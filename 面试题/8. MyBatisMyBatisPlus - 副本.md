## 1. ORM框架? MyBatis优缺点?

ORM（Object-Relational Mapping）框架是一种在编程中将面向对象的概念与关系型数据库的表结构进行映射的技术。它使得开发者可以使用面向对象的方式来操作数据库，而不需要直接编写SQL语句。在Java中，MyBatis是一个流行的ORM框架，它支持自定义SQL、存储过程以及高级映射。

### MyBatis的优点包括：
1. **灵活性**：MyBatis允许开发者编写自定义的SQL语句，这使得它在处理复杂查询时非常灵活。
2. **性能**：由于MyBatis允许开发者直接控制SQL执行，它可以提供比全自动ORM框架更好的性能。
3. **易于维护**：MyBatis将SQL语句与Java代码分离，使得SQL语句的维护和优化更加集中和方便。
4. **与Spring框架的集成**：MyBatis可以很容易地与Spring框架集成，实现依赖注入和事务管理。
5. **支持多种数据库**：MyBatis不仅限于特定的数据库，它可以与多种数据库一起工作，如MySQL、Oracle、SQL Server等。

### MyBatis的缺点包括：
1. **SQL编写工作量**：与全自动ORM框架相比，MyBatis需要开发者手动编写SQL语句，这可能会增加工作量。
2. **数据库移植性**：由于SQL语句通常针对特定的数据库编写，因此在更换数据库时可能需要重写SQL语句。
3. **学习曲线**：对于初学者来说，MyBatis的学习曲线可能比较陡峭，因为它需要理解SQL映射和配置文件。
4. **配置复杂性**：MyBatis需要配置大量的XML文件或注解，这可能会使项目结构变得复杂。

### 适用场景：
MyBatis适用于对性能要求较高、需求变化频繁的项目，特别是当项目需要直接控制SQL语句以优化性能时。它也适用于那些已经存在复杂数据库结构和SQL语句的遗留系统。

总的来说，MyBatis是一个强大且灵活的ORM框架，它通过减少代码量、提供灵活的SQL映射和支持复杂的查询操作，帮助开发者更高效地进行数据库编程。然而，它也需要开发者具备一定的SQL编写能力和对框架的理解。

## 2.  类的属性名和数据库字段名不一致？

在MyBatis中，当数据库字段名与实体类属性名不一致时，有几种常用的解决方案：

1. **使用SQL中的别名**：
   在SQL查询中，可以直接给字段起别名，使其与实体类属性名一致。例如：
   
   ```xml
   <select id="selectUser" resultType="User">
       SELECT id, username AS name, password AS pwd FROM user
   </select>
   ```
   这种方法简单直接，但如果字段较多，会导致SQL语句变得冗长。
   
2. **使用`<resultMap>`标签**：
   在MyBatis的映射文件中，可以使用`<resultMap>`标签来定义字段与属性之间的映射关系。例如：
   ```xml
   <resultMap id="UserMap" type="User">
       <result property="id" column="id"/>
       <result property="name" column="username"/>
       <result property="password" column="password"/>
   </resultMap>
   <select id="selectUser" resultMap="UserMap">
       SELECT id, username, password FROM user
   </select>
   ```
   这种方法更加灵活，尤其是当需要映射的字段较多或者需要进行复杂映射时。

3. **开启驼峰命名自动映射**：
   在MyBatis配置文件中，可以设置`mapUnderscoreToCamelCase`属性为`true`，这样MyBatis会自动将数据库中的下划线命名（如`user_name`）映射到实体类中的驼峰命名（如`userName`）：
   ```xml
   <settings>
       <setting name="mapUnderscoreToCamelCase" value="true"/>
   </settings>
   ```
   这种方法适用于数据库字段名遵循下划线命名规则，而实体类属性名遵循驼峰命名规则的情况。

4. **使用`@Column`注解**（仅适用于MyBatis 3.4.5及以后版本）：
   在实体类中，可以直接使用`@Column`注解来指定数据库字段名。例如：
   ```java
   public class User {
       private Integer id;
       private String name;
       private String password;
       
       @Column("username")
       public String getName() {
           return name;
       }
       
       @Column("pwd")
       public String getPassword() {
           return password;
       }
   }
   ```
   这种方法可以避免修改映射文件，使代码更加简洁。

选择哪种方法取决于具体的项目需求和个人偏好。通常，`<resultMap>`标签提供了最大的灵活性和可维护性，而开启驼峰命名自动映射则可以减少配置的复杂性。

## 3. MyBatis 的执行流程?

> 1. 加载配置文件 2.创建sqlSessionFactory 3.创建sqlsession表示一次会话 4.执行sql 5.结果映射 6.返回结果关闭sqlsession

MyBatis 的执行流程涉及多个步骤，从用户发起请求到最终数据库操作完成，整个过程包括以下几个主要环节：

1. **初始化 MyBatis**：
   - 加载 MyBatis 配置文件（`mybatis-config.xml`），创建 `SqlSessionFactory` 实例。

2. **创建 SqlSession**：
   - 通过 `SqlSessionFactory` 创建 `SqlSession` 实例，它是 MyBatis 执行持久化操作的主要对象。

3. **映射器注册**：
   - 通过配置文件或注解的方式，将 Mapper 接口与对应的 XML 映射文件注册到 MyBatis 框架中。

4. **执行持久化操作**：
   - 用户通过 Mapper 接口调用持久化方法，这些方法与 XML 映射文件中的 SQL 语句相对应。

5. **解析映射文件**：
   - MyBatis 解析映射文件（XML），将 SQL 语句和 Java 对象映射关系注册到 `SqlSession` 中。

6. **SQL 语句执行**：
   - `SqlSession` 根据用户请求找到对应的 SQL 语句，执行 SQL 操作（查询、插入、更新或删除）。

7. **结果映射**：
   - 将 SQL 执行结果映射到 Java 对象中，MyBatis 支持自动映射和手动映射（通过 `resultMap`）。

8. **事务管理**：
   - MyBatis 支持声明式事务管理，可以通过注解或 XML 配置事务的传播行为。

9. **错误处理**：
   - 如果在执行过程中发生异常，MyBatis 会进行异常处理，包括回滚事务等。

10. **关闭 SqlSession**：
    - 操作完成后，需要关闭 `SqlSession` 以释放数据库资源。

11. **获取映射器**：
    - 通过 `SqlSession` 获取 Mapper 接口的代理对象，用户可以通过这个代理对象调用映射的 SQL 语句。

以下是一个简化的 MyBatis 执行流程图：

```
用户请求 -> SqlSession -> 映射器接口 -> 映射文件解析 -> SQL 执行 -> 结果映射 -> 事务管理 -> 关闭 SqlSession
```

在实际应用中，MyBatis 还提供了许多高级特性，如动态 SQL、缓存机制、插件系统等，这些特性可以进一步扩展和优化 MyBatis 的执行流程。

## 4. MyBatis异常？

1. **PersistenceException**：这是MyBatis中的顶级异常，通常是由其他异常引起的。要获取详细的异常信息，可以开启MyBatis的日志功能，设置日志级别为`TRACE`或`DEBUG`，以便查看完整的异常栈轨迹。

2. **BuilderException**：通常与MyBatis的配置文件有关，如映射文件路径错误或SQL语句错误。

3. **ReflectionException**：与反射相关，可能是由于在映射文件中指定的类或方法不存在。

4. **BindingException**：通常发生在Mapper接口与映射文件不一致时。

5. **SQLSyntaxErrorException**：SQL语句编写错误，如语法错误或列名错误。

6. **TooManyResultsException**：当`selectOne()`方法期望返回一个结果，但实际上返回了多个结果时抛出。

7. **DuplicateKeyException**：数据库中存在重复的主键值时抛出。

8. **ParameterHandler和ResultHandler异常**：处理参数或结果集时可能抛出的异常。

9. **MyBatisSystemException**：系统内部错误，如数据库连接问题或配置问题。

处理MyBatis异常时，应该首先查看异常信息，确定异常的原因。然后，根据异常的具体类型，采取相应的解决措施，如检查SQL语句、数据库连接信息、MyBatis配置文件等。如果需要更详细的异常处理方法，可以查阅MyBatis官方文档或社区支持。

此外，还有一些常见的错误，如配置文件错误、SQL语句错误、类型不匹配、数据库连接问题等。解决这些问题通常需要仔细检查配置文件、SQL语句、确保数据库服务运行正常，并确保MyBatis配置文件正确无误。

在开发过程中，良好的异常处理和清晰的日志记录对于快速定位和解决问题至关重要。

## 5. ${}和#{}?

在 MyBatis 中，`${}` 和 `#{}` 是用于在 SQL 语句中插入参数的两种不同方式，它们的主要区别在于处理方式和用途：

1. **`#{}`（预处理参数）**：
   - `#{}` 是参数占位符，MyBatis 会将其替换为预处理语句（`PreparedStatement`）的参数占位符 `?`。
   - 使用 `#{}` 时，MyBatis 会自动为 SQL 参数提供适当的转义，防止 SQL 注入攻击。
   - `#{}` 可以有效地防止 SQL 注入，因为它允许数据库在执行前预编译 SQL 语句，从而避免了参数的直接替换。
   - 例如：`SELECT * FROM users WHERE id = #{id}`。

2. **`${}`（字符串替换）**：
   - `${}` 是文本替换，MyBatis 会将其替换为实际的字符串值。
   - 使用 `${}` 时，参数值将直接拼接到 SQL 语句中，没有预处理或转义。
   - `${}` 可能会导致 SQL 注入攻击，因为它直接将参数值插入到 SQL 语句中。
   - 例如：`SELECT * FROM users WHERE name = '${name}'`。

### 什么情况下一定要使用 `${}`？

你应该在以下情况下使用 `${}`：

1. **动态表名或列名**：
   - 当你需要动态地指定表名或列名时，因为这些通常不能作为预处理语句的参数。

2. **排序字段**：
   - 当你需要根据用户输入的字段进行排序时，例如：`ORDER BY ${sortField}`。

3. **复杂的条件**：
   - 当你需要构建复杂的 SQL 条件，而这些条件不能通过预处理参数实现时。

### 注意事项：

- 由于 `${}` 可能会导致 SQL 注入风险，因此在使用时应该非常小心，确保动态插入的值是可信的，或者使用其他方式对其进行验证和转义。
- 在可能的情况下，推荐优先使用 `#{}`，因为它更安全。

### 示例：

```xml
<!-- 使用 #{} 预处理参数 -->
<select id="selectUserById" resultType="User">
  SELECT * FROM users WHERE id = #{id}
</select>

<!-- 使用 ${} 字符串替换 -->
<select id="selectUserByName" resultType="User">
  SELECT * FROM users WHERE name = '${name}'
</select>
```

在第一个示例中，`#{}` 用于参数替换，MyBatis 会为 `id` 参数创建预处理语句，这有助于防止 SQL 注入。

在第二个示例中，`${}` 用于字符串替换，这可能会带来 SQL 注入风险，因此应该谨慎使用，并确保 `name` 参数是安全的。

## 6. 什么是 SQL 注入?如何预防？

### 什么是SQL注入？

SQL注入（SQL Injection）是一种常见的网络安全攻击技术，它允许攻击者插入或“注入”一个或多个SQL语句到原本的查询中，使得攻击者可以执行未授权的数据库命令。这种攻击利用了应用程序在处理用户输入时的安全漏洞，攻击者可以通过修改Web应用的输入字段来改变SQL语句的意图。

### SQL注入的危害

1. **数据泄露**：攻击者可以访问或窃取数据库中的敏感信息。
2. **数据篡改**：攻击者可以修改或删除数据库中的数据。
3. **认证绕过**：攻击者可以绕过登录认证，直接访问后台系统。
4. **系统控制**：在某些情况下，攻击者可能通过SQL注入控制整个数据库服务器。

### 如何预防SQL注入？

1. **使用预处理语句（Prepared Statements）**：
   - 预处理语句是防止SQL注入的最有效方法之一。它们通过使用参数化查询来分离SQL代码和数据，确保用户输入不会作为SQL命令的一部分执行。

2. **使用ORM框架**：
   - 对象关系映射（ORM）框架通常提供了内置的防护措施来防止SQL注入。

3. **使用参数化查询**：
   - 在编写SQL语句时，使用参数化查询而不是将用户输入直接拼接到SQL语句中。

4. **转义用户输入**：
   - 对所有用户输入进行适当的转义，以确保特殊字符不会改变SQL语句的结构。

5. **限制数据库权限**：
   - 应用程序使用的数据库账户应该只有完成其功能所必需的最小权限，例如，如果应用程序不需要修改数据，那么该账户应该只有查询权限。

6. **使用Web应用防火墙（WAF）**：
   - WAF可以帮助检测和阻止SQL注入攻击。

7. **定期更新和打补丁**：
   - 保持应用程序和数据库系统的软件更新，以修复已知的安全漏洞。

8. **错误处理**：
   - 不要在错误消息中显示敏感信息，如数据库结构或SQL语句，这可能会给攻击者提供有用的信息。

9. **输入验证**：
   - 对所有用户输入进行验证，拒绝不符合预期模式的输入。

10. **使用安全的API和库**：
    - 选择那些设计时就考虑了安全性的API和库。

通过采取这些预防措施，可以显著降低应用程序受到SQL注入攻击的风险。安全编程的最佳实践是始终假设所有用户输入都是潜在的攻击载体，并对其进行相应的处理。

## 7. MyBatis 中如何实现分页?

在MyBatis中实现分页通常有几种方法，以下是一些常见的分页实现方式：

### 1. 使用MyBatis拦截器（Interceptor）实现自动分页

MyBatis提供了拦截器（Interceptor）机制，可以编写自定义拦截器来实现分页。这种方式可以在不修改现有SQL语句的情况下实现分页。

一个流行的分页拦截器是PageHelper，它是一个开源的MyBatis分页插件，可以自动地对SQL语句进行分页处理。

使用PageHelper的示例：

```java
// 在配置文件中添加PageHelper插件
<plugins>
    <plugin interceptor="com.github.pagehelper.PageInterceptor">
        <property name="helperDialect" value="mysql"/>
    </plugin>
</plugins>

// 在Mapper接口中使用PageHelper提供的分页方法
public interface UserMapper {
    List<User> selectPage(int pageNum, int pageSize);
}

// 在服务层调用分页方法
public class UserService {
    public List<User> getPageUsers(int pageNum, int pageSize) {
        return userMapper.selectPage(pageNum, pageSize);
    }
}
```

### 2. 在SQL语句中手动实现分页

这种方式需要在SQL语句中使用LIMIT子句（对于MySQL）或其他数据库特定的分页语法来实现分页。

MySQL示例：

```xml
<select id="selectUsersByPage" resultType="User">
    SELECT * FROM users
    LIMIT #{offset}, #{pageSize}
</select>
```

在这种情况下，你需要传递`offset`（起始位置）和`pageSize`（每页大小）作为参数。

### 3. 使用MyBatis的动态SQL功能

MyBatis的动态SQL功能（如`<if>`标签）可以用来根据分页参数条件动态构建SQL语句。

```xml
<select id="selectUsersByPage" resultType="User">
    SELECT * FROM users
    <if test="pageNum != null and pageSize != null">
        LIMIT #{pageNum}, #{pageSize}
    </if>
</select>
```

### 4. 使用物理分页（RowBounds）

MyBatis提供了`RowBounds`对象，它可以用来指定查询的偏移量和限制，从而实现物理分页。

```java
// 在Mapper接口的方法中使用RowBounds
public interface UserMapper {
    List<User> selectUsersByRowBounds(RowBounds rowBounds);
}

// 在服务层中调用
SqlSession sqlSession = sqlSessionFactory.openSession();
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
RowBounds rowBounds = new RowBounds(0, 10); // 从第一条数据开始，限制10条数据
List<User> users = userMapper.selectUsersByRowBounds(rowBounds);
```

### 5. 使用后处理分页（Post-pagination）

在某些情况下，可以先查询出所有数据，然后在应用层面进行分页处理。这种方式适用于数据量不大的情况。

```java
public List<User> getPageUsers(List<User> allUsers, int pageNum, int pageSize) {
    int start = (pageNum - 1) * pageSize;
    int end = pageNum * pageSize;
    return allUsers.subList(start, Math.min(end, allUsers.size()));
}
```

在选择分页方法时，应考虑应用程序的具体需求、数据量大小以及数据库类型。对于大型数据集，推荐使用数据库层面的分页，以减少内存消耗和提高性能。对于数据量较小的情况，可以考虑在应用层面进行分页处理。

## 8. MyBatisPlus是如何实现分页的?

MyBatisPlus 是一个 MyBatis 的增强工具，它提供了包括分页查询在内的多种功能。在 MyBatisPlus 中实现分页主要依赖于其内置的分页插件 `PaginationInnerInterceptor`。

### 如何实现分页？

1. **配置分页插件**：
   在 Spring Boot 的配置类中添加分页插件的配置。这通常在 `application.yml` 或 `application.properties` 文件中进行，或者通过 Java 配置类的方式。

   ```java
   @Configuration
   public class MybatisPlusConfig {
       @Bean
       public MybatisPlusInterceptor mybatisPlusInterceptor() {
           MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
           interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
           return interceptor;
       }
   }
   ```

2. **使用分页方法**：
   在 Mapper 接口中，可以直接使用 MyBatisPlus 提供的 `selectPage` 方法进行分页查询。

   ```java
   public interface UserMapper extends BaseMapper<User> {
       IPage<User> selectPageVo(IPage<User> page, @Param("age") Integer age);
   }
   ```

3. **调用分页查询**：
   在服务层或控制器层调用 Mapper 的分页方法，并传入 `Page` 对象和其他查询条件。

   ```java
   @Service
   public class UserService {
       @Autowired
       private UserMapper userMapper;
       public IPage<User> getUserPage(int pageNum, int pageSize) {
           Page<User> page = new Page<>(pageNum, pageSize);
           return userMapper.selectPage(page, new QueryWrapper<>());
       }
   }
   ```

4. **自定义分页查询**：
   如果需要自定义 SQL 进行分页查询，可以在 Mapper 接口中定义方法，并在对应的 XML 文件中编写 SQL 语句。

   ```xml
   <!-- UserMapper.xml -->
   <select id="selectPageVo" resultType="User">
       SELECT * FROM users WHERE age > #{age}
   </select>
   ```

5. **性能优化**：
   MyBatisPlus 分页插件提供了一些性能优化的配置，如 `setMaxLimit` 用于限制单页最大数量，避免一次性查询过多数据。

### 优点和缺点

**优点**：
- 简化了分页查询的实现，开发者不需要手动编写分页 SQL。
- 提供了丰富的配置选项和灵活的分页策略。
- 通过拦截器机制自动处理分页，减少了代码侵入性。

**缺点**：
- 对于复杂的分页查询，可能需要自定义 SQL，这增加了开发和维护的复杂性。
- 分页插件可能会对性能产生一定影响，尤其是在大数据量的情况下。

### 总结

MyBatisPlus 的分页插件为开发者提供了一种简单、高效的方式来实现分页查询，同时也提供了一定的灵活性和性能优化选项。在实际开发中，应根据项目需求和数据量大小选择合适的分页策略。

## 9. 动态 SQL?

动态SQL是指在程序运行时根据条件动态生成或修改SQL语句的技术。这种方式允许开发者根据不同的输入参数或业务逻辑构建定制化的SQL查询，而不是在编写代码时静态地定义SQL语句。

动态SQL的主要优点包括：

1. **灵活性**：可以根据不同的条件构建不同的查询，使得程序能够适应更多的业务场景。

2. **可扩展性**：随着业务需求的变化，可以轻松地扩展或修改SQL语句，而不需要重写整个查询。

3. **性能**：在某些情况下，动态SQL可以避免不必要的数据加载，从而提高查询性能。

4. **用户交互**：在用户交互式应用程序中，可以根据用户的输入动态构建查询，提供个性化的数据检索。

在Java中，MyBatis 和 MyBatis Plus 等ORM框架提供了动态SQL的功能。这些框架允许开发者使用特定的标签和语法来构建动态SQL语句。例如，MyBatis中的 `<if>` 标签和 `<choose>`、`<when>`、`<otherwise>` 等子标签可以用来根据条件包含或排除SQL片段。

以下是一些动态SQL的例子：

### MyBatis中的动态SQL：

```xml
<select id="selectUsers" resultType="User">
  SELECT *
  FROM users
  <where>
    <if test="id != null">
      id = #{id}
    </if>
    <if test="name != null">
      AND name = #{name}
    </if>
    <if test="email != null">
      AND email = #{email}
    </if>
  </where>
</select>
```

在这个例子中，`<where>` 标签用于构建条件语句，`<if>` 标签用于根据是否存在条件动态地包含SQL片段。

### MyBatis Plus中的动态SQL：

MyBatis Plus 也支持动态SQL，但它更倾向于使用Lambda查询和Wrapper来构建动态SQL，这样可以更自然地表达查询条件。

```java
QueryWrapper<User> queryWrapper = new QueryWrapper<>();
if (id != null) {
    queryWrapper.eq("id", id);
}
if (name != null) {
    queryWrapper.eq("name", name);
}
if (email != null) {
    queryWrapper.eq("email", email);
}
List<User> users = userMapper.selectList(queryWrapper);
```

在这个Java代码示例中，`QueryWrapper` 用于构建动态查询条件，可以根据条件的存在与否添加不同的查询条件。

动态SQL是处理复杂业务逻辑和构建灵活、可扩展应用程序的强大工具。然而，它也增加了SQL语句的复杂性，因此在设计时需要仔细考虑以确保代码的可读性和可维护性。

## 10. MyBatis的一级缓存和二级缓存？sqlsession是什么？

### MyBatis 的缓存机制

MyBatis 支持两种级别的缓存：一级缓存（Local Cache）和二级缓存（Global Cache）。

1. **一级缓存（Local Cache）**：
   - 一级缓存是 MyBatis 中 `SqlSession` 的一个内置缓存，它的作用域仅限于当前的 `SqlSession`。
   - 当同一个 `SqlSession` 内执行多个查询时，一级缓存可以避免重复查询数据库，从而提高性能。
   - 一级缓存是自动存在的，通常不需要手动配置。
   - 一级缓存的数据在 `SqlSession` 关闭后会失效。

2. **二级缓存（Global Cache）**：
   - 二级缓存是跨 `SqlSession` 的，它可以被多个 `SqlSession` 共享。
   - 二级缓存需要在 MyBatis 配置文件中显式配置，并且可以设置不同的缓存策略和存储介质。
   - 二级缓存适用于多个 `SqlSession` 之间共享数据，减少数据库的访问次数。
   - 二级缓存可以通过配置文件中的 `<cache>` 标签来开启，并且可以指定具体的缓存实现类。

### SqlSession

`SqlSession` 是 MyBatis 中的核心概念，它是执行持久化操作的主要对象。以下是 `SqlSession` 的一些关键点：

1. **执行 SQL 命令**：
   - `SqlSession` 提供了执行 SQL 命令的方法，如 `selectOne`、`selectList`、`insert`、`update`、`delete` 等。

2. **管理事务**：
   - `SqlSession` 可以控制事务的边界，通过 `commit` 和 `rollback` 方法来提交或回滚事务。

3. **获取映射器**：
   - `SqlSession` 可以获取映射器（Mapper）对象，通过映射器可以访问数据库操作。

4. **关闭资源**：
   - `SqlSession` 需要手动关闭，以释放数据库连接和其他资源。

5. **一级缓存**：
   - `SqlSession` 内置了一级缓存，可以缓存查询结果，避免重复查询。

### 缓存的使用场景

- **一级缓存**通常用于单个事务中，当一个事务需要多次查询相同的数据时，一级缓存可以提供快速的数据访问。
- **二级缓存**适用于分布式系统中，或者在多个事务中需要共享数据的场景，如用户信息、商品信息等。

### 配置二级缓存

在 MyBatis 配置文件中，可以通过 `<cache>` 标签来配置二级缓存：

```xml
<configuration>
  <cache type="org.mybatis.cache.impl.PerpetualCache"/>
  <cache-ref namespace="com.example.mapper.OtherMapper"/>
</configuration>
```

在这个配置中，`<cache>` 标签定义了二级缓存的类型，`<cache-ref>` 标签引用了其他映射器的缓存配置。

### 注意事项

- 缓存可以提高性能，但也可能导致数据不一致的问题，特别是在数据更新频繁的场景中。
- 需要合理配置缓存的有效期和清空策略，以确保数据的实时性和准确性。

MyBatis 的缓存机制是其优化数据库访问性能的重要特性之一，通过合理使用缓存，可以显著提高应用程序的响应速度和处理能力。

## 11. MyBatis二级缓存?

在MyBatis中，开启二级缓存需要进行一些配置。以下是开启二级缓存的步骤：

1. **全局配置**：
   在MyBatis的全局配置文件`mybatis-config.xml`中，确保`cacheEnabled`设置为`true`。这是开启二级缓存的全局开关。

   ```xml
   <settings>
       <setting name="cacheEnabled" value="true"/>
   </settings>
   ```

2. **Mapper配置**：
   在具体的Mapper XML文件中，添加`<cache>`标签来启用二级缓存。可以为`<cache>`标签添加一些属性，如`eviction`（缓存回收策略）、`flushInterval`（刷新间隔）、`size`（缓存大小）和`readOnly`（是否只读）。

   ```xml
   <mapper namespace="com.example.mapper.UserMapper">
       <cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/>
       ...
   </mapper>
   ```

3. **实体类序列化**：
   使用二级缓存时，MyBatis要求返回的POJO（Plain Old Java Object）必须是可序列化的，也就是要求实现`Serializable`接口。

   ```java
   public class User implements Serializable {
       ...
   }
   ```

4. **使用二级缓存**：
   在Mapper接口的方法上，可以通过`@CacheNamespace`注解来启用二级缓存，或者在XML映射文件中使用`<cache>`标签来启用。

   ```java
   @CacheNamespace
   public interface UserMapper {
       ...
   }
   ```

5. **测试二级缓存**：
   可以通过编写测试代码来验证二级缓存是否生效。通常，在一个`SqlSession`中查询数据后，关闭`SqlSession`，然后在另一个`SqlSession`中再次查询相同的数据，如果数据能够从缓存中获取，说明二级缓存生效了。

   ```java
   public void testSecondLevelCache() throws IOException {
       SqlSessionFactory sqlSessionFactory = ...;
       try (SqlSession sqlSession1 = sqlSessionFactory.openSession()) {
           UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class);
           User user = mapper1.findById(1);
           sqlSession1.close();
       }
       try (SqlSession sqlSession2 = sqlSessionFactory.openSession()) {
           UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);
           User user = mapper2.findById(1);
           sqlSession2.close();
       }
   }
   ```

请注意，二级缓存是基于Mapper的命名空间进行缓存的，因此相同的命名空间下的查询会共享缓存。同时，二级缓存可能会带来脏读的问题，因此在某些场景下可能需要谨慎使用。在分布式系统中，通常建议使用如Redis这样的分布式缓存来替代MyBatis的二级缓存。

## 12. Mybatis为什么不默认开启二级缓存？

MyBatis 默认不开启二级缓存的原因有以下几个:
1. **分布式环境下数据一致性问题**:在一个分布式环境下，多个应用实例共享同一个数据库，如果开启了二级缓存，其中一个实例对数据库进行了更新操作(如插入、修改、删除)，而其他实例的缓存中仍然保存着旧的数据，就会导致数据不一致的问题。
2. **业务场景问题**:二级缓存适用于读多写少、数据相对静态的场景，但在许多实际项目中，这类场景并不常见。因此，默认关闭二级缓存可以确保框架在大多数情况下都能灵活应对不同需求。
3. **内存占用问题**:开启二级缓存后，缓存的数据需要占用一定的内存空间。如果没有合适的策略来管理缓存，可能会导致内存占用过多的问题。
4. **复杂性和配置问题**:二级缓存的配置需要考虑很多因素，包括缓存的刷新策略、缓存的清理策略等等。这增加了配置的复杂性和可能引入配置错误的风险。
5. **缓存设计相对简单**:MyBaits 中的缓存设计的相对比较简单，例如 MyBaits 缓存的数据默认只能保存 1024个，且缓存淘汰策略比较简单，只有几种策略可供选择。

## 13. MyBaits有几种缓存淘汰策略?如何设置缓存淘汰策略?

MyBatis 有哪些缓存淘汰策略?
MyBatis 中可用的缓存策略有以下几个:
1. LRU-最近最少使用:移除最长时间不被使用的对象。
2. FIFO-先进先出:按对象进入缓存的顺序来移除它们。
3. SOFT-软引用:基于垃圾回收器状态和软引用规则移除对象。
4. WEAK-弱引用:更积极地基于垃圾收集器状态和弱引用规则移除对象。

**默认的缓存淘汰策略是 LRU。**
flushInterval(刷新间隔)默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。当设置flushInterval 后，MyBatis 会周期性地检查是否需要刷新二级缓存，避免数据过期或脏数据的问题。当超过设定的时间间隔时，MyBatis 会自动清空二级缓存，下次查询时会重新加载最新的数据到缓存中。size(引|用数目)属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。

## 14. MyBatis中使用里哪些设计模式？ ★
**1. 工厂模式**
工厂模式想必都比较熟悉，它是 Java 中最常用的设计模式之一。工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。这就好比你去餐馆吃饭，可以直接点菜，而不用考虑厨师是怎么做的。工厂模式在 MyBatis 中的典型代表是 SqlSessionfactory。SqlSession 是 MyBatis 中的重要 Java 接口，可以通过该接口来执行 SQL 命令、获取映射器示例和管理事务，而 SqlSessionfactory 正是用来产生 SqlSession 对象的，所以它在 MyBatis 中是比较核心的接口之一。

**2. 建造者模式**
建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。例如，组装电脑，最终的产品就是一台主机，然而不同的人对它的要求是不同的，比如设计人员需要显卡配置高的:而影片爱好者则需要硬盘足够大的(能把视频都保存起来)，但对于显卡却没有太大的要求，我们的装机人员根据每个人不同的要求，组装相应电脑的过程就是建造者模式。建造者模式在 MyBatis 中的典型代表是 SalSessionfactoryBuilder，普通的对象都是通过 new 关键字直接创建的但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者不能一次性得到构建所需的所有参数，那么就需要将构建逻辑从对象本身抽离出来，让对象只关注功能，把构建交给构建类，这样可以简化对象的构建，也可以达到分步构建对象的日的，而 SalSessionfactoryBuilder 的构建过程正是如此
**链式调用是建造者模式的一种常见表现形式，它使得建造者模式的代码更加简洁和易于理解。**

**3.单例模式**
单例模式(Singleton Pattern)是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类。
单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，每个收费站的窗口都只能一辆车子一辆车子的经过，类似的场景都是属于单例模式。单例模式在 MyBatis 中的典型代表是 ErrorContext。
ErrorContext 是线程级别的的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。

**4.适配器模式**
适器模式是指将一个不兼容的接口转换成另一个可以兼容的接口，这样就可以使那些不兼容的类可以一起工作。列如，最早之前我们用的耳机都是圆形的，而现在大多数的耳机和电源都统一成了方形的 typec 接口，那之前的圆形耳机就不能使用了，只能买一个适配器把圆形接口转化成方形的，如下图所示:
而这个转换头就相当于程序中的适配器模式，适配器模式在 MyBatis 中的典型代表是 Log.MyBatis 中的日志模块适配了以下多种日志类型:
SLF4J
Apache Commons Logging
Log4j2
Log4j
JDK logging

**5.代理模式**
代理模式指的是给某一个对象提供一个代理对象，并由代理对象控制原对象的调用。代理模式在生活中也比较常见，比如我们常见的超市、小卖店其实都是一个个"代理”，他们的最上游是一个个生产厂家，他们这些代理负责把厂家生产出来的产品卖出去，代理模式在 MyBatis 中的典型代表是 MapperProxyFactory。
MapperProxyFactory 的 newInstance()方法就是生成一个具体的代理来实现某个功能,

**6.模板方法模式**
模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。
例如，我们喝茶的一般步骤都是这样的:
把热水烧开
把茶叶放入壶中
等待一分钟左右
把茶倒入杯子中
喝茶
整个过程都是固定的，唯一变的就是泡入茶叶种类的不同，比如今天喝的是绿茶，明天可能喝的是红茶，那么我们就可以把流程定义为一个模板，而把茶叶的种类延伸到子类中去实现，这就是模板方法的实现思路模板方法在 MyBatis 中的典型代表是 BaseExecutor，在 MyBatis 中 BaseExecutor 实现了大部分 SOL 执行的透辑。

**7.装饰器模式**
装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。
装饰器模式在生活中很常见，比如装修房子，我们在不改变房子结构的同时，给房子添加了很多的点缀:比如安装了天然气报警器，增加了热水器等附加的功能都属于装饰器模式。装饰器模式在 MyBatis 中的典型代表是 Cache。
Cache 除了有数据存储和缓存的基本功能外(由 PerpetualCache 永久缓存实现)还有其他附加的 Cache 类，比如先进先出的 FifoCache、最近最少使用的 LruCache 等众多附加功能的缓存类