## 1. JVM的运行过程?

> java-字节码-类加载器-运行时数据区-执行引擎-本地方法库

JVM(Java Virtual Machine，Java 虚拟机)是 Java 程序的运行环境，它负责将 Java 字节码翻译成机器代码并执行。也就是说 Java 代码之所以能够运行，主要是依靠 JVM 来实现的。JVM 执行的主流流程如下:
1. 程序在执行之前先要把 **Java 代码转换成字节码**(class 文件)，JVM首先需要把字节码通过一定的方式**类加载器**(ClassLoader)把文件加载到内存中**运行时数据区**(Runtime Data Area)。
2. 但字节码文件是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器也就是 JVM 的**执行引擎**(Execution Engine)会将**字节码翻译成底层系统指令**再交由 CPU 去执行。
3. 在执行的过程中，也需要调用其他语言的接口，如通过调用本地库接口(Native Interface) 来实现整个程序的运行，如下图所示:

所以，整体来看， JVM 主要通过分为以下4个部分来执行 Java 程序的:

1. 类加载器(ClassLoader)
2. 运行时数据区(Runtime Data Area)
3. 执行引擎(Execution Engine)
4. 本地库接口(Native Interface)

## 2. JVM内存布局?

> 线程共享：堆、方法去 线程私有：虚拟机栈、本地方法栈、程序计数器

JVM（Java虚拟机）的内存布局是指JVM在执行Java程序时所管理的内存区域的组织方式。它包括以下几个主要部分：

1. **程序计数器（Program Counter Register）**：
   - 每个线程都有自己的程序计数器，用于存储当前执行的字节码指令的地址或直接执行的本地方法的地址。

2. **Java虚拟机栈（Java Virtual Machine Stack）**：
   - 每个线程在创建时都会创建一个虚拟机栈，用于存储局部变量、操作数栈、动态链接和方法出口等信息。

3. **本地方法栈（Native Method Stack）**：
   - 与虚拟机栈类似，但它为本地方法服务。在JVM中，本地方法栈可以是虚拟机栈的一部分，也可以是独立的。

4. **堆（Heap）**：
   - 堆是JVM中最大的内存区域，用于存储对象实例和数组。堆是所有线程共享的，并且是垃圾回收器的主要工作区域。

5. **方法区（Method Area）**：
   - 方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在Java 8之前，这部分被称为永久代（PermGen），而在Java 8及以后的版本中，这部分被元空间（Metaspace）所取代。

6. **直接内存（Direct Memory）**：
   - 不是JVM运行时数据区的一部分，但它是JVM通过NIO直接管理的内存，通常用于存储大数据缓冲区。

## 3. 方法区、永久代和元空间?

> 方法区：类的元数据、常量、静态变量
>
> 永久代：①有大小限制-容易溢出 ②使用的是堆内存 ③字符串常量池放在永久代中
>
> 元空间：①没有大小限制 ②使用本地内存 ③字符串放在了堆中， 运行时常量池放在永久代中

在Java虚拟机（JVM）中，方法区、永久代和元空间是与存储类的元数据、常量、静态变量等相关的内存区域。它们之间的关系和区别如下：

1. **方法区（Method Area）**：
   - 方法区是JVM规范中定义的一个逻辑区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   - 方法区是线程共享的内存区域，它在JVM启动时被创建。

2. **永久代（PermGen）**：
   - 永久代是方法区在Java 8之前的HotSpot虚拟机中的实现。它用于存储类的元数据、静态变量、常量池等信息。
   - 永久代的大小有限，可以通过 `-XX:PermSize` 和 `-XX:MaxPermSize` 参数进行调整。
   - 永久代的问题在于容易造成内存溢出，尤其是动态生成类的情况，如大量使用JSP页面或动态类加载。

3. **元空间（Metaspace）**：
   - 从Java 8开始，HotSpot虚拟机引入了元空间来替代永久代。元空间用于存储类的元数据，但它不位于JVM堆内存中，而是使用本地内存（即操作系统的内存）。
   - 元空间的大小受本地内存限制，可以通过 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 参数进行调整。
   - 元空间的优点包括更好的内存管理、更高的垃圾回收效率，以及避免了永久代的内存溢出问题。

4. **关系和区别**：
   - 方法区是JVM规范中的一个概念，而永久代和元空间是方法区的具体实现。
   - 永久代和元空间的主要区别在于它们的位置（永久代在JVM堆中，元空间在本地内存中）、大小限制（永久代有固定大小，元空间大小受本地内存限制）、以及垃圾回收效率（元空间更高）。

5. **常量池的变化**：
   - 在Java 7及之前，字符串常量池位于永久代中。从Java 7开始，字符串常量池被移动到堆中。
   - Java 8中，运行时常量池也随着元空间的引入而移动到元空间中。

6. **总结**：
   - 方法区、永久代和元空间是JVM内存模型中的重要组成部分，它们随着Java版本的发展而经历了变迁。
   - Java 8引入元空间是为了解决永久代的内存溢出问题，提高内存管理的灵活性和垃圾回收的效率。



## 4. 字符串常量池？

> 1. 为什么字符串会有常量池？ final
> 2. 如何查找字符串是否在常量池中？String.intern
> 3. 存放位置？永久代-元空间

在Java中，`String` 类的 `intern()` 方法用于在字符串常量池中查找一个字符串，如果常量池中已经存在该字符串，则返回常量池中该字符串的引用；如果不存在，则在常量池中创建一个新的字符串，并返回新创建的字符串的引用。这个过程被称为字符串的“国际化”。

字符串常量池是JVM在内存中分配的一块区域，用于存储所有字符串字面量和通过 `intern()` 方法显式加入的字符串。这样做的目的是为了节省内存空间，避免相同的字符串在内存中重复存储。

在Java 7之前，字符串常量池位于永久代（PermGen）中，这是一个内存区域，用于存储类的元数据。由于永久代的大小是有限的，当字符串常量池中的字符串过多时，可能会导致 `OutOfMemoryError` 异常。因此，Java 7开始将字符串常量池从永久代移到了Java堆中。

在Java 8中，永久代被元空间（Metaspace）所取代，元空间使用本地内存，而不是JVM管理的内存。这意味着字符串常量池的大小不再受到JVM内存限制，而是受到本地系统内存的限制。

字符串常量池的设计和实现对于Java程序的性能和内存管理至关重要。通过合理使用字符串常量池，可以有效地减少内存使用，提高程序的运行效率。同时，理解字符串常量池的工作原理也有助于开发者更好地理解和使用Java中的字符串操作。

## 6. 堆溢出?

> 1. 堆中存放的是创建好的对象
> 2. 溢出原因：堆内的对象过多、无法被垃圾回收
> 3. 造成原因：①内存泄漏 ②无线递归创建大量对象 ③创建大量大的对象 ④没有合理设置堆的大小

堆溢出(Heap Overflow)通常是指堆内存中的对象过多、无法被垃圾回收所导致的内存溢出错误。以下是一些常见的导致堆溢出的场景和原因:
1. 内存泄漏:最常见的情况是内存泄漏，即对象被创建后不再被使用，但没有被释放。这会导致堆中的对象数量逐渐增加，直到堆溢出。例如 ThreadLoca| 使用不当，使用完成之后未调用 remove 方法导致内存泄漏，以及忘记释放各种连接，也会导致内存泄漏，如数据库连接、网络连接和 I0 连接等。
2. 无限递归创建大量对象:无限递归调用一个方法可能会导致栈溢出，但如果递归方法中创建了大量对象并持续递归，也可能导致堆溢出。
3. 创建大量大对象:创建大量大对象，尤其是数组或集合，可能导致堆溢出。如果没有足够的连续内存来存储大对象，堆溢出会发生。
4. 未合理设置堆大小:如果未合理设置 Java 虚拟机的堆大小参数(如 -Xmx 和 -Xms)，可能导致堆溢出。
5. Excel 导入和导出:如果有大的 excel 要进行导入和导出的情况下，因为其操作都是在内存中拼接和组织数据的，如果 excel 过大，很容易就会造成 Heap OOM。

## 7. 栈溢出?

> 栈存储：①局部变量 ②方法调用 ③异常处理 ④同步方法 ⑤方法返回值
>
> 溢出原因：①深度递归 ②大量局部变量 ③线程数过多 ④大对象的创建 ⑤栈大小设置过小 ⑥异常处理不当 ⑦ThreadLocal没有合理回收

JVM（Java虚拟机）的栈是线程私有的内存区域，它的主要作用和存储的内容如下：

1. **存储局部变量**：栈中存储了每个方法调用时的局部变量，包括基本数据类型（如int、float、double等）、对象引用（不是对象本身，而是对象在堆内存中的地址）和返回地址。

2. **方法调用**：每当一个线程调用一个方法时，JVM会为这个方法创建一个新的栈帧（Stack Frame），这个栈帧包含了这个方法的局部变量、操作数栈、动态链接信息和方法返回值等。方法执行完毕后，对应的栈帧会被销毁。

3. **操作数栈**：每个栈帧中都有一个操作数栈，用于存储计算过程中的临时变量。操作数栈是后进先出（LIFO）的数据结构，用于存储计算过程中的中间结果。

4. **方法调用状态**：栈帧中还包含了方法的调用状态，包括方法的返回地址、方法的参数、方法的执行状态等。

5. **异常处理**：当异常发生时，JVM会使用栈来跟踪异常的传播路径，直到找到合适的异常处理器。

6. **同步方法**：在同步方法中，栈还用于存储锁信息，确保线程安全。

7. **方法返回值**：当一个方法执行完毕后，它的返回值也会被存储在栈中，直到调用者方法读取这个返回值。

总的来说，JVM的栈主要用于支持方法的调用和执行，以及存储方法执行过程中的局部变量和临时数据。

在JVM中，栈溢出（StackOverflowError）通常发生在栈内存耗尽时。以下是一些可能导致栈溢出的情况：

1. **深度递归**：如果一个方法不断地递归调用自身，而没有适当的退出条件，这将导致栈帧不断增加，最终耗尽栈内存。

2. **大量局部变量**：尽管这种情况较少见，但如果一个方法定义了大量的局部变量，尤其是大对象的引用，也可能导致栈空间不足。

3. **线程数过多**：每个线程都有自己的栈，如果创建了过多的线程，并且每个线程都占用了大量的栈空间，那么整体的栈内存可能会被耗尽。

4. **大对象的创建**：虽然对象是在堆内存中分配的，但如果在栈中创建了大量大对象的引用，并且这些对象没有被及时回收，也可能导致栈溢出。

5. **栈大小设置过小**：如果JVM启动参数中设置的栈大小（-Xss）过小，那么即使是正常的操作也可能导致栈溢出。

6. **复杂的表达式**：在某些编程语言中，复杂的表达式可能会创建大量的中间对象，这些对象的引用如果存储在栈中，也可能导致栈溢出。

7. **异常处理不当**：如果异常处理不当，比如在捕获异常的代码块中创建了大量对象或者进行了深度递归调用，也可能导致栈溢出。

8. **循环引用**：在某些情况下，循环引用可能导致内存泄漏，如果循环引用的对象占用了栈空间，那么随着时间的推移，这可能导致栈溢出。

9. **线程局部变量（ThreadLocal）**：虽然ThreadLocal变量存储在堆中，但如果使用不当，比如创建了大量ThreadLocal变量并且没有及时清理，它们可能会间接导致栈溢出。

10. **同步代码块**：如果同步代码块中包含了复杂的逻辑，并且有大量的线程同时竞争锁，那么每个线程的栈可能会因为同步代码块的执行而耗尽。

要避免栈溢出，可以通过优化代码逻辑、减少递归深度、合理设置栈大小、及时清理不再使用的局部变量和ThreadLocal变量等方法来实现。

## 8. 方法区会OOM吗?

> 如果方法区过小，类信息太多，也会oom

《]ava 虚拟机规范》对方法区的定义是可以没有 GC(垃圾回收)，也没有明确规定是否会出现 00M 的定义但 HotSpot 中，对方法区(也就是永久代和元空间)实现了 GC 操作，并且 Hotspot 中存在 OOM 的情况。例如，在 JDK 1.8 中，如果元空间设置空间过小，而类信息产生的过多就会产生 OOM，比如以下元空间设置较小时，通过动态代理类将方法区填满，从而就导致 OOM:

## 9. Java编译和解释语言? JIT? 热点代码?

> java即使编译语言，又是解释语言
>
> JIT "即时编译"，是一种在程序运行时将部分热点代码编译成机器代码的技术，以提高程序的执行性能。
>
> 什么是热点代码?：调用次数

Java是一种特殊的编程语言，它结合了编译型语言和解释型语言的特点。

1. **编译性语言**：Java源代码首先会被编译成字节码（bytecode），这是一种中间形式的代码，可以在任何安装了Java虚拟机（JVM）的平台上运行。

2. **解释性语言**：编译后的字节码在运行时会被JVM解释执行。

**JIT（Just-In-Time Compiler）即时编译器**：
- JIT是一种优化技术，它在运行时将字节码转换成机器码。JIT编译器在程序运行时分析热点代码（即频繁执行的代码），并将这些代码编译成优化过的本地机器码，以提高程序的执行效率。
- JIT编译器通常在程序运行过程中动态地进行编译，它可以识别出那些被频繁调用的方法，并为这些方法生成优化的机器码，从而提高程序的性能。

**热点代码**：

- 热点代码是指在程序执行过程中被频繁调用的代码段。JVM通过一种称为“热点探测”的机制来识别这些代码段。
- 热点代码可以是循环体、递归调用、频繁调用的方法等。JVM会监控方法的调用次数，当某个方法的调用次数达到一定的阈值时，JVM会认为这段代码是“热点代码”。
- 一旦识别出热点代码，JVM的JIT编译器就会介入，将这些代码编译成优化的本地机器码，从而提高程序的执行效率。

总结来说，Java是一种混合了编译和解释特性的语言。JIT是JVM中用于提高程序性能的一种技术，它通过即时编译热点代码来实现。热点代码则是那些在程序执行过程中被频繁调用的代码段。

## 10. 类加载?对象生命周期?

> 对象的生命周期：①创建阶段：new-堆分配内存-构造方法初始化对象 ②使用阶段：堆内存中被引用和使用 ③不可达阶段：任何引用变量指向该对象 ④垃圾回收：回收对象占用的内存 ⑤最终垃圾回收，生命周期结束 ⑥对象消亡
>
> 类加载机制：①加载：类的全限定名-class对象 ②链接：验证；准备；解析 ③初始化：赋值 ④使用 ⑤卸载
>
> 加载器：启动类加载器-扩展类加载器-应用程序类加载器

### 类的加载机制

类的加载过程涉及三个主要步骤：加载（Loading）、链接（Linking）和初始化（Initialization），具体过程如下：

1. **加载**：
   - 加载是类加载的第一个阶段，JVM通过类的全限定名查找.class文件，并通过字节流将类的信息读入到JVM内部，创建一个`java.lang.Class`对象。

2. **链接**：
   - 链接阶段包括验证（Verification）、准备（Preparation）和解析（Resolution）三个子阶段：
     - **验证**：确保加载的类信息符合JVM规范，没有安全问题。
     - **准备**：为类的静态变量分配内存，并设置默认初始值。
     - **解析**：将类的二进制数据中的符号引用转换为直接引用。

3. **初始化**：
   - 初始化是类加载的最后一个阶段，JVM执行类的构造器方法`<clinit>()`，按照语句在源码中的顺序来执行类的静态变量的赋值操作和静态代码块。

4. **使用**：
   - 类被加载、链接和初始化后，就可以被应用程序使用了。

5. **卸载**：
   - 当类不再被使用，且没有任何引用指向它时，类加载器会从内存中卸载这个类。

类加载器机制是Java实现平台无关性、防止核心库被篡改、动态加载类的基础。JVM提供了三个主要的类加载器：
- **启动类加载器**（Bootstrap ClassLoader）：加载JVM基础核心类库。
- **扩展类加载器**（Extension ClassLoader）：加载扩展目录（如`jre/lib/ext`）中的类库。
- **应用程序类加载器**（Application ClassLoader，也称为系统类加载器）：加载应用程序的类路径（classpath）上的类库。

此外，还可以自定义类加载器来实现特定的加载需求。

### 对象的生命周期

1. **创建阶段**：
   - 当通过`new`关键字创建对象时，JVM会在堆内存中分配内存空间给这个对象，并调用构造方法初始化对象。

2. **使用阶段**：
   - 对象创建后，可以在堆内存中被引用变量访问和使用。

3. **不可到达阶段**：
   - 当没有任何引用变量指向该对象时，该对象变得不可到达，此时垃圾收集器理论上可以回收它。

4. **垃圾收集阶段**：
   - 垃圾收集器（GC）会定期扫描堆内存，识别出不可到达的对象，并进行回收。

5. **最终回收阶段**：
   - 垃圾收集器回收对象占用的内存后，对象的生命周期结束。

6. **对象的消亡**：
   - 对象的类（Class）在被卸载之前，对象不会彻底消亡。如果对象实现了`finalize()`方法，在被回收前，JVM会调用这个方法。

## 11. 双亲委派模型?

> 当一个类加载器收到类加载的请求，会先委托给父类加载器加载类，如果没有找到，继续往上。如果都没有再返回，让其加载
>
> 好处：①避免类的重复加载 ②保证核心类库的安全 ③实现类的隔离

双亲委派模型是Java虚拟机中类加载机制的一种设计模式。它的核心思想是，当一个类加载器收到类加载请求时，会先委托给父类加载器去完成，如果父类加载器没有找到这个类，子类加载器才会尝试自己去加载这个类。这种模型确保了Java核心库的安全性，避免了类的多次加载，并保证了Java类的唯一性。

双亲委派模型的工作过程如下：
1. 当一个类加载器收到类加载请求时，它首先会委托给父类加载器去完成。
2. 父类加载器会尝试在自己的类库中查找并加载这个类。
3. 如果父类加载器没有找到这个类，它会将请求转发给自己的父类加载器。
4. 这个过程会递归进行，直到最顶层的启动类加载器。
5. 如果父类加载器无法完成类加载任务，子加载器才会尝试自己去加载这个类。

使用双亲委派模型的原因包括：
1. **避免类的重复加载**：确保一个类只被加载一次，无论它被多少个类加载器请求加载。
2. **保证核心类库的安全性**：Java的核心类库只能由最顶层的启动类加载器加载，防止被篡改。
3. **实现类的隔离**：不同的类加载器加载的类是隔离的，互不影响，即使类名相同也不会冲突。

热点代码则是指在程序运行过程中被频繁执行的代码段，这些代码段通常会被即时编译器（JIT）编译成优化的本地机器码，以提高程序的执行效率。

## 12. 打破双亲委派模型

> 

双亲委派模型是Java类加载机制的核心，它规定了类加载器在加载类时的委托顺序：先由父类加载器尝试加载，如果父类加载器无法完成加载任务，再由子类加载器尝试加载。这种模型确保了Java核心库的类型安全，防止了类的多次加载。

然而，在某些情况下，我们需要打破双亲委派模型，例如：

1. SPI
3. **容器环境**：如Tomcat，需要为每个Web应用程序提供独立的类加载器，以实现类隔离。

要打破双亲委派模型，可以采取以下方法：

1. **自定义类加载器**：通过继承`ClassLoader`类并重写`loadClass`方法，可以自定义类的加载逻辑，从而绕过双亲委派机制。例如，Tomcat的类加载器就是通过这种方式实现的，它允许每个Web应用程序都有自己的类加载器，从而实现类隔离。

2. **使用线程上下文类加载器**：通过`Thread.setContextClassLoader`方法，可以为特定线程设置一个类加载器，这个类加载器可以用于加载类，从而绕过双亲委派模型。

3. **利用第三方库**：如OSGi框架，它提供了自己的类加载机制，允许在运行时动态加载和卸载模块，从而打破了双亲委派模型。

在实现自定义类加载器时，通常需要重写`findClass`方法来实现类的加载逻辑，并在`loadClass`方法中调用`findClass`。这样，当父类加载器无法完成加载任务时，自定义类加载器可以介入并加载所需的类。

需要注意的是，打破双亲委派模型可能会带来一些风险，如类的多次加载和版本冲突。因此，在决定打破双亲委派模型之前，应该仔细权衡其利弊，并确保有充分的理由和必要的安全措施。

## 13. 判断对象存活?

判断对象是否存活的常见的算法有以下两种
1. 引用计数算法
2. 可达性分析算法
它们的介绍和优缺点如下，

 **引用计数器算法**
引用计数器算法的实现思路是，给对象增加一个引用计数器，每当有一个地方引用它时，计数器就 +1;当引用失效时，计数器就 -1;任何时刻计数器为 0的对象就是不能再被使用的，即对象已"死"。
引用计数法的优点:实现简单，判定效率也比较高。
引用计数法的缺点:是引用计数法无法解决对象的循环引用问题。

**可达性分析算法**
可达性分析算法是通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称之为"引用链"，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象是不可用的，也就是死亡对象。

## 14. GC Roots?

在 Java 语言中，可作为 GC Roots 的对象有以下几种!
1. Java 虚拟机栈(栈帧中的本地变量表)中引用的对象。
2. 本地方法栈中(Native 方法)引用的对象。
3. 方法区中类静态属性引用的对象。
4. 方法区中常量引用的对象。

其中，Java 虚拟机栈和本地方法栈中的引用对象，是目前线程正在执行时用的对象，所以它们不能被回收，因此它们可以作为 GC Roots。而方法区中的静态属性和常量对象与类本身相关联，而类已经被加载到程序中了，所以类属于系统的一部分了，因此类所关联的静态属性和常量也就是系统的一部分了，所以它们可以作为 GC Roots。

## 15. 引用类型?

可达性分析算法的关键是通过 GC Roots 找到引用链，所以“引用"也是 JVM 中的关键，**同时它们也为 Java 程序提供了一种更加精细的内存管理手段，使得开发者可以根据应用程序的具体需求来调整对象生命周期，特别是在处理大量数据缓存、资源管理和防止内存泄漏等场景时显得尤为重要。**
Java 将“引用”分为:强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减，具体内容如下:

1. **强引用**:强引用指的是在程序代码之中普遍存在的，类似于"0bject obj= new Object()”这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象实例。
   - 使用场景:日常开发中使用 new XXX()创建的所有对象都是强引用。
2. **软引用**:软引用是用来描述一些还有用但是不是必须的对象。==对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围之中进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常==。在 JDK1.2 之后，提供了 SoftReference 类来实现软引用。
   - 使用场景:软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。
3. **弱引用**:弱引用也是用来描述非必需对象的，它的强度要弱于软引用。==被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾回收器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的对象==。在 JDK1.2 之后提供了 WeakReference 类来实现弱引用。
   - 使用场景:维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重新实例化。例如ThreadLocal 中的 ThreadLocalMap 使用的就是弱引用，来它来尽量避免内存泄漏。
4. **虚引用**:虚引用也被称为幽灵引用或者幻影引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制
   - 使用场景:有人使用虚引用监控对象的创建和销毁。

## 16. 垃圾回收算法?

1. **标记-清除算法**:"标记-清除"算法是最基础的收集算法。算法分为"标记"和"清除"两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，如下图所示:
   - 优点:实现简单、且执行效率相对高效。
   - 缺点:会产生内存碎片问题，在标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够连续内存而不得不提前触发另一次垃圾收集。

2. **标记-整理算法**:标记-整理算法也是分为两个阶段“标记“和“整理”，其中标记仍与标记-清除算法的“标记”过程实现是一致的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存，如下图所示:
   - 优点:无内存碎片问题。
   - 缺点:执行效率比较低。

3. **复制算法**:"复制"算法是为了解决"标记-整理"的效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存需要进行垃圾回收时，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。这样做的好处是每次都是对整个半区进行内存回收，内存分配时也就不需要考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配即可。此算法实现简单，运行高效。如下图所示:
   - 优点:执行效率高。
   - 缺点:空间利用率比较低。
4. **分代算法**:分代算法是通过区域划分，实现不同区域和不同的垃圾回收策略，从而实现更好的垃圾回收。这就好比中国的一国两制方针一样，对于不同的情况和地域设置更符合当地的规则，从而实现更好的管理，这就时分代算法的设计思想。
   - 优点:分而治之，不同场景使用不同算法，整体性能更高，且空间利用率较好。
   - 缺点:实现复杂度比较高。

## 17. 分代算法和分区算法?

分代算法（Generational Algorithm）和分区算法（Partitioning Algorithm）是垃圾回收（Garbage Collection, GC）中的两种不同的策略，它们用于处理堆内存中的垃圾回收问题。以下是它们的主要区别：

### 分代算法（Generational GC）

1. **基于假设**：分代算法基于一个观察结果：大多数对象都是朝生夕死的，即大部分对象在很短的时间内就会变得不再被使用。

2. **内存分区**：堆内存被分为不同的区域，通常是三个区域：新生代（Young Generation）、老年代（Old Generation）和永久代（PermGen，Java 8 之后被元空间 Metaspace 替代）。

3. **收集频率**：新生代因为对象存活时间短，所以垃圾回收频繁；老年代因为对象存活时间长，所以垃圾回收较少。

4. **回收过程**：当新生代填满时，会进行Minor GC，只有少量存活对象会被移动到老年代。当老年代填满时，会进行Major GC（或Full GC），这是一个更耗时的过程。

5. **优化**：通过频繁地在新生代进行垃圾回收，可以减少在老年代进行全堆扫描的次数，从而提高垃圾回收的效率。

### 分区算法（分区 GC）

1. **内存划分**：分区算法将堆内存划分为多个连续的区域（分区），每个区域可以独立地进行垃圾回收。

2. **并行处理**：由于分区是独立的，垃圾回收可以在不同的分区并行进行，从而提高垃圾回收的效率。

3. **空间利用率**：分区算法可以更好地利用内存空间，因为它可以精确地回收每个分区中不再被使用的对象，而不需要等待整个堆内存填满。

4. **回收策略**：分区算法通常与并发标记-清除（Concurrent Mark-Sweep, CMS）或并发标记-清除-整理（Concurrent Mark-Sweep-Compact, CMS+CMSS）等算法结合使用，以实现高效的垃圾回收。

5. **适用场景**：分区算法适用于需要高吞吐量和低延迟的垃圾回收场景，尤其是在大堆内存的情况下。

### 区别总结

- **分代算法**侧重于根据对象的生命周期将堆内存分区，并针对不同区域采取不同的回收策略。
- **分区算法**侧重于将堆内存划分为多个小区域，以实现并行回收和提高内存利用率。

两种算法都是为了提高垃圾回收的效率和性能，但它们的方法和侧重点不同。在实际的垃圾回收器实现中，可能会结合使用这两种算法，以适应不同的应用场景和性能要求。例如，G1（Garbage-First）垃圾回收器就是一种结合了分代和分区思想的算法，它将堆内存划分为多个区域，并根据这些区域的回收价值来优先回收。

## 18. 垃圾回收类型?

在Java虚拟机（JVM）中，垃圾回收（GC）是自动内存管理的一个重要部分。垃圾回收器会定期清理不再使用的对象，释放内存空间。在JVM中，垃圾回收主要分为以下几种类型：

1. **Minor GC（年轻代垃圾回收）**：
   - 针对年轻代的垃圾回收，通常发生在Eden区或Survivor区。
   - 因为大多数对象在年轻代的生命周期较短，所以Minor GC非常频繁，但通常回收速度较快。

2. **Major GC（老年代垃圾回收）**：
   - 针对老年代的垃圾回收，通常在老年代空间不足时触发。
   - Major GC的执行时间通常比Minor GC慢，因为它涉及更大量的内存回收。

3. **Full GC（全局垃圾回收）**：
   - 针对整个堆内存（包括年轻代、老年代和元空间）的垃圾回收。
   - Full GC的执行时间最长，因为它需要扫描整个堆内存，进行标记、清理和压缩。

触发Full GC的情况包括但不限于：
- 老年代空间不足。
- 显式调用`System.gc()`，尽管这只是一个建议，JVM可以选择忽略。
- 永久代（Java 8之前的版本）或元空间（Java 8及之后的版本）空间不足。

Minor GC和Major GC的区别主要在于它们关注的内存区域不同，Minor GC通常只涉及年轻代，而Major GC涉及老年代。Full GC则涉及整个堆内存。

在实际应用中，合理配置JVM的垃圾回收参数和选择合适的垃圾回收器对于优化应用性能至关重要。例如，G1垃圾回收器（Garbage-First Collector）是一种分区收集器，它在JDK 9中成为默认的垃圾回收器，旨在提供可预测的停顿时间，同时保持高吞吐量。CMS（Concurrent Mark Sweep）垃圾回收器则是一种分代收集器，它通过并发标记和清除算法来减少GC的停顿时间。

了解这些GC类型和触发条件有助于开发者更好地理解JVM的内存管理机制，从而进行有效的性能调优。

## 19. 常见垃圾回收器?

Java虚拟机（JVM）中的垃圾回收器（GC）是用来自动管理内存的一种机制，它能够识别并回收不再使用的对象，释放内存空间。以下是JVM中常见的垃圾回收器及其特点：

1. **Serial GC**：
   - 单线程的垃圾回收器，适用于小型应用或单核处理器。
   - 新生代使用标记-复制算法，老年代使用标记-整理算法。
   - **垃圾回收过程中会暂停所有用户线程（Stop The World，STW）**。

2. **Parallel GC**：
   - 也称为Throughput Collector，是Serial GC的多线程版本。
   - 新生代使用标记-复制算法，老年代使用标记-整理算法。
   - **目标是达到最大的吞吐量，即在最短的时间内完成最多的工作。**

3. **CMS (Concurrent Mark-Sweep) GC**：
   - 并发标记-清除算法的垃圾回收器，主要针对老年代。
   - 旨在减少垃圾回收过程中的停顿时间。

4. **G1 (Garbage-First) GC**：
   - 服务器端垃圾回收器，旨在提供可预测的停顿时间。
   - 将堆内存划分为多个区域，优先回收垃圾最多的区域。
   - 可以与JVM中的其他垃圾回收器组合使用。

5. **ZGC (Z Garbage Collector)**：
   - 低延迟垃圾回收器，目标是实现亚毫秒级的停顿时间。
   - 适用于大堆内存，使用彩色标记算法进行并发标记。

6. **Shenandoah GC**：
   - 并发标记-清除-整理算法的垃圾回收器。
   - 旨在减少停顿时间，同时保持高吞吐量。

7. **Epsilon GC**：
   - 不执行任何垃圾回收操作的垃圾回收器，主要用于测试。

8. **Parallel Old GC**：
   - Parallel GC的老年代版本，使用多线程进行标记-整理算法。

选择哪种垃圾回收器取决于应用的需求、内存大小、预期的停顿时间等因素。例如，对于需要低延迟的应用，可以选择CMS或G1 GC；而对于追求高吞吐量的应用，可以选择Parallel GC。在实际应用中，可以根据具体情况和性能测试结果来选择最合适的垃圾回收器。

## 20. CMS垃圾回收器?

CMS（Concurrent Mark Sweep）垃圾回收器是Java虚拟机（JVM）中的一种老年代垃圾回收器，它主要目标是减少垃圾回收时的应用程序停顿（STW）时间。CMS通过并发执行垃圾回收线程和用户线程来降低停顿时间，使用的是标记-清除算法。

CMS垃圾回收器的工作过程大致分为以下几个阶段：

1. **初始标记（CMS initial mark）**：
   - 这个阶段是标记从GC Roots直接可达的老年代对象，会导致一次短暂的STW。

2. **并发标记（CMS concurrent mark）**：
   - 这个阶段是并发执行的，垃圾回收线程和用户线程同时运行，标记所有可达的对象。

3. **重新标记（CMS remark）**：
   - 这个阶段需要STW，用于修正并发标记阶段可能产生的标记错误。

4. **并发清除（CMS concurrent sweep）**：
   - 这个阶段也是并发执行的，清除被标记为垃圾的对象，释放内存空间。

CMS垃圾回收器的优点包括并发收集和低延迟，但它也有一些缺点：

- **对CPU资源敏感**：
  - 在并发标记和并发清除阶段，会占用一部分CPU资源，可能导致应用程序变慢。

- **无法处理浮动垃圾**：
  - 在并发标记和并发清除阶段，用户线程还在运行，可能会产生新的垃圾，这些垃圾被称为浮动垃圾，CMS无法在当次收集中处理它们。

- **内存碎片问题**：
  - 由于使用标记-清除算法，CMS会产生内存碎片。可以通过参数 `-XX:+UseCMSCompactAtFullCollection` 来在必要时进行内存碎片整理。

- **并发模式失败（Concurrent Mode Failure）**：
  - 如果在CMS运行期间老年代空间不足以容纳新的对象，就会触发并发模式失败，此时会使用Serial Old垃圾回收器进行全堆的垃圾回收，导致长时间的STW。

在实际应用中，CMS适用于对停顿时间要求较高的场景，但需要根据具体的应用程序需求和系统环境进行选择和调整。对于CMS的调优，可以通过调整 `-XX:CMSInitiatingOccupancyFraction` 参数来控制触发CMS的阈值，以及通过 `-XX:+UseCMSCompactAtFullCollection` 和 `-XX:CMSFullGCsBeforeCompaction` 参数来控制内存碎片整理的策略。

CMS垃圾回收器在JDK 9中被标记为不推荐使用，并在JDK 14中被移除。在JDK 9之后，默认年轻代为ParNew收集器，并且不可更改。CMS的设计理念和实现机制对后续的垃圾回收器，如G1和ZGC，有着重要的影响。

## 21. CMS执行流程?

CMS（Concurrent Mark Sweep）垃圾回收器的执行流程主要包括以下几个阶段：

1. **初始标记（CMS Initial Mark）**：
   - 这个阶段是STW（Stop The World）的，即暂停所有用户线程，只有CMS线程在运行。
   - CMS线程会标记所有直接从GC Roots可达的对象。

2. **并发标记（CMS Concurrent Mark）**：
   - 这个阶段是并发的，即CMS线程和用户线程同时运行。
   - CMS线程会递归地标记所有可达的对象，这个过程可能需要一段时间。

3. **预清理（CMS Concurrent Preclean）**：
   - 这个阶段是并发的，CMS线程会尝试清理一些已经确定不会在重新标记阶段发生变化的区域，以减少重新标记的工作量。

4. **可取消的预清理（CMS Concurrent Abortable Preclean）**：
   - 这个阶段是并发的，CMS线程会继续清理工作，但如果发现用户线程分配的对象太多，可能会取消这个阶段，直接进入重新标记。

5. **重新标记（CMS Remark）**：
   - 这个阶段是STW的，用于修正并发标记阶段可能产生的标记错误，因为并发标记阶段用户线程还在运行，可能会产生新的垃圾。

6. **并发清除（CMS Concurrent Sweep）**：
   - 这个阶段是并发的，CMS线程会清除所有被标记为垃圾的对象，释放内存空间。

7. **并发重置（CMS Concurrent Reset）**：
   - 这个阶段是并发的，CMS线程会重置标记数据，等待下一次CMS垃圾回收的触发。

在整个CMS执行流程中，初始标记和重新标记阶段需要STW，而其他阶段都是并发执行的，这样可以减少垃圾回收对用户线程的影响，降低停顿时间。但是，CMS也存在一些问题，如对CPU资源敏感、无法处理浮动垃圾、内存碎片等。

为了防止老年代空间不足导致的并发模式失败（Concurrent Mode Failure），CMS会预留一部分空间给用户线程使用，这部分空间可以通过参数 `-XX:CMSInitiatingOccupancyFraction` 来设置。如果预留的空间不足以容纳新的对象，CMS会触发并发模式失败，此时会使用Serial Old垃圾回收器进行全堆的垃圾回收，导致长时间的STW。

## 22. CMS如何解决内存碎片问题?它能使用标记-整理算法吗?为什么?

CMS 并不能直接解决内存碎片的问题，因为 CMS 使用的标记-清除算法。但是当内存碎片比较多时(连续内存不不足以申请大对象时)，CMS 会借助 Serial 0ld 垃圾收集器执行内存碎片的回收工作，因为 Serial Old 使用的是标记-整理算法，所以内存碎片问题就得到了解决。
**CMS能使用标记-整理算法吗?为什么?**
CMS 不能使用标记-整理算法，这是因为 CMS 最后一个阶段是并发清除阶段，此阶段 CMS 垃圾回收会和用户线程并发执行，如果使用并发-整理算法需要移动内存位置，而此时用户线程正在执行，所以不能使用并发-整理算法如下图所示:

## 23. G1是如何分区的?

G1 总共有以下 4 块区域:
- **Eden(伊甸园区)**:新创建对象都会放在此区域。
- **Survivor(存活区)**:eden 经过 GC 之后存活的对象就会移动到此区域。
- **Old(老年代)**:经过n次 GC 之后还存活的对象就会放到此区域。
- **Humongous(巨型区)**:用来存放大对象的，大对象会直接存放到此区域，当一个对象的大小超过 Region 的一半时(50%)，则该对象定义为大对象。

## 24. G1和CMS有什么区别?

G1（Garbage-First）垃圾回收器和CMS（Concurrent Mark Sweep）垃圾回收器都是Java虚拟机（JVM）中的垃圾回收器，它们都旨在优化垃圾回收性能，但它们在设计理念、实现机制和适用场景上有所不同。以下是G1和CMS垃圾回收器的主要区别：

1. **垃圾回收策略**：
   - **CMS**：采用“标记-清除”算法，主要关注老年代的垃圾回收，尝试减少垃圾回收过程中的停顿时间（STW）。
   - **G1**：采用“标记-整理”算法，同时关注整个堆的垃圾回收，旨在提供可预测的停顿时间，同时保持高吞吐量。

2. **内存管理**：
   - **CMS**：将堆内存分为年轻代和老年代，老年代采用标记-清除算法，容易产生内存碎片。
   - **G1**：将堆内存划分为多个大小相等的区域（Region），每个区域可以是Eden、Survivor或Old区，采用复制算法，减少了内存碎片。

3. **停顿时间**：
   - **CMS**：设计目标是最小化停顿时间，但可能会因为内存碎片和浮动垃圾导致并发模式失败（Concurrent Mode Failure），从而触发Full GC，导致较长的停顿时间。
   - **G1**：提供了停顿时间预测模型，用户可以指定最大停顿时间目标，G1会尽力在该时间内完成垃圾回收。

4. **并发性**：
   - **CMS**：在标记和清除阶段与应用程序线程并发执行，但重新标记和清理阶段需要STW。
   - **G1**：在标记、清理和转移阶段都可以与应用程序线程并发执行，提高了并发性。

5. **适用场景**：
   - **CMS**：适用于对停顿时间要求较高的应用，如交互式应用。
   - **G1**：适用于大堆内存和需要可预测停顿时间的应用，如后台处理和大型数据处理。

6. **性能和资源消耗**：
   - **CMS**：对CPU资源相对敏感，可能会因为并发执行而影响应用程序的性能。
   - **G1**：在提供低延迟的同时，可能会消耗更多的CPU资源和内存空间。

7. **垃圾回收器发展**：
   - **CMS**：在JDK 9中被标记为不推荐使用，并在JDK 14中被移除。
   - **G1**：从JDK 9开始成为默认的垃圾回收器，逐渐成为主流的垃圾回收器选择。

总的来说，G1是CMS的后继者，它在CMS的基础上做了许多改进，尤其是在内存碎片处理和停顿时间预测方面。G1的设计使得它更适合现代大型应用和大堆内存环境。然而，选择哪种垃圾回收器还需要根据具体的应用需求和系统资源进行权衡。

## 25. 对象创建一定在堆上吗?什么是逃逸分析?什么是锁消除和标量替换?

在Java中，对象的创建通常发生在堆（Heap）上，但这不是绝对的。以下是对这些问题的详细解释：

### Java对象创建一定在堆上吗？

1. **堆内存**：
   - 在大多数情况下，Java对象是在堆内存中创建的。堆是JVM中最大的内存区域，用于存储所有的Java对象实例。

2. **栈上分配**：
   - 然而，对于一些小的、生命周期短的对象，JVM可能会选择在栈（Stack）上分配，这称为栈上分配（Stack Allocation）。这样做可以减少垃圾回收的压力，因为这些对象的生命周期与栈帧的生命周期相同，当方法返回时，这些对象就可以被自动回收。

3. **标量替换**：
   - 在某些情况下，如果对象的字段都是基本数据类型，JVM可能会执行标量替换（Scalar Replacement），将对象拆分成单独的变量，这些变量直接存储在栈上。

### 什么是逃逸分析？

逃逸分析（Escape Analysis）是JVM在编译期间进行的一种优化手段，用于分析对象的作用域。它可以帮助虚拟机判断对象是否在方法内部被外部方法引用，从而确定对象的分配位置和是否需要同步。

1. **逃逸情况**：
   - 如果一个对象在方法中被外部方法引用，或者作为返回值传递给其他方法，那么这个对象就发生了逃逸。

2. **优化**：
   - 逃逸分析可以帮助JVM决定是否进行某些优化，如栈上分配、锁消除、标量替换等。

### 什么是锁消除？

锁消除（Lock Elimination）是一种JVM即时编译器（JIT）的优化技术，它通过逃逸分析来确定同步块内的锁操作是否可以被消除。

1. **锁消除的条件**：
   - 如果逃逸分析发现同步块内的代码不会逃逸到外部线程，即没有线程安全问题，那么锁操作可以被消除，以提高性能。

2. **优化效果**：
   - 锁消除可以减少不必要的同步开销，特别是在单线程环境中，或者在确定不会发生线程间数据竞争的情况下。

### 什么是标量替换？

标量替换（Scalar Replacement）是一种JVM优化技术，它将对象拆分成单独的基本数据类型（标量），以减少对象的创建和内存占用。

1. **标量和聚合量**：
   - 标量是不可再分的最小数据单位，如int、long、float等。
   - 聚合量是可以包含多个标量的复合数据结构，如对象。

2. **优化过程**：
   - 如果一个对象只包含基本数据类型，并且没有逃逸到外部方法，那么JVM可能会将这个对象的字段拆分出来，直接作为基本数据类型进行操作。

3. **优化效果**：
   - 标量替换可以减少对象的创建和内存占用，提高内存利用率和程序性能。

逃逸分析、锁消除和标量替换都是JVM在编译期间进行的优化技术，它们可以帮助提高程序的运行效率和性能。开发者在编写代码时，应该注意避免不必要的对象创建和同步操作，以便于JVM进行这些优化。

## 26. 说说CMS工作原理?

CMS（Concurrent Mark Sweep，即并发标记清除）垃圾回收器是Java虚拟机（JVM）中的老年代垃圾回收器，它的主要目标是减少垃圾回收过程中的停顿时间（STW，Stop The World）。CMS通过并发执行垃圾回收任务来降低停顿时间，适用于对响应时间要求较高的应用场景。

CMS垃圾回收器的工作原理可以分为以下几个阶段：

1. **初始标记（Initial Mark）**：
   - 这个阶段是STW的，JVM会暂停所有用户线程，进行GC Roots的标记。这个步骤非常快，因为它只标记GC Roots直接引用的对象。

2. **并发标记（Concurrent Mark）**：
   - 在这个阶段，CMS线程会并发地与用户线程一起运行，继续标记所有可达的对象。这个过程可能需要一段时间，但不需要STW。

3. **重新标记（Remark）**：
   - 由于并发标记阶段是与用户线程并发执行的，可能会有新的垃圾对象产生（即浮动垃圾）。重新标记阶段是STW的，用于修正并发标记阶段可能遗漏的标记。

4. **并发清除（Concurrent Sweep）**：
   - 这个阶段是并发执行的，CMS线程会清除所有被标记为垃圾的对象，释放内存空间。用户线程仍然可以并发执行。

5. **并发重置（Concurrent Reset）**：
   - 在这个阶段，CMS线程会重置标记数据，为下一次垃圾回收做准备。

CMS垃圾回收器的优点包括：

- **并发收集**：大部分垃圾回收工作与用户线程并发执行，减少了停顿时间。
- **低延迟**：适合对响应时间要求较高的应用。

CMS垃圾回收器的缺点包括：

- **内存碎片**：由于使用标记-清除算法，可能会产生内存碎片，导致大对象无法找到足够的连续空间。
- **浮动垃圾**：并发标记和清除阶段产生的新垃圾（浮动垃圾）无法在当前周期被回收，可能需要等到下一次GC。
- **CPU资源敏感**：在并发阶段，CMS线程会占用CPU资源，可能会影响应用程序的性能。

CMS垃圾回收器在JDK 9中被标记为不推荐使用，并在JDK 14中被移除。在现代Java应用中，更推荐使用G1或其他新一代垃圾回收器，因为它们提供了更好的性能和更低的停顿时间。

# 补充：
## 1. AOT和JIT有什么区别?

AOT(Ahead-of-Time Compilation，提前编译)和 JIT(Just-In-Time Compilation，即时编译)是两种不同的编译方式。其中 JIT 在 JDK 1.7 中就默认开启了，而 AOT 虽然不是什么新的技术和概念(传统的 C++ 编译方式就是AOT 编译)，但它是在 GraalVM，也就是 Spring Boot 3(Spring 6)中才逐渐走入 Java 的世界的。

两者的主要区别如下:
1. **AOT(提前编译)**:在程序运行之前就将源代码或中间字节码转换为特定平台的机器码。
   - **优点**:由于日标代码是在运行前生成的，所以程序启动速度快，运行时无需进行额外的编译过程，且运行效率通常较高，特别是在 CPU 密集型任务中表现更优。
   - **缺点**:针对不同平台需要生成对应的机器码，不具有跨平台性;且如果源代码发生变化，必须重新进行编译才能看到效果，不利于开发阶段的快速迭代。

2. JIT(即时编译):在程序运行期间，对部分热点代码(即频繁执行的代码)进行动态编译为机器码。
   - 优点:具备良好的跨平台性，只需编写一次代码即可在支持 JM 或其他解释型环境的平台上运行;并且能。够根据实际运行情况动态优化代码，提供比纯解释执行更高的性能;同时，在开发过程中可以快速修改并立即查看结果，利于调试和迭代。
   - 缺点:程序启动速度相比 AOT 略慢，因为需要先解释执行然后逐步编译热点代码;而且为了实现动态优化，会消耗一定的内存资源。

## 2. 说一下ZGC?它有什么优点?

ZGC（Z Garbage Collector）是Java虚拟机中的一种新型垃圾回收器，它在JDK 11中首次引入，旨在提供低延迟和高吞吐量的垃圾回收体验。以下是ZGC的一些关键特性和工作原理：

1. **低延迟**：
   - ZGC的设计目标之一是实现低延迟的垃圾回收，即在垃圾回收过程中，应用程序的停顿时间非常短，不超过10ms。在JDK 16中，ZGC的停顿时间已经可以控制在1ms以内，并且时间复杂度为O(1)，这意味着GC停顿时间是一个固定值，不受堆内存大小的影响 。

2. **支持大堆内存**：
   - ZGC支持的堆内存范围从几百兆字节到数TB，未来甚至支持16TB，这使得它非常适合处理大型内存和高并发的应用场景 。

3. **内存多重映射**：
   - ZGC使用内存多重映射技术，将同一块物理内存映射为多个虚拟内存地址，这些地址在不同的时间点可以指向不同的物理内存，从而实现并发的垃圾回收 。

4. **染色指针**：
   - ZGC采用染色指针技术，通过在对象的引用地址中嵌入额外的信息，如对象是否被移动、对象的存活状态等，从而在并发标记和转移阶段提高效率 。

5. **读屏障**：
   - 读屏障是一种在程序运行时插入到对象访问操作中的特殊检查，用于确保对象访问的正确性，并在对象标记和转移过程中发挥作用 。

6. **GC过程**：
   - ZGC的垃圾回收过程包括初始标记、并发标记、再标记、初始转移、并发转移和重定位等阶段，其中大部分工作都是并发执行的，减少了停顿时间 。

7. **适用场景**：
   - ZGC适用于需要大内存、低延迟和高吞吐量的应用，如金融交易、游戏、广告科技等领域 。

8. **调优建议**：
   - 合理配置堆内存大小，避免产生大量短生命周期对象，使用工具进行性能监控和分析，了解并利用ZGC的特性，根据实际情况调整相关参数，如堆大小、线程数等，以获得最佳性能表现 。

ZGC的引入为Java垃圾回收器带来了新的选择，特别是在处理大内存和低延迟要求的场景下，ZGC提供了一种有效的解决方案。随着JDK版本的更新，ZGC也在不断优化和改进，以适应更广泛的应用需求。

## 3. 什么是彩色指针和读屏障?

彩色指针和读屏障是 ZGC 中的两个关键技术，用于实现并发垃圾回收，在多线程环境中确保内存一致性和减少垃圾回收带来的性能开销。
**① 彩色指针**
在传统的内存管理中，对象引用通常只存储指向对象的地址，==而在 ZGC 中，每个对象引用被设计为包含颜色信息的“彩色指针”(也叫染色指针)==
这种指针不仅记录了所引用对象在内存中的位置，还携带了额外的信息来表示该对象的状态:
- 白色:表示对象尚未被垃圾收集器访问过，可达性分析算法开始阶段所有对象都是白色:但若在分析结束阶段还未白色，则代表不可达(垃圾对象)。
- 黑色:表示对象已经被垃圾回收器扫描过，并且其所有可达的对象也已被扫描。黑色标识已经被扫描过，并且.为安全存活的。
- 灰色:表示对象当前正在被垃圾回收器扫描，尚未完成扫描其子对象。

通过这种方式，ZGC 可以并发地执行垃圾回收过程，同时保证不会丢失对任何可达对象的跟踪。

**② 读屛障**
读屏障是一种在读取对象引用时插入的特殊代码段，用于确保并发标记阶段的一致性。这样，即使在并发执行过程中，也能确保对内存中对象的访问始终正确无误。
在 ZGC 中，当一个线程尝试从内存中读取对象引用时，读屏障会检查这个引用是否满足以下条件:
1. 对象是否已经被移动到堆内存中的新位置。
2. 根据对象的颜色状态进行判断和执行
   - 如果对象颜色为黑色则表明对象已被访问过(或被标记为白色)，那么线程可以安全地继续访问对象
   - 而对象颜色为灰色状态下，则标识当前对象正在垃圾回收期间，因此，在读屏障的作用下，它通常会触发阻塞操作，如暂停当前线程，等待垃圾回收程序完成相关的操作后再继续执行。

在 ZGC 中，彩色指针不仅用于表示对象的可达性状态，还记录了对象在内存中的实际位置。由于 ZGC 采用了读屏障技术来处理并发过程中的对象移动问题，因此彩色指针能够确保即使在并发执行期间，也能正确地追踪和更新对象引用。

## 4. 如何进行JVM线上调优?
典型回答
JVM 线上调优的思路为以下几步:
1. 设置合理参数:根据实际业务场景设置合理内存大小和合适的垃圾收集器。
2. 监控:监控 JVM 运行。
3. 分析和定位问题:遇到 JVM 瓶颈之后，可以启动 GC 日志记录，分析和定位问题。
4. 修正参数设置和 BUG 代码:根据 GC 日志，定位到问题，然后再进行参数修正或 BUG 代码修改。
具体操作如下。

**设置合理参数**
所谓的合理参数，指的是根据实际业务也硬件大小设置 JVM 参数，如以下两个:
1. **分配合适的内存**:合理的堆大小可以减少垃圾收集的频率
   - **堆内存设置**:通过设置 -Xmx 和 -Xms 参数来调整堆内存大小。-Xmx 指定最大堆内存，-Xms 指定初始堆内存。合适的堆内存大小取决于应用程序的需求，通常需要根据应用程序的性能特性进行试验和调整。
   - **非堆内存设置**:非堆内存包括 Metaspace(在 Java8及更早版本中是 PermGen)和本地内存。可以使用XX:MaxMetaspaceSize 参数来设置 Metaspace 的最大大小，确保不会出现 Metaspace 溢出错误。
2. **选择合适的垃圾回收器**:根据应用程序的性能需求选择合适的垃圾回收器。例如，CMS(Concurrent Mark-2Sweep)适用于需要低延迟的应用程序，而 G1(Garbage-first)适用于需要更均衡的吞吐量和低延迟的应用程序。

**监控**
使用适当的监控工具来收集 JM 的性能指标和运行状态，可以帮助你了解应用程序的瓶颈和资源使用情况，一些常用的监控工具包括 Java VisualVM、Java Mission Control、Grafana 等。

**分析和定位问题**
开启 GC 日志可以收集详细的垃圾回收信息，通过分析 GC 日志可以识别潜在的性能问题并进行优化调整。之后可以使用工具如 GCViewer、GCEasy 等来帮助解析和分析 GC 日志。

## 5. 排查OOM?

JVM（Java虚拟机）的OOM（Out of Memory）错误通常是由于应用程序请求的内存超出了JVM的可用内存限制，导致JVM无法分配更多的内存而发生的错误。要排查JVM的OOM错误，可以按照以下步骤进行：

1. **查看OOM错误日志**：首先查看JVM的日志文件，通常会有详细的错误信息，包括堆栈跟踪和导致OOM的原因。

2. **分析堆转储文件**：当JVM发生OOM时，通常会生成堆转储文件（Heap Dump），可以使用工具如MAT（Memory Analyzer Tool）来分析堆转储文件，查看内存中的对象分布情况，找出内存泄漏或者内存占用过高的对象。

3. **检查代码**：检查应用程序的代码，特别是内存使用较大的部分，查看是否有内存泄漏或者不合理的内存使用方式，比如频繁创建大量对象、未关闭资源等。

4. **调整JVM参数**：根据应用程序的内存需求和实际情况，可以调整JVM的内存参数，如-Xmx（最大堆内存）、-Xms（初始堆内存）、-XX:MaxPermSize（永久代大小）等，以确保JVM有足够的内存可用。

5. **使用监控工具**：使用监控工具如JConsole、VisualVM等实时监控JVM的内存使用情况，及时发现内存泄漏或者内存占用过高的情况。

6. **优化代码**：对代码进行优化，减少内存占用，比如使用缓存、复用对象、及时释放资源等，以降低发生OOM的风险。

通过以上步骤的排查和分析，可以帮助定位并解决JVM的OOM错误，提高应用程序的稳定性和性能。

## 6. 如何进行JVM调优？

JVM 调优是一个很大的话题，在回答"如何进行 JM 调优?"之前，首先我们要回答一个更为关键的问题，那就是，我们为什么要进行 JVM 调优?

只有知道了为什么要进行 JM 调优之后，你才能准确的回答出来如何进行 JM 调优?

要进行 JVM 调优无非就是以下两种情况:
1. 目标驱动型的 JVM 调优，如，我们是为了最短的停顿时间所以要进行 JVM 调优，或者是我们为了最大吞吐量所以要进行 JVM 调优等。
2. 问题驱动型的 JVM 调优，因为生产环境出现了频繁的 FulGC 了，导致程序执行变慢，所以我们要进行 JVM’调优。

所以，针对不同的 JVM 调优的手段和侧重点也是不同的。
总的来说，JVM 进行调优的流程如下:
1. 确定 JVM 调优原因
2. 分析 JVM(目前)运行情况
3. 设置 JVM 调优参数
4. 压测观测调优后的效果
5. 应用调优后的配置

具体来说它们的执行如下：

**1. 确定JVM调优原因**

先确定是目标驱动型的 JVM 调优，还是问题驱动型的 JVM 调优。如果是目标性的 JVM 调优，那么 JVM 调优实现思路就比较简单了，如:
1. 以最短停顿时间为目标的调优，只需要将垃圾收集器设置成以最短停顿时间的为目标的垃圾收集器即可，如CMS 收集器或 G1 收集器。
2. 以吞吐量为目标的调优，只需要将垃圾收集器设置为 Parallel Scavenge 和 Parallel Old 这种以吞吐量为主要目’标的垃圾回收器即可，

如果是以问题驱动的 JVM 调优，那就要先分析问题是什么，然后再进行下一步的调优了

**2.分析JVM运行情况**
我们可以借助于目前主流的监控工具 Prometheus + Grafana 和 JDK 自带的命令行工具，如 jps、jstat、jinfo、Jstack 等进行 JVM 运行情况的分析。
==主要分析的点是 Young Gc 和 Full GC 的频率，以及垃圾回收的执行时间。==

**3.设置JVM调优参数**
常见的 JVM 调优参数有以下几个:
- **调整堆内存大小**:通过设置 -Xms(初始堆大小)和 -Xmx(最大堆大小)参数来调整堆内存大小，避免频繁的垃圾回收。
- **选择合适的垃圾回收器**：根据应用程序的性能需求和特点，选择合适的垃圾回收器，如 Serial Gc、ParallelGC、CMS GC、G1 GC 等。
- **调整新生代和老年代比**:通过设置 -XX:NewRatio 参数来调整新生代和老年代的比例，优化内存分配设置合适的堆中的各个区域比例:通过设置-XX:SurvivorRati0 参数和 -XX:MaxTenuringThreshold 参数来调整Eden 区、Survivor 区和老年代的比例，避免过早晋升和过多频繁的垃圾回收。
- **设置对象从年轻代进入老年代的年龄值**:-XX:InitialTenuringThreshold=7 表示7 次年轻代存活的对象就会进入老年代。
- **设置元空间大小**:在 JDK 1.8 版本中，元空间的默认大小会根据操作系统有所不同。具体来说，在 Windows上，元空间的默认大小为 21MB;而在 Linux 上，其默认大小为 24MB。然而如果元空间不足也有可能触发 FulGC 从而导致程序执行变慢，因此我们可以通过 -XX:MaxMetaspaceSize=<size>设置元空间的最大容量。

**4.压测观测调优后的效果**
IVM 参数调整之后，我们要通过压力测试来观察 JM 参数调整前和调整后的差别，以确认调整后的效果
**5.应用调优后的配置**
在确认了 JM 参数调整后的效果满足需求之后，就可以将 JM 的参数配置应用于生产环境了。