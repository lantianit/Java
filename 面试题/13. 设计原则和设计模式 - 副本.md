**课程目标**

1、通过对节课内容的学习，了解设计原则的重要性。

2、掌握七大设计原则的具体内容。 

**内容定位**

学习设计原则，学习设计模式的基础。在实际开发过程中，并不是一定要求所有代码都遵循设计原则，我们要考虑人力、时间、成本、质量，不是刻意追求完美，要在适当的场景遵循设计原则，体现的是一种平衡取舍，帮助我们设计出更加优雅的代码结构。



## 开闭原则

> 1. 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
> 2. 现实例子：对于每天工作 8 小时这个规定是关闭的。但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走
> 3. 代码案例：icourse接口-javacourse-discountjavacourse

​	开闭原则（Open-Closed Principle, OCP）是指**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭**。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。

​	**在现实生活中对于开闭原则也有体现。比如，很多互联网公司都实行弹性制作息时间，规定每天工作 8 小时。意思就是说，对于每天工作 8 小时这个规定是关闭的，但是你什么时候来，什么时候走是开放的。早来早走，晚来晚走。**

​	实现开闭原则的核心思想就是面向抽象编程，接下来我们来看一段代码：

​	以咕泡学院的课程体系为例，首先创建一个课程接口 ICourse：

```java
public interface ICourse {
    Integer getId();
    String getName();
    Double getPrice();
}
```

​	整个课程生态有 Java 架构、大数据、人工智能、前端、软件测试等，我们来创建一个 Java 架构课程的类 JavaCourse：

```java
public class JavaCourse implements ICourse{
    private Integer Id;
    private String name;
    private Double price;
    public JavaCourse(Integer id, String name, Double price) {
        this.Id = id;
        this.name = name;
        this.price = price;
    }
    public Integer getId() {
    	return this.Id;	
    }
    public String getName() {
    	return this.name;
    }
    public Double getPrice() {
    	return this.price;
    }
}
```

​	现在我们要给 Java 架构课程做活动，价格优惠。如果修改 JavaCourse 中的 getPrice()方法，则会存在一定的风险，可能影响其他地方的调用结果。我们如何在不修改原有代码前提前下，实现价格优惠这个功能呢？现在，我们再写一个处理优惠逻辑的类，JavaDiscountCourse 类（思考一下为什么要叫JavaDiscountCourse，而不叫 DiscountCourse）：

```java
public class JavaDiscountCourse extends JavaCourse {
    public JavaDiscountCourse(Integer id, String name, Double price) {
        super(id, name, price);
    }
    public Double getOriginPrice(){
        return super.getPrice();
    }
    public Double getPrice(){
        return super.getPrice() * 0.61;
    }
}
```



## **依赖倒置原则**

> 1. 高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象
> 2. tom不依赖课程，而是提供课程接口。课程也是实现课程接口。然后这样tom直接调用课程接口，实现多可用。多态

​	依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，**高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象**。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。接下来看一个案例，还是以课程为例，先来创建一个类 Tom：

```java
public class Tom {
    public void studyJavaCourse(){
        System.out.println("Tom正在学习Java课程");
    }

    public void studyPythonCourse(){
        System.out.println("Tom正在学习Python课程");
    }
}
```

来调用一下：

```java
public static void main(String[] args) {
    Tom tom = new Tom();
    tom.studyJavaCourse();
    tom.studyPythonCourse();
}
```

​	Tom 热爱学习，目前正在学习 Java 课程和 Python 课程。大家都知道，学习也是会上瘾的。随着学习兴趣的暴涨，**现在 Tom 还想学习 AI 人工智能的课程。这个时候，业务扩展，我们的代码要从底层到高层（调用层）一次修改代码。在 Tom 类中增加 studyAICourse()的方法，在高层也要追加调用。如此一来，系统发布以后，实际上是非常不稳定的，在修改代码的同时也会带来意想不到的风险。接下来我们优化代码，创建一个课程的抽象 ICourse 接口**：

```java
public interface ICourse {
	void study();
}
```

然后写 JavaCourse 类：

```java
public class JavaCourse implements ICourse {
    @Override
    public void study() {
	    System.out.println("Tom 在学习 Java 课程");
    }
}
```

再实现 PythonCourse 类：

```java
public class PythonCourse implements ICourse {
    @Override
    public void study() {
    	System.out.println("Tom 在学习 Python 课程");
    }
}
```

修改 Tom 类：

```java
public class Tom {
    public void study(ICourse course){
        course.study();
    }
}
```

来看调用：

```java
public static void main(String[] args) {
    Tom tom = new Tom();
    tom.study(new JavaCourse());
    tom.study(new PythonCourse());
}
```

我们这时候再看来代码，Tom 的兴趣无论怎么暴涨，对于新的课程，我只需要新建一个类，通过传参的方式告诉 Tom，而不需要修改底层代码。实际上这是一种大家非常熟悉的方式，叫**依赖注入**。注入的方式还有构造器方式和 setter 方式。我们来看构造器注入方式：

```java
public class Tom {
    private ICourse course;
    public Tom(ICourse course){
    	this.course = course;
    }
    public void study(){
    	course.study();
    }
}
```

看调用代码：

```java
public static void main(String[] args) {
	Tom tom = new Tom(new JavaCourse());
	tom.study();
}
```

根据构造器方式注入，在调用时，每次都要创建实例。那么，如果 Tom 是全局单例，则我们就只能选择用 Setter 方式来注入，继续修改 Tom 类的代码：

```java
public class Tom {
    private ICourse course;
    public void setCourse(ICourse course) {
	    this.course = course;
    }
    public void study(){
	    course.study();
    }
}
```

看调用代码：

```java
public static void main(String[] args) {
    Tom tom = new Tom();
    tom.setCourse(new JavaCourse());
    tom.study();
    tom.setCourse(new PythonCourse());
    tom.study();
}
```

现在我们再来看最终的类图：

![image-20241018102253635](./../Java/设计原则和设计模式/设计原则.assets/image-20241018102253635.png)

大家要切记：以抽象为基准比以细节为基准搭建起来的架构要稳定得多，因此大家在拿到需求之后，要面向接口编程，先顶层再细节来设计代码结构。

## **单一职责原则**

> 一个类应该只负责一个功能
>
> 用户类：负责存储信息，不负责验证密码正确性

单一职责原则（Single Responsibility Principle, SRP）是面向对象设计原则之一，它指出一个类应该只有一个改变的原因。换句话说，**一个类应该只负责一个功能**。下面是一个Java中遵循单一职责原则的例子：

### 违反单一职责原则的例子：

假设我们有一个`User`类，它负责用户信息的存储，并且负责用户信息的验证：

```java
public class User {
    private String name;
    private String email;
    private String password;

    // Constructor, getters, and setters

    public boolean validateUser() {
        // Check if the email is valid
        if (!email.contains("@")) {
            return false;
        }
        
        // Check if the password is strong enough
        if (password.length() < 8) {
            return false;
        }
        
        // Other validation rules...
        
        return true;
    }
}
```

在这个例子中，`User`类负责了两个职责：用户信息的存储和用户信息的验证。如果将来验证逻辑需要改变，可能会影响到存储逻辑，这违反了单一职责原则。

### 遵循单一职责原则的例子：

为了遵循单一职责原则，我们可以将验证逻辑分离到另一个类中：

```java
public class User {
    private String name;
    private String email;
    private String password;

    // Constructor, getters, and setters
}

public class UserValidator {
    public boolean validateUser(User user) {
        // Check if the email is valid
        if (!user.getEmail().contains("@")) {
            return false;
        }
        
        // Check if the password is strong enough
        if (user.getPassword().length() < 8) {
            return false;
        }
        
        // Other validation rules...
        
        return true;
    }
}
```

在这个改进的例子中，`User`类只负责用户信息的存储，而`UserValidator`类负责验证用户信息。这样，每个类只有一个改变的原因，符合单一职责原则。

### 使用例子：

```java
public class Main {
    public static void main(String[] args) {
        User user = new User("John Doe", "john@example.com", "strongPassword123");
        UserValidator validator = new UserValidator();
        
        boolean isValid = validator.validateUser(user);
        if (isValid) {
            System.out.println("User is valid.");
        } else {
            System.out.println("User is not valid.");
        }
    }
}
```

在这个例子中，`Main`类创建了一个`User`对象和一个`UserValidator`对象，然后使用`UserValidator`对象来验证`User`对象。这种设计使得`User`类和`UserValidator`类各自只关注一个职责，易于维护和扩展。

## **接口隔离原则**

> 1. **客户端不应该依赖于它不使用的接口**
> 2. 接口应该简洁，精炼，不冗余
> 3. 例子：动物接口-吃-睡觉-飞，分为IFeedable, ISleepable, IFlyable 

接口隔离原则（Interface Segregation Principle, ISP）是面向对象设计原则之一，它指出客户端**不应该依赖于它不使用的接口**。换句话说，应该**将大的接口拆分成小的、特定的接口**，这样客户端只需要依赖于它们实际使用的接口。

以下是一个违反接口隔离原则的Java例子：

```java
// 一个违反接口隔离原则的接口
public interface IAnimalControl {
    void feed();
    void sleep();
    void fly();
}
```

在这个例子中，`IAnimalControl` 接口包含了三个方法：`feed()`、`sleep()` 和 `fly()`。但是，并不是所有的动物都需要 `fly()` 方法。例如，如果有一个 `Dog` 类实现这个接口，它就不需要 `fly()` 方法，这违反了接口隔离原则。

现在，让我们通过将 `IAnimalControl` 接口拆分成更小的接口来遵循接口隔离原则：

```java
// 遵循接口隔离原则的接口
public interface IFeedable {
    void feed();
}

public interface ISleepable {
    void sleep();
}

public interface IFlyable {
    void fly();
}
```

现在，我们可以根据动物的实际需求实现这些接口：

```java
// Dog 类只需要吃饭和睡觉
public class Dog implements IFeedable, ISleepable {
    @Override
    public void feed() {
        System.out.println("Dog is eating.");
    }

    @Override
    public void sleep() {
        System.out.println("Dog is sleeping.");
    }
}

// Bird 类需要吃饭、睡觉和飞行
public class Bird implements IFeedable, ISleepable, IFlyable {
    @Override
    public void feed() {
        System.out.println("Bird is eating.");
    }

    @Override
    public void sleep() {
        System.out.println("Bird is sleeping.");
    }

    @Override
    public void fly() {
        System.out.println("Bird is flying.");
    }
}
```

在这个改进的例子中，`Dog` 类实现了 `IFeedable` 和 `ISleepable` 接口，而 `Bird` 类实现了 `IFeedable`、`ISleepable` 和 `IFlyable` 接口。这样，每个类只需要依赖于它们实际使用的接口，符合接口隔离原则。

### 使用例子：

```java
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Bird bird = new Bird();

        dog.feed();
        dog.sleep();

        bird.feed();
        bird.sleep();
        bird.fly();
    }
}
```

在这个例子中，`Main` 类创建了一个 `Dog` 对象和一个 `Bird` 对象，并调用了它们的方法。这种设计使得每个类只需要关注它们实际使用的方法，减少了不必要的依赖，提高了代码的灵活性和可维护性。

## 迪米特法则

> 1. 最少知道原则，不间接直接的调用其他类的方法，而是通过封装调用其他类中的方法
> 2. school中有student类，想调用school中student的类，那么school需要提供student类的封装方法

迪米特法则（Law of Demeter，LoD）最少知道原则，是一种软件设计原则，它规定一个对象应该对其他对象有最少的了解。换句话说，一个对象不应该直接与它的朋友（friend）以外的对象进行交互。这个原则有助于减少对象之间的耦合，使得系统更加模块化。

以下是一个违反迪米特法则的Java例子：

```java
public class Student {
    private String name;
    private int age;
    // Constructor, getters, and setters
}

public class School {
    private String name;
    private Student student;
    // Constructor, getters, and setters
}

public class University {
    public static void main(String[] args) {
        School school = new School();
        Student student = school.getStudent();
        System.out.println(student.getName()); // 违反了迪米特法则
    }
}
```

在这个例子中，`University` 类直接访问了 `School` 类中的 `Student` 对象的 `getName()` 方法。这违反了迪米特法则，因为 `University` 类不应该直接与 `Student` 类交互。

现在，让我们通过修改代码来遵循迪米特法则：

```java
public class Student {
    private String name;
    private int age;
    // Constructor, getters, and setters
    public String getName() {
        return name;
    }
}

public class School {
    private String name;
    private Student student;
    // Constructor, getters, and setters
    public Student getStudent() {
        return student;
    }
    
    public String getStudentName() { // 新增方法，遵循迪米特法则
        return student.getName();
    }
}

public class University {
    public static void main(String[] args) {
        School school = new School();
        System.out.println(school.getStudentName()); // 现在遵循了迪米特法则
    }
}
```

在这个改进的例子中，`University` 类不再直接访问 `Student` 类的方法，而是通过 `School` 类的 `getStudentName()` 方法来获取学生的名字。这样，`University` 类只与 `School` 类交互，而不需要了解 `Student` 类的细节，符合迪米特法则。

迪米特法则的目的是减少类之间的依赖关系，使得每个类更加独立，从而提高系统的可维护性和可扩展性。通过遵循迪米特法则，可以减少系统中的潜在错误，并使得代码更加清晰和易于理解。

## **里氏替换原则**

> 程序中，子类替换父类后，依然正常允许
>
> 创建一个父类数组，用子类赋值，然后遍历即可测试

里氏替换原则（Liskov Substitution Principle, LSP）是面向对象设计中的一个原则，它指出子类应该能够替换其基类（父类），而不影响程序的正确性。换句话说，使用基类的地方应该能够无缝地使用子类对象。

以下是一个遵循里氏替换原则的Java例子：

```java
// 基类（父类）
public class Animal {
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

// 子类（子类）继承自 Animal
public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof woof");
    }
}

// 另一个子类继承自 Animal
public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow meow");
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        // 使用基类类型的引用指向子类对象
        Animal[] animals = {myAnimal, myDog, myCat};

        for (Animal animal : animals) {
            animal.makeSound(); // 程序可以正常运行，因为子类遵循了里氏替换原则
        }
    }
}
```

在这个例子中，`Animal` 是一个基类，它有一个 `makeSound` 方法。`Dog` 和 `Cat` 是 `Animal` 的子类，它们都重写了 `makeSound` 方法。

在 `Main` 类中，我们创建了一个 `Animal` 类型的数组，并且将 `Dog` 和 `Cat` 的实例放入数组中。当我们遍历数组并调用 `makeSound` 方法时，程序可以正常运行，因为 `Dog` 和 `Cat` 的实例可以替换 `Animal` 类型的引用，且不违反里氏替换原则。

这个例子展示了子类对象能够替换其基类对象，而不会破坏程序的正确性。这就是里氏替换原则的核心思想，它有助于保持代码的灵活性和可扩展性。

## **合成复用原则**

> 扩展代码时候，尽可能选择加入对象而不是继承对象来扩展

合成复用原则（Composite Reuse Principle, CRP），也称为组合/聚合复用原则，建议优先使用对象的组合/聚合来实现代码复用，而不是通过继承来实现。这个原则鼓励你通过包含其他对象来构建复杂的系统，而不是创建一系列继承自基类的子类。

以下是一个违反合成复用原则的Java例子，它使用继承来复用代码：

```java
// 基类
public class Vehicle {
    protected String type;

    public Vehicle(String type) {
        this.type = type;
    }

    public void move() {
        System.out.println(type + " is moving.");
    }
}

// 通过继承复用
public class Car extends Vehicle {
    public Car() {
        super("Car");
    }
}

public class Bicycle extends Vehicle {
    public Bicycle() {
        super("Bicycle");
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        Bicycle bicycle = new Bicycle();
        car.move();
        bicycle.move();
    }
}
```

在这个例子中，`Car` 和 `Bicycle` 通过继承 `Vehicle` 类来复用 `move()` 方法。

现在，让我们通过组合/聚合来改写这个例子，以遵循合成复用原则：

```java
// 基类
public class Vehicle {
    protected String type;

    public Vehicle(String type) {
        this.type = type;
    }

    public void move() {
        System.out.println(type + " is moving.");
    }
}

// 通过组合复用
public class Car {
    private Vehicle vehicle;

    public Car() {
        this.vehicle = new Vehicle("Car");
    }

    public void move() {
        vehicle.move();
    }
}

public class Bicycle {
    private Vehicle vehicle;

    public Bicycle() {
        this.vehicle = new Vehicle("Bicycle");
    }

    public void move() {
        vehicle.move();
    }
}

// 客户端代码
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        Bicycle bicycle = new Bicycle();
        car.move();
        bicycle.move();
    }
}
```

在这个改进的例子中，`Car` 和 `Bicycle` 类不再继承自 `Vehicle` 类，而是包含一个 `Vehicle` 类的实例。这样，`Car` 和 `Bicycle` 类通过组合来复用 `Vehicle` 类的 `move()` 方法，而不是通过继承。

合成复用原则的优点在于它提供了更大的灵活性，并且减少了类之间的耦合。当系统需要变化时，你可以通过修改组合/聚合的对象来适应变化，而不需要修改继承层次结构。这种方法使得代码更容易维护和扩展。

## 1. 设计模式？

> 1. 概念：**软件工程中的一种最佳实践，它是在特定情境下解决特定问题的成熟模板或方案**。
> 2. 特点场景举例：
>    1. 创建型模式（模式提供了对象创建的机制，同时隐藏了创建逻辑，而不是直接使用new操作符实例化对象）：单例模式（Singleton）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、建造者模式（Builder）和原型模式（Prototype）。
>    2. 结构型模式（如何组合类或对象以形成更大的结构的方式）：适配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）和外观模式（Facade）。
>    3. 行为型模式（专注于对象之间的通信，以确保对象和类之间的良好协作）：策略模式（Strategy）、观察者模式（Observer）、命令模式（Command）、迭代器模式（Iterator）和状态模式（State）。
> 3. 好处：
>    1. 提高代码的可重用性和编写效率
>    2. 提高代码的可读性和可维护性
>    3. 提高代码的灵活性和可扩展性

设计模式（Design Pattern）是**软件工程中的一种最佳实践，它是在特定情境下解决特定问题的成熟模板或方案**。设计模式是经过验证的、可重用的设计方案，可以帮助开发者高效地解决在软件设计过程中遇到的一些常见问题。

设计模式的主要目的是：

1. **提高代码的可重用性和编写效率**：通过使用设计模式，开发者可以避免重复编写相同的代码结构。
2. **提高代码的可读性和可维护性**：设计模式提供了一种通用的语言，使得其他开发者更容易理解代码的意图和结构。
3. **提高代码的灵活性和可扩展性**：设计模式通常关注于解耦合，使得代码更容易扩展和维护。

设计模式可以分为三大类：

1. **创建型模式**（Creational Patterns）：
   - 这些模式提供了对象创建的机制，同时隐藏了创建逻辑，而不是直接使用new操作符实例化对象。
   - 常见的创建型模式包括**单例模式（Singleton）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、建造者模式（Builder）和原型模式（Prototype）**。

2. **结构型模式**（Structural Patterns）：
   - 这些模式提供了如何组合类或对象以形成更大的结构的方式。
   - 常见的结构型模式包括适**配器模式（Adapter）、桥接模式（Bridge）、组合模式（Composite）、装饰器模式（Decorator）和外观模式（Facade），代理模式。**

3. **行为型模式**（Behavioral Patterns）：
   - 这些模式专注于对象之间的通信，以确保对象和类之间的良好协作。
   - 常见的行为型模式包括**策略模式（Strategy）、观察者模式（Observer）、命令模式（Command）、迭代器模式（Iterator）和状态模式（State），模板方法模式。**

设计模式的应用需要根据具体的应用场景和需求来选择，不恰当地使用设计模式可能会导致过度设计和不必要的复杂性。因此，开发者应该根据实际情况和经验来判断是否需要使用设计模式。

## 2. 设计模式中要遵循的基本原则？

1. 开闭原则：类、接口、模块对于访问开放，修改关闭。课程-java课程。
2. 单一原则：一个类负责一个功能。课程播放-直播和录播-如果扩展了直播功能-代码改动量大，影响其他功能。
3. 接口隔离原则：接口功能尽可能单一精简，比如一个动物接口实现了飞，但并不是所有动物都飞，所以不如isFlyable接口单独出来。
4. 依赖倒置原则：高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。tom看课程例子
5. 迪米特法则：最少知道原则，访问其他类的时候，最好访问封装方法
6. 里氏替换：子类可以完全替代父类，可以用数组检验程序
7. 合成复用：扩展的时候，最好组合类，不是继承

## 3. 单例模式的实现方式有几种?它有哪些使用场景?

单例模式**确保一个类只有一个实例，并提供一个全局访问点来获取这个实例**。以下是几种实现单例模式的方式：

### 1. 饿汉式（Eager Initialization）

这种方式在类加载时就立即初始化单例对象。

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

### 2. 双重检查锁定（Double-Check Locking）

这种方式减少了同步的开销，只有在实例未创建时才进行同步。

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 3. 静态内部类（Static Nested Class）

这种方式利用了类加载机制，保证了单例的唯一性。

```java
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    private Singleton() {}

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

单例模式的使用场景?
单例模式的典型使用场景是 **Spring 中 Bean 的实例**，Bean 实例默认使用的就是单例模式,除此之外，**单例模式的使用场景还有数据库连接池、Redis 连接池、线程池等使用场景**。

## 4. 什么是工厂模式?它的使用场景有哪些?

在Java中，工厂模式是一种创建型设计模式，它提供了一个创建对象的接口，让子类决定实例化哪个类。工厂模式使得一个类的实例化延迟到其子类。

工厂模式的主要目的是通过使用一个共同的接口来指向新创建的对象，而不是直接在代码中实例化对象。这样做的好处是，可以在不修改现有代码的情况下引入新的对象类型。

工厂模式通常包含以下几个组件：

1. **产品（Product）**：定义了产品的接口。
2. **具体产品（Concrete Product）**：实现了产品接口的具体类。
3. **工厂（Factory）**：提供了创建产品实例的接口。
4. **具体工厂（Concrete Factory）**：实现了工厂接口，生成具体的产品实例。

### 简单工厂模式的Java代码示例：

```java
// 抽象产品
interface Product { 
    void use(); 
}

// 具体产品A
class ConcreteProductA implements Product { 
    public void use() { 
        System.out.println("Using ConcreteProductA"); 
    } 
}

// 具体产品B
class ConcreteProductB implements Product { 
    public void use() { 
        System.out.println("Using ConcreteProductB"); 
    } 
}

// 抽象工厂
interface Factory { 
    Product createProduct(); 
}

// 具体工厂A
class ConcreteFactoryA implements Factory { 
    public Product createProduct() { 
        return new ConcreteProductA(); 
    } 
}

// 具体工厂B
class ConcreteFactoryB implements Factory { 
    public Product createProduct() { 
        return new ConcreteProductB(); 
    } 
}

// 客户端代码
public class FactoryMethodDemo { 
    public static void main(String[] args) { 
        Factory factory = new ConcreteFactoryA(); 
        Product product = factory.createProduct(); 
        product.use(); 
    } 
}
```

在这个示例中，`Factory` 是工厂接口，`ConcreteFactory` 是具体工厂，它创建一个 `Product` 对象。`Product` 是产品接口，`ConcreteProductA` 和 `ConcreteProductB` 是具体产品类。客户端代码通过工厂接口与具体工厂交互，无需知道具体产品的细节。

当需要引入新产品时，只需添加新的具体产品类并修改具体工厂类，而无需修改客户端代码，这体现了开闭原则。工厂模式的使用场景有哪些?
工厂模式的常见使用场最有两个

1. 线程池中的线程通过线程工厂创建线程。
2. Spring 中的 Bean 通过 FactoryBean 创建 Bean 对象。

## 5. 抽象工厂和工厂模式有什么区别?

抽象工厂模式（Abstract Factory Pattern）和工厂方法模式（Factory Method Pattern）都是创建型设计模式，它们都用于创建对象，但是它们在结构和使用场景上有所不同。

### 工厂方法模式（Factory Method Pattern）：

1. **目的**：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。
2. **结构**：通常包含一个抽象产品类、多个具体产品类、一个抽象工厂类、以及多个具体工厂类。
3. **使用场景**：当你需要创建一系列相关或依赖对象时，但每次只需要创建其中的一个对象。
4. **特点**：允许通过多态性来创建对象，而不是直接实例化对象。

### 抽象工厂模式（Abstract Factory Pattern）：

1. **目的**：提供一个接口，用于创建一系列相关或依赖对象的家族，而不需要指定具体类。
2. **结构**：通常包含多个抽象产品类、多个具体产品类、一个抽象工厂类、以及多个具体工厂类。
3. **使用场景**：当你需要创建多个系列的产品族时，每个系列的产品族都是相关的，并且需要一起使用。
4. **特点**：允许你独立地创建一系列相关的产品，而不需要依赖于具体的类。

### 主要区别：

1. **产品系列**：
   - 工厂方法模式通常用于创建一个产品族中的一个对象。
   - 抽象工厂模式用于创建多个产品族中的多个对象。

2. **复杂性**：
   - 工厂方法模式通常比较简单，因为它只关注一个产品族。
   - 抽象工厂模式更复杂，因为它需要处理多个产品族。

3. **扩展性**：
   - 在工厂方法模式中，添加新的产品族可能需要修改抽象工厂类，这违反了开闭原则。
   - 在抽象工厂模式中，添加新的产品族不需要修改现有的工厂类，更容易扩展。

4. **客户端代码**：
   - 工厂方法模式的客户端代码通常依赖于抽象工厂类。
   - 抽象工厂模式的客户端代码通常依赖于抽象工厂接口。

### 示例代码：

#### 工厂方法模式：

```java
// 抽象产品
interface Product { 
    void use(); 
}

// 具体产品A
class ConcreteProductA implements Product { 
    public void use() { 
        System.out.println("Using ConcreteProductA"); 
    } 
}

// 具体产品B
class ConcreteProductB implements Product { 
    public void use() { 
        System.out.println("Using ConcreteProductB"); 
    } 
}

// 抽象工厂
interface Factory { 
    Product createProduct(); 
}

// 具体工厂A
class ConcreteFactoryA implements Factory { 
    public Product createProduct() { 
        return new ConcreteProductA(); 
    } 
}

// 具体工厂B
class ConcreteFactoryB implements Factory { 
    public Product createProduct() { 
        return new ConcreteProductB(); 
    } 
}

// 客户端代码
public class FactoryMethodDemo { 
    public static void main(String[] args) { 
        Factory factory = new ConcreteFactoryA(); 
        Product product = factory.createProduct(); 
        product.use(); 
    } 
}
```

#### 抽象工厂模式：

```java
// 抽象产品A
interface ProductA { 
    void useA(); 
}

// 抽象产品B
interface ProductB { 
    void useB(); 
}

// 具体产品A1
class ConcreteProductA1 implements ProductA { 
    public void useA() { 
        System.out.println("Using ConcreteProductA1"); 
    } 
}

// 具体产品A2
class ConcreteProductA2 implements ProductA { 
    public void useA() { 
        System.out.println("Using ConcreteProductA2"); 
    } 
}

// 具体产品B1
class ConcreteProductB1 implements ProductB { 
    public void useB() { 
        System.out.println("Using ConcreteProductB1"); 
    } 
}

// 具体产品B2
class ConcreteProductB2 implements ProductB { 
    public void useB() { 
        System.out.println("Using ConcreteProductB2"); 
    } 
}

// 抽象工厂
interface AbstractFactory { 
    ProductA createProductA(); 
    ProductB createProductB(); 
}

// 具体工厂1
class ConcreteFactory1 implements AbstractFactory { 
    public ProductA createProductA() { 
        return new ConcreteProductA1(); 
    } 
    public ProductB createProductB() { 
        return new ConcreteProductB1(); 
    } 
}

// 具体工厂2
class ConcreteFactory2 implements AbstractFactory { 
    public ProductA createProductA() { 
        return new ConcreteProductA2(); 
    } 
    public ProductB createProductB() { 
        return new ConcreteProductB2(); 
    } 
}

// 客户端代码
public class AbstractFactoryDemo { 
    public static void main(String[] args) { 
        AbstractFactory factory = new ConcreteFactory1(); 
        ProductA productA = factory.createProductA(); 
        ProductB productB = factory.createProductB(); 
        productA.useA(); 
        productB.useB(); 
    } 
}
```

在实际应用中，选择工厂方法模式还是抽象工厂模式取决于你的具体需求，以及你希望如何组织和管理你的产品对象。

## 6. 什么是建造者模式?它的使用场景有哪些?

建造者模式（Builder Pattern）是一种创建型设计模式，**它提供了一种创建复杂对象的方法，同时允许通过分步骤构建对象来分离对象的构建和表示**。建造者模式使得相同的构建过程可以创建不同的表示。

建造者模式的主要目的是：

1. 提供一种清晰的方式来创建复杂对象，同时保持对象的创建代码和业务逻辑分离。
2. 允许通过分步骤构建对象，使得对象的构建过程更加灵活。
3. **避免使用大量的构造参数，这些参数可能会使得构造函数变得复杂且难以管理。**

建造者模式通常包含以下几个角色：

1. **产品（Product）**：
   - 要构建的复杂对象。

2. **建造者（Builder）**：
   - 提供一个接口，用于创建和设置产品的不同部分。

3. **具体建造者（Concrete Builder）**：
   - 实现建造者接口，提供具体的构建步骤。

4. **导演（Director）**：
   - 负责管理建造过程，通常包含一个建造者对象，并指导如何构建产品。

5. **客户端（Client）**：
   - 创建具体建造者对象，并指导导演进行构建。

### Java代码示例：

```java
// 产品类
class Product {
    private String partA;
    private String partB;

    public void setPartA(String partA) {
        this.partA = partA;
    }

    public void setPartB(String partB) {
        this.partB = partB;
    }

    @Override
    public String toString() {
        return "Product{" +
                "partA='" + partA + '\'' +
                ", partB='" + partB + '\'' +
                '}';
    }
}

// 建造者接口
interface Builder {
    void buildPartA();
    void buildPartB();
    Product getResult();
}

// 具体建造者
class ConcreteBuilder implements Builder {
    private Product product = new Product();

    public void buildPartA() {
        product.setPartA("PartA");
    }

    public void buildPartB() {
        product.setPartB("PartB");
    }

    public Product getResult() {
        return product;
    }
}

// 导演类
class Director {
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    public void construct() {
        builder.buildPartA();
        builder.buildPartB();
    }

    public Product getResult() {
        return builder.getResult();
    }
}

// 客户端代码
public class BuilderPatternDemo {
    public static void main(String[] args) {
        Builder builder = new ConcreteBuilder();
        Director director = new Director(builder);
        director.construct();
        Product product = director.getResult();
        System.out.println(product);
    }
}
```

在这个示例中，`Product` 是要构建的复杂对象，`Builder` 是建造者接口，`ConcreteBuilder` 是具体建造者，`Director` 是导演类，负责指导构建过程，`Client` 是客户端代码，它创建具体建造者对象并指导导演进行构建。建造者模式使得构建过程和表示分离，提高了代码的可读性和可维护性。

## 7. 什么是原型模式？使用场景？

在Java中，原型模式（Prototype Pattern）是一种创建型设计模式，它允许一个对象实例用作创建其他对象实例的通用模板。原型模式在Java中主要通过克隆（Cloneable接口）来实现。

### 原型模式的核心思想

**原型模式的核心思想是定义一个通用的接口或类，然后通过克隆来创建具体的实例。克隆可以是完全独立的，原型和克隆之间不会相互影响。**

### 使用场景

1. **创建相似对象**：
   当你需要创建多个相似对象，但不需要共享状态时，可以使用原型模式。

2. **延迟对象创建**：
   当对象创建成本较高或依赖于系统资源时，可以使用原型模式来延迟对象的创建。

3. **避免类爆炸**：
   当系统需要创建多种产品时，原型模式可以避免类层次结构的复杂性。

4. **简化类结构**：
   原型模式可以简化类结构，因为克隆对象不需要显式继承原型类。

### Java中的实现

在Java中，原型模式通常通过实现`Cloneable`接口来实现。`Cloneable`接口定义了一个`clone()`方法，该方法用于创建对象的一个副本。

```java
public class Prototype implements Cloneable {
    public Object clone() {
        Prototype prototype = null;
        try {
            prototype = (Prototype) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return prototype;
    }
}
```

### 使用示例

```java
Prototype prototype = new Prototype();
Prototype clonedPrototype = (Prototype) prototype.clone();
```

在这个例子中，`Prototype`类实现了`Cloneable`接口，并提供了自己的`clone()`方法实现。然后我们创建了一个`Prototype`对象的实例，并通过调用`clone()`方法来创建一个克隆对象。

### 注意事项

- `clone()`方法需要正确处理`CloneNotSupportedException`异常。
- 原型模式不适用于需要共享内部状态的场景。
- 原型模式创建的对象应该是可变的，克隆的。

原型模式在Java中不是非常常见，因为它涉及到对象的复制，这在某些情况下可能导致性能问题。在实际应用中，应该根据具体需求和场景来决定是否使用原型模式。

## 8. 什么是适配器模式?它的使用场景有哪些?

适配器模式（Adapter Pattern）是一种**结构型设计模式，它允许不兼容的接口之间能够一起工作**，主要用于解决软件设计中的接口不兼容问题。适配器模式提供了一个中间层，使得原本由于接口不匹配而不能一起工作的类可以一起工作。

适配器模式通常包含以下几个角色：

1. **目标接口（Target Interface）**：
   - 定义了客户期望使用的接口。

2. **适配者（Adaptee）**：
   - 有一个已经存在的接口，但是不兼容目标接口。

3. **适配器（Adapter）**：
   - 将适配者的接口转换成目标接口，使得原本不兼容的接口可以一起工作。

适配器模式有两种主要形式：

1. **类适配器模式**：
   - 使用多重继承将适配者类和目标接口类结合在一起。

2. **对象适配器模式**：
   - 使用组合的方式将适配者对象包装在适配器对象中。

### Java代码示例（对象适配器模式）：

```java
// 目标接口
interface Target {
    void request();
}

// 适配者类
class Adaptee {
    public void specificRequest() {
        System.out.println("Adaptee: Specific request.");
    }
}

// 适配器类
class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        adaptee.specificRequest();
    }
}

// 客户端代码
public class AdapterPatternDemo {
    public static void main(String[] args) {
        Adaptee adaptee = new Adaptee();
        Target target = new Adapter(adaptee);
        target.request();
    }
}
```

在这个示例中，`Target` 是目标接口，`Adaptee` 是已经存在的类，它有一个不兼容的接口。`Adapter` 是适配器类，它实现了目标接口，并通过组合的方式包装了 `Adaptee` 对象。客户端代码通过适配器类来调用适配者的方法。

适配器模式使得我们可以透明地使用一些不符合当前系统要求的类，而不需要修改原有代码。这种模式在系统集成和第三方库的整合中非常有用。

**适配器模式的使用场景有哪些?**
适配器的常见使用场景有以下几个:

1. HandlerAdapter:在 Spring MVC 中，HandlerAdapter 是用于适配处理器(handler)的接口。Spring MVC1.框架根据请求的不同，选择合适的 HandlerAdapter 实现类来适配不同类型的处理器，以使其能够正确地处理请求。例如，RequestMappingHandlerAdapter 用于适配带有 @RequestMapping 注解的方法处理器;而HttpRequestHandlerAdapter 用于适配实现了 HttpRequestHandler 接口的处理器，用于处理来自客户端的HTTP 请求。
2. MessageConverter:在 Spring Web 中，MessageConverter 是用于适配不同格式的消息(message)的接口。通过使用不同的 MessageConverter 实现类，Spring 能够将 HTTP 请求的消息体(body)转换为适合应用程序处理的格式，以及将应用程序生成的响应消息转换为适合发送给客户端的格式。例如，HttpMessageConverter 用于处理与 HTTP 请求和响应相关的消息转换，用于处理各种格式的消息，如 JSON.XML、表单数据等:WebSocketMessageBrokerConfiqurer 用于处理 WebSocket 的传输。

## 9. 什么是装饰模式?它有哪些使用场景?

装饰模式（Decorator Pattern）是一种结构型设计模式，**它允许向一个现有的对象添加新的功能，同时又不改变其结构**。这种设计模式通过创建一个包装对象，即装饰者，来包含原有对象，并在保持原有方法签名的同时提供额外的功能。

装饰模式的主要目的是提供一种灵活的替代继承的方法，以便在运行时透明地给对象添加功能。

装饰模式通常包含以下几个角色：

1. **组件（Component）**：
   - 定义了对象的接口，可以给这些对象动态地添加职责。

2. **混凝土组件（Concrete Component）**：
   - 定义了将要接收附加责任的对象。

3. **装饰器（Decorator）**：
   - 持有一个组件对象的引用，并定义一个与组件接口一致的接口。

4. **混凝土装饰器（Concrete Decorator）**：
   - 负责给组件添加新的责任。

### Java代码示例：

```java
// 组件接口
interface Coffee {
    double getCost();
    String getDescription();
}

// 具体组件
class SimpleCoffee implements Coffee {
    public double getCost() {
        return 1;
    }

    public String getDescription() {
        return "Simple coffee";
    }
}

// 装饰器
abstract class CoffeeDecorator implements Coffee {
    protected final Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }

    public double getCost() {
        return decoratedCoffee.getCost();
    }

    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}

// 具体装饰器
class MilkCoffeeDecorator extends CoffeeDecorator {
    public MilkCoffeeDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 0.5;
    }

    public String getDescription() {
        return super.getDescription() + ", with milk";
    }
}

// 具体装饰器
class SugarCoffeeDecorator extends CoffeeDecorator {
    public SugarCoffeeDecorator(Coffee coffee) {
        super(coffee);
    }

    public double getCost() {
        return super.getCost() + 0.2;
    }

    public String getDescription() {
        return super.getDescription() + ", with sugar";
    }
}

// 客户端代码
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        Coffee coffee = new SimpleCoffee();
        System.out.println(coffee.getCost());
        System.out.println(coffee.getDescription());

        Coffee milkCoffee = new MilkCoffeeDecorator(coffee);
        System.out.println(milkCoffee.getCost());
        System.out.println(milkCoffee.getDescription());

        Coffee sugarCoffee = new SugarCoffeeDecorator(coffee);
        System.out.println(sugarCoffee.getCost());
        System.out.println(sugarCoffee.getDescription());

        Coffee milkSugarCoffee = new MilkCoffeeDecorator(new SugarCoffeeDecorator(coffee));
        System.out.println(milkSugarCoffee.getCost());
        System.out.println(milkSugarCoffee.getDescription());
    }
}
```

在这个示例中，`Coffee` 是组件接口，`SimpleCoffee` 是具体组件。`CoffeeDecorator` 是装饰器的抽象类，`MilkCoffeeDecorator` 和 `SugarCoffeeDecorator` 是具体装饰器。客户端代码可以根据需要组合装饰器来增加额外的功能。装饰模式提供了一种灵活的方式来增加对象的功能，而不需要改变现有的代码结构。

**装饰模式的使用场景有哪些?**
装饰模式的使用场景有以下几个:

1. Spring AOP:Spring 中的 AOP 功能实际上使用了装饰模式的思想。通过创建代理对象，可以在不修改原始对1象的情况下，动态地为目标对象增加额外的功能，如事务管理、日志记录等。
2. Filter 过滤器:在 Spring Web 应用中，可以使用 Servlet Filter 对请求进行预处理和后处理。这是典型的装饰模式的应用，因为 Filter 类实现了与原始 Servlet 相同的接口，可以在添加自定义行为的同时调用原始 Servlet的方法。
3. Spring Security:Spring Security 是用于身份验证和授权的库，它使用装饰模式来提供功能强大的安全性。
   Spring Security 使用包装器模式来对原始的 Web 请求进行保护、处理认证和授权等操作。

## 10. 什么是代理模式?它的使用场景有哪些?

代理模式（Proxy Pattern）是一种结构型设计模式，它为其他对象提供一个代理或占位符，以控制对这个对象的访问。代理模式可以在不改变对象的代码的情况下，为对象添加额外的功能，如访问控制、延迟初始化、日志记录等。

代理模式的主要目的是为一个对象提供一个代理对象，从而在不改变原有对象代码的前提下，增加额外的功能。

代理模式通常包含以下几个角色：

1. **主题（Subject）**：
   - 定义了真实对象和代理对象共有的接口。

2. **真实主题（Real Subject）**：
   - 定义了代理所代表的真实对象，实现了主题接口。

3. **代理（Proxy）**：
   - 包含对真实主题的引用，实现了主题接口，并在调用真实对象之前或之后添加额外的处理。

4. **客户端（Client）**：
   - 通过主题接口与代理对象或真实对象进行交互。

代理模式的类型包括：

1. **静态代理**：
   - 通过继承或组合实现代理功能。

2. **动态代理**：
   - 利用反射机制在运行时创建代理对象。

3. **虚拟代理**：
   - 延迟初始化资源密集型对象，直到真正需要时才创建。

4. **智能引用代理**：
   - 在访问对象时执行额外的操作，如引用计数、加载持久对象等。

5. **保护代理**：
   - 控制对原始对象的访问权限。

6. **远程代理**：
   - 为远程对象提供局部代表。

### Java代码示例（静态代理）：

```java
// 主题接口
interface Subject {
    void request();
}

// 真实主题
class RealSubject implements Subject {
    public void request() {
        System.out.println("RealSubject: Handling request.");
    }
}

// 代理
class Proxy implements Subject {
    private RealSubject realSubject;

    public Proxy() {
        this.realSubject = null;
    }

    public void setRealSubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    public void request() {
        preRequest();
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        realSubject.request();
        postRequest();
    }

    private void preRequest() {
        System.out.println("Proxy: Logging the time of request.");
    }

    private void postRequest() {
        System.out.println("Proxy: Logging the time of response.");
    }
}

// 客户端代码
public class ProxyPatternDemo {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.setRealSubject(new RealSubject());
        proxy.request();
    }
}
```

在这个示例中，`Subject` 是主题接口，`RealSubject` 是真实主题，`Proxy` 是代理类。客户端通过代理类 `Proxy` 来访问 `RealSubject`。在调用真实主题的方法之前和之后，代理类可以添加额外的处理，如日志记录。

**代理模式的使用场景有哪些?**
Java 中的 JDK Proxy、Spring 中的 AOP、声明式事务 @Transactional 等，都是通过代理模式实现的。

## 11. 什么是模板方法模式?它的使用场景有哪些?

模板方法模式（Template Method Pattern）是一种行为型设计模式，**它在父类中定义一个算法的框架，允许子类在不改变算法结构的情况下重写算法的某些步骤。**

模板方法模式的主要目的是：
1. 封装算法不变部分，同时将可变部分留给子类实现。
2. 提供一个公共的行为模板，子类可以扩展或修改某些步骤而不改变算法结构。

### 模板方法模式的结构：
- **抽象类（Abstract Class）**：定义模板方法和算法框架。
- **具体方法（Concrete Method）**：在抽象类中实现，通常是 final 的，不可被子类修改。
- **模板方法（Template Method）**：定义算法的框架，调用多个步骤按顺序执行。
- **钩子方法（Hook Method）**：在抽象类中定义，被子类可选择性重写。
- **具体类（Concrete Class）**：实现模板方法中的步骤，或者重写钩子方法。

### Java代码示例：

```java
// 抽象类定义算法框架
abstract class Game {
    // 模板方法定义游戏的骨架
    final void play() {
        initialize();
        startPlay();
        endPlay();
    }

    // 具体方法，初始化游戏
    void initialize() {
        System.out.println("Initializing the game...");
    }

    // 抽象方法，子类需要实现具体的游戏逻辑
    abstract void startPlay();

    // 钩子方法，子类可以选择性重写
    void endPlay() {
        System.out.println("Ending the game...");
    }
}

// 具体类实现抽象类的方法
class Cricket extends Game {
    @Override
    void startPlay() {
        System.out.println("Playing cricket...");
    }
}

class Football extends Game {
    @Override
    void startPlay() {
        System.out.println("Playing football...");
    }
}

public class TemplateMethodPatternDemo {
    public static void main(String[] args) {
        Game cricket = new Cricket();
        Game football = new Football();

        System.out.println("Playing Cricket:");
        cricket.play();

        System.out.println("\nPlaying Football:");
        football.play();
    }
}
```

在这个示例中，`Game` 是一个抽象类，它定义了模板方法 `play()`，该方法按顺序调用 `initialize()`、`startPlay()` 和 `endPlay()` 方法。`Cricket` 和 `Football` 是具体类，它们继承自 `Game` 并实现 `startPlay()` 方法。`play()` 方法提供了一个固定的游戏流程，而 `startPlay()` 方法则由子类根据具体的游戏来实现。

模板方法模式非常适合于那些算法结构固定，但某些步骤在具体实现时需要变化的情况。它使得代码复用最大化，同时保持了良好的扩展性。
**模板方法模式的使用场景有哪些?**
模版方法模式的典型使用场景是 **Spring 中 AbstractApplicationContext，它定义了整个 Spring 上下文(ApplicationContext)的创建和管理流程，包括配置读取、Bean 的实例化和依赖注入等过程，以及容器的启动和关闭**。AbstractApplicationContext 中提供了一个模板方法 refresh()，该方法定义了 Spring 上下文的创建和初始化的整体流程，它包含了一系列的具体步骤，如读取配置信息、创建Beanfactory、加载 Bean 的定义、实例化Bean 等。
子类通过继承 AbstractApplicationContext，实现其中的具体步骤，来完成对应的功能。不同的子类可以通过重写模板方法中的具体步骤来定制自己的行为，以适应不同的应用场景。具体的子类，如ClassPathXmlApplicationContext(根据 XML 配置文件初始化 Spring 容器上下文)AnnotationConfigApplicationContext(根据注解初始化 Spring 容器上下文)等，根据不同的配置方式和上下文要求，提供了不同的实现方式。

## 12. 什么是策略模式？使用场景有哪些？

策略模式（Strategy Pattern）是一种行为型设计模式，它**定义了一系列算法族，分别封装起来，让它们之间可以互相替换。策略模式让算法的变化独立于使用算法的客户，使得算法在运行时可以灵活地改变。**

### 策略模式的核心思想

策略模式的核心思想是**将算法族封装在不同的类中，使得算法的变化不会影响客户端。策略模式通常包括上下文策略、中序策略和组合策略等。**

### 使用场景

1. **算法的可替换性**：
   当系统中需要使用多种算法，并且这些算法可以相互替换时，可以使用策略模式。

2. **算法的可扩展性**：
   当需要在不修改客户端代码的情况下增加新的算法时，可以使用策略模式。

3. **算法的独立性**：
   当算法的实现和使用解耦合时，可以使用策略模式。

4. **算法的可配置性**：
   当算法的选择和配置需要在运行时确定时，可以使用策略模式。

### 策略模式的结构

策略模式通常包括以下组件：

- **上下文（Context）**：
   维护一个或引用算法族的实例。

- **策略接口（Strategy）**：
   定义算法族的接口，声明了算法的行为。

- **具体策略（ConcreteStrategy**）**：
   实现了算法族的接口，提供具体的算法实现。

### Java 中的实现

在Java中，策略模式通常通过接口和实现该接口的类来实现。以下是一个简单的策略模式实现示例：

```java
// 策略接口
public interface Strategy {
    public void execute();
}

// 具体策略实现
public class ConcreteStrategyA implements Strategy {
    public void execute() {
        System.out.println("Executing ConcreteStrategyA");
    }
}

// 客户端使用策略
public class Client {
    public void useStrategy(Strategy strategy) {
        strategy.execute();
    }
}

// 使用示例
public class Main {
    public static void main(String[] args) {
        Client useStrategy new ConcreteStrategyA();
    }
}
```

在这个例子中，`Strategy` 是策略接口，`ConcreteStrategyA` 是策略接口的具体实现，`Client` 是客户端类，它使用策略模式来执行特定的策略。

### 注意事项

- 策略模式允许客户端在运行时选择算法，这使得算法的选择和使用解耦合。
- 策略模式支持算法的可替换性，使得算法可以独立于客户端变化。
- 策略模式通常与组合模式结合使用，以提供更灵活的算法组合。

策略模式（Strategy Pattern）的一个通俗易懂的例子是使用不同的支付策略来处理订单支付。

### 场景描述

假设你运营一个在线商店，顾客在结账时可以选择不同的支付方式，比如信用卡、借记卡、PayPal或银行转账。每种支付方式可能有不同的处理方式和费用结构。

### 策略模式的应用

1. **定义支付策略接口**：
   创建一个名为 `PaymentStrategy` 的接口，它包含一个 `pay()` 方法。

2. **实现具体支付策略**：
   为每种支付方式创建一个类，每个类都实现了 `PaymentStrategy` 接口，提供具体的支付逻辑。

3. **上下文（Context）**：
   创建一个类 `PaymentContext`，它维护一个 `PaymentStrategy` 引用，可以动态地改变支付策略。

4. **客户端使用**：
   客户端代码使用 `Context` 来执行支付，根据顾客的选择来设置支付策略。

### Java 实现

```java
// 支付策略接口
public interface PaymentStrategy {
    public void pay(double amount);
}

// 具体支付策略实现
public class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paying with credit card");
    }
}

public class DebitPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paying with debit card");
    }
}

// 上下文（Context）
public class PaymentContext {
    private PaymentStrategy strategy;

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy(double amount) {
        strategy.pay(amount);
    }
}

// 客户端使用
public class Client {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext();
        context.setStrategy(new CreditCardPayment());
        context.executeStrategy(100.0);
        context.setStrategy(new DebitPayment());
        context.executeStrategy(200.0);
    }
```

在这个例子中，`PaymentStrategy` 是支付策略的接口，`CreditCardPayment` 和 `DebitPayment` 是具体支付策略的实现。`PaymentContext` 是上下文，它持有一个 `PaymentStrategy` 的引用，可以根据需要设置为不同的支付策略。`Client` 类是客户端代码，它使用 `PaymentContext` 来执行支付操作。

策略模式允许在运行时选择算法，这使得算法的变化独立于客户端。这种模式适合于算法可能经常变化，或者需要多种算法的场景。

## 13. 什么是观察者模式？使用场景有哪些？

观察者模式（Observer Pattern）是一种行为型设计模式，它定义了对象间的一种一对多依赖关系，让多个观察者对象监听某一个主题对象的状态变化，当主题对象的状态改变时，所有依赖于它的观察者都会收到通知并自动更新。观察者模式是实现发布-订阅机制的一种方式，它支持对象间的低耦合和动态订阅。

### 观察者模式的核心思想

观察者模式的核心思想是将被观察者（Observer）和被观察者（Subject）解耦合，当被观察者的状态改变时，所有注册的观察者都会收到通知。这种模式允许对象状态的动态变化被多个观察者所监听，而不需要直接引用被观察者的具体实现。

## 使用场景

1. **事件处理系统**：
   当系统中的某些事件发生时，需要通知多个组件进行处理，如用户登录、按钮点击等。

2. **数据绑定**：
   在图形用户界面中，将数据模型的变化绑定到视图组件，当数据模型改变时视图自动更新。

3. **通知系统**：
   当应用需要在状态改变时通知用户，如电池电量低、未读消息等。

4. **模型-视图分离**：
   在MVC（Model-View-Controller）架构中，视图组件观察数据模型的变化，当数据模型变化时视图组件更新显示新的数据。

## Java 中的实现

在Java中，观察者模式可以通过实现`java.util.Observable`和`java.util.Observer`类来实现。

```java
import java.util.Observable;
import java.util.Observer;

public class Subject {
    private String state;

    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }

    public String getState() {
        return state;
    }
}

public class Observer implements Observer {
    public void update(Observable o, Object arg) {
        System.out.println("Observer: State changed to " + arg.toString());
    }
}

public class Main {
    public static void main(String[] args) {
        Subject subject = new Subject();
        Observer observer = new Observer();
        subject.addObserver(observer);
        subject.setState("New State");
    }
}
```

在这个例子中，`Subject` 类维护状态，当状态改变时调用`notifyObservers()`方法通知所有观察者。`Observer` 类实现了`Observer`接口，`update()`方法在被调用时处理状态改变。

## 注意事项

- **内存管理**：观察者模式可以导致内存泄露，如果不当取消观察者注册，特别是当观察者生命周期长于被观察者时。
- **性能**：大量的观察者和通知可以影响性能，需要合理设计通知机制，避免过度通知。
- **扩展性**：观察者模式支持动态添加或删除观察者，适合于变化频繁的场景。

## 14. JDK中包含了哪些设计模式?举例说明一下

一、单例模式
在 JDK 中，Runtime 类和 Toolkit 类都使用了单例模式，这些类只能有一个实例，并提供了一个全局访问点。

二、工厂模式

在 JDK 中，Calendar 类使用了工厂方法模式，通过 qetInstance()方法创建 Calendar 对象，能够根据特定的条件返回不同的实现类的实例。

三、适配器模式

在 JDK 中，java.util.Arrays.asList(T... a)方法将数组转换为列表，这可以视为适配器模式的应用，因为它让数组表现得像一个实现了 List 接口的对象，具体实现代码如下

四、装饰模式

在 java.io 包中，I/0 流的实现广泛使用了装饰者模式，例如以下这些:

BufferedReader 是对 Reader 的装饰，添加了缓冲功能。
DataInputStream 是对 InputStream 的装饰，用于处理字节流中的基本数据类型。

五、代理模式
JDK 中的动态代理(JDK Proxy)本身就是代理模式，它的使用示例如下

## 15. sping中包含的设计模式

Spring 框架中常用的设计模式有很多种，以下是其中七种常见的设计模式及其举例：

1. **单例模式（Singleton Pattern）**：Spring 中的 Bean 默认是单例的，即容器中的 Bean 只会被创建一次并在整个应用中共享。例如，ApplicationContext 是一个单例 Bean，整个应用只会有一个 ApplicationContext 实例。

2. **工厂模式（Factory Pattern）**：Spring 中的 BeanFactory 和 ApplicationContext 是工厂模式的典型应用，它们负责创建和管理 Bean 实例。

3. **代理模式（Proxy Pattern）**：Spring AOP（面向切面编程）就是基于代理模式实现的，通过代理可以在目标方法执行前后添加额外的逻辑。

4. **观察者模式（Observer Pattern）**：Spring 中的事件监听机制就是观察者模式的应用，通过 ApplicationEvent 和 ApplicationListener 实现事件的发布和订阅。

5. **模板模式（Template Pattern）**：Spring 中的 JdbcTemplate 是模板模式的典型应用，它定义了数据库操作的基本流程，具体的 SQL 语句由子类实现。

6. **装饰者模式（Decorator Pattern）**：Spring 中的装饰者模式体现在 AOP 的实现上，通过动态代理和切面可以在不修改原有代码的情况下增强对象的功能。

7. **策略模式（Strategy Pattern）**：Spring 中的注解驱动开发就是策略模式的应用，通过不同的注解（如 @Component、@Service、@Controller 等）指定不同的策略来实现不同的功能。

这些设计模式在 Spring 框架中发挥着重要作用，帮助开发者编写可维护、可扩展的应用程序。

## 16. Mybatis中包含的设计模式

MyBatis 中包含的设计模式有：

1. **工厂模式（Factory Pattern）**：MyBatis 使用工厂模式来创建 SqlSessionFactory 对象，通过 SqlSessionFactory 创建 SqlSession 对象。

2. **建造者模式（Builder Pattern）**：在 MyBatis 的配置文件中，可以使用建造者模式来构建 Configuration 对象，简化配置的过程。

3. **装饰者模式（Decorator Pattern）**：MyBatis 中的插件机制就是基于装饰者模式实现的，可以在 SQL 执行的各个阶段插入自定义的逻辑。

4. **代理模式（Proxy Pattern）**：MyBatis 中的 Mapper 接口在运行时会被动态代理，实现了接口方法与 SQL 语句的映射。

5. **模板方法模式（Template Method Pattern）**：MyBatis 中的 Executor 接口和 BaseExecutor 类使用了模板方法模式，定义了 SQL 执行的基本流程，具体的实现由子类完成。

6. **观察者模式（Observer Pattern）**：MyBatis 的事件机制使用了观察者模式，可以在 SQL 执行的各个阶段注册监听器，实现自定义的事件处理逻辑。

7. **策略模式（Strategy Pattern）**：MyBatis 中的 StatementHandler 接口使用了策略模式，根据不同的 SQL 类型选择不同的 Statement 处理策略。

这些设计模式的应用使得 MyBatis 在实现数据访问时更加灵活、可扩展和易于维护。