# Java集合面试题

## 1. Java中的集合？

>Conllection：List、Set、Queue
>Map：

在Java中，`Map` 和 `Collection` 是两个核心接口，它们代表了两种不同的集合类型。以下是它们各自包含的一些常见集合类型：

### Collection 接口下的集合类型：

1. **List**：
   - `ArrayList`：基于动态数组实现，支持随机访问。
   - `LinkedList`：基于双向链表实现，适合频繁的插入和删除操作。
   - `Vector`：和`ArrayList`类似，但它是同步的。

2. **Set**：
   - `HashSet`：基于哈希表实现，不保证集合的迭代顺序。
   - `LinkedHashSet`：类似于`HashSet`，但维护了元素的插入顺序。
   - `TreeSet`：基于红黑树实现，元素处于排序状态。

3. **Queue**：
   - `LinkedList`：可以用作队列，支持`Queue`接口的所有操作。
   - `PriorityQueue`：基于优先级堆实现，元素按照自然顺序或自定义比较器排序。

### Map 接口下的集合类型：

1. **HashMap**：基于哈希表实现，不保证映射的顺序。
2. **LinkedHashMap**：类似于`HashMap`，但维护了元素的插入顺序或访问顺序。
3. **TreeMap**：基于红黑树实现，键处于排序状态。
4. **Hashtable**：类似于`HashMap`，但它是同步的。
5. **ConcurrentHashMap**：线程安全的`HashMap`实现，适用于并发环境。
6. **WeakHashMap**：键是弱引用，键的对象被垃圾回收器回收时，对应的条目会被自动移除。
7. **IdentityHashMap**：使用对象的身份（==）而不是内容（equals）来比较键。

### 其他相关接口和实现：

- **SortedSet**：继承自`Set`，保证元素处于排序状态。
- **SortedMap**：继承自`Map`，保证键处于排序状态。
- **NavigableSet**：继承自`SortedSet`，提供导航方法，可以方便地找到元素。
- **NavigableMap**：继承自`SortedMap`，提供导航方法，可以方便地找到键和值。

这些集合类型提供了不同的功能和性能特点，可以根据具体的应用场景和需求来选择合适的集合类。例如，如果你需要保持元素的插入顺序，可以选择`LinkedHashSet`或`LinkedHashMap`；如果你需要元素处于排序状态，可以选择`TreeSet`或`TreeMap`。

## 2. ArrayList 和 LinkedList?

>1、内部结构 2、随机访问性能 3、插入和删除 4、内存占用 5、性能原因 6、线程安全 7、使用场景

`ArrayList` 和 `LinkedList` 都是 Java 中的两个非常常用的列表（List）实现类，它们都实现了 `List` 接口，但它们在内部数据存储、性能和使用场景上有一些重要的区别：

1. **内部数据结构**：
   - `ArrayList`：基于动态数组实现的，这意味着它的元素在内存中是连续存储的。
   - `LinkedList`：基于双向链表实现的，元素在内存中不是连续存储的，每个元素都通过指针指向前一个和后一个元素。

2. **随机访问性能**：
   - `ArrayList`：提供了快速的随机访问能力，即通过索引访问元素的时间复杂度为 O(1)。
   - `LinkedList`：随机访问性能较差，因为需要从头或尾开始遍历链表直到达到指定的索引位置，时间复杂度为 O(n)。

3. **插入和删除操作**：
   - `ArrayList`：在列表的末尾添加或删除元素是快速的，但如果在列表的中间插入或删除元素，可能需要移动后续或前面的所有元素，这在最坏情况下的时间复杂度为 O(n)。
   - `LinkedList`：在列表的任何位置添加或删除元素都相对快速，因为只需要改变元素之间的指针，时间复杂度为 O(1)，但如果是插入到列表的中间位置，可能需要先遍历到该位置，所以最坏情况下的时间复杂度为 O(n)。

4. **内存占用**：
   - `ArrayList`：由于是连续存储，所以内存利用率较高，但可能需要额外的空间来支持动态扩容。
   - `LinkedList`：每个元素都需要额外的空间来存储指针，所以内存占用通常比 `ArrayList` 高。

5. **性能特点**：
   - `ArrayList`：适合频繁的查找操作，不适合频繁的插入和删除操作。
   - `LinkedList`：适合频繁的插入和删除操作，不适合频繁的查找操作。

6. **线程安全**：
   - 两者都不是线程安全的。如果需要在多线程环境中使用，可以考虑使用 `Vector`（虽然不推荐因为它的性能较差），或者使用 `Collections.synchronizedList` 方法来包装它们，或者使用并发包中的 `CopyOnWriteArrayList`。

7. **使用场景**：
   - `ArrayList`：当你需要快速随机访问列表中的元素时，或者你的列表不需要经常从中间插入或删除元素时。
   - `LinkedList`：当你需要频繁地在列表中插入或删除元素时，或者当你需要一个可以作为队列、栈或双向队列的数据结构时。

在选择 `ArrayList` 和 `LinkedList` 时，应该根据具体的应用场景和性能需求来决定使用哪一个。通常情况下，`ArrayList` 由于其快速的随机访问能力而被更频繁地使用。

**因此，在多查的场景下考虑使用 ArrayList，而在插入和删除比较多的场景下考虑使用 LinkedList。**

## 3. ArrayList线程安全问题？

>1、加锁 2、CopyOnWriteArrayList

`ArrayList` 不是线程安全的。在 Java 中，`ArrayList` 是非同步的，这意味着它没有内置任何机制来处理多个线程同时访问和修改列表的情况。如果多个线程同时修改一个 `ArrayList` 实例，可能会引发不可预知的行为，包括数据不一致和抛出 `ConcurrentModificationException`。

如果你需要在多线程环境中使用列表，有几种方法可以使其线程安全：

1. **使用 `Vector` 类**：
   - `Vector` 是 Java 中的一个古老类，它是线程安全的，因为它的所有公共方法都是同步的。但由于其性能开销，通常不推荐使用。

2. **使用 `Collections.synchronizedList` 方法**：
   - 这个方法可以返回一个线程安全的 `List` 包装器，它在 `ArrayList` 的基础上添加了同步控制。
   ```java
   List<String> syncList = Collections.synchronizedList(new ArrayList<String>());
   ```

3. **使用 `CopyOnWriteArrayList` 类**：
   - `CopyOnWriteArrayList` 是 Java 并发包中的一个线程安全变体，适用于读多写少的场景。每次修改（添加、删除等）都会复制整个底层数组，因此读操作不需要加锁，因为它们作用于不变的数组快照。

4. **手动同步**：
   - 你可以在代码中使用 `synchronized` 关键字来同步对 `ArrayList` 的访问。这可以通过在方法上使用 `synchronized` 关键字或在块上使用 `synchronized` 语句来实现。
   ```java
   synchronized(list) {
       list.add(element);
   }
   ```

5. **使用并发包中的其他并发集合**：
   - Java 的 `java.util.concurrent` 包提供了一些线程安全的集合类，如 `ConcurrentHashMap`，虽然这不是一个列表，但它提供了线程安全的 Map 实现。

在实际应用中，通常推荐使用 `CopyOnWriteArrayList` 或 `Collections.synchronizedList`，因为它们为线程安全提供了更好的性能和灵活性。选择哪种方式取决于具体的应用场景和性能需求。

## 4. HashMap底层？

>底层：数组+链表+红黑树。

`HashMap` 是 Java 中一个非常重要的数据结构，它实现了 `Map` 接口，提供了存储键值对（key-value pairs）的功能。`HashMap` 是基于哈希表（hash table）实现的，它提供了快速的查找、插入和删除操作。以下是 `HashMap` 的一些关键实现细节：

1. **数组和链表**：
   - `HashMap` 内部使用一个数组（实际上是一个 Entry 类型的节点数组）来存储元素。
   - 每个数组元素可以是一个链表（在 Java 8 及以后版本中，当链表长度超过一定阈值时，链表会转换成红黑树）。

2. **哈希函数**：
   - 当插入一个键值对时，`HashMap` 会使用键对象的 `hashCode()` 方法计算哈希码，然后通过哈希函数（如取模运算）将哈希码映射到数组的一个位置上。

3. **冲突解决**：
   - 如果两个键的哈希码相同（即哈希冲突），它们会被存储在同一个数组位置上，形成链表（或红黑树）。

4. **动态扩容**：
   - 当 `HashMap` 中的元素数量超过负载因子（load factor）与当前数组容量的乘积时，`HashMap` 会进行扩容操作，通常是将数组大小扩大一倍，并重新计算所有元素的哈希位置。

5. **默认初始容量**：
   - `HashMap` 有一个默认的初始容量（16），这意味着在没有任何参数的情况下创建 `HashMap` 时，内部数组的大小为 16。

6. **负载因子**：
   - `HashMap` 有一个负载因子（默认为 0.75），它决定了 `HashMap` 在自动扩容前可以达到的满度。

7. **链表和红黑树**：
   - 在 Java 8 及以后的版本中，当链表的长度超过 8 时（即树化阈值），链表会被转换成红黑树，以提高搜索效率。

8. **线程安全性**：
   - `HashMap` 不是线程安全的。如果需要线程安全的 `HashMap`，可以使用 `Hashtable` 或 `Collections.synchronizedMap` 方法，或者使用 `ConcurrentHashMap`。

9. **空键和空值**：
   - `HashMap` 允许一个空键（null key）和多个空值（null value），但只能有一个空键。

10. **迭代器**：
    - `HashMap` 提供了迭代器来遍历键（keySet）、值（values）和键值对（entrySet）。

`HashMap` 的这些特性和实现细节使其成为了 Java 中使用最广泛的数据结构之一，特别是在需要快速查找的场景中。然而，由于它的非线程安全性和对哈希冲突的处理方式，开发者在使用时需要注意选择合适的数据结构和同步机制。

## 5. 为什么HashMap要使用红黑树？而不使用别的树？

HashMap在JDK8中引入了红黑树来解决哈希冲突时链表过长导致性能下降的问题。当链表中的元素个数超过一定阈值（默认为8），链表会转换为红黑树，以提高查找、插入和删除操作的效率。

红黑树是一种自平衡的二叉搜索树，具有较好的平衡性能，能够保证在最坏情况下的时间复杂度为O(log n)，相比于普通的链表，红黑树能够更快地进行查找操作。

其他常见的树结构如AVL树和B树也具有自平衡的特性，但它们在某些方面存在一些缺点：

1. AVL树：AVL树是一种高度平衡的二叉搜索树，保证任意节点的左右子树高度差不超过1。虽然AVL树在查找操作上有着和红黑树相同的时间复杂度，但是在插入和删除操作上，AVL树需要更多的旋转操作来维持平衡，导致性能略低于红黑树。

2. B树：B树是一种多路搜索树，常用于数据库索引等场景。B树相比于红黑树在磁盘IO操作上有着更好的性能，因为B树节点的大小更适合磁盘块的大小，能够减少IO次数。但是在内存中，红黑树通常比B树更快，因为红黑树的节点更小，能够更好地利用CPU缓存。

综上所述，HashMap选择使用红黑树来解决哈希冲突是因为红黑树在平衡性能和操作效率上有着较好的表现，能够更好地满足HashMap的需求。

## 6. 哈希冲突?

哈希冲突指的是当两个不同的输入数据经过哈希函数计算后得到相同的哈希值。哈希函数是将不同长度的输入数据映射为固定长度的输出值的函数。由于哈希函数的输出是固定长度的，而输入的数据可能是任意长度的，所以不同的输入可能会产生相同的哈希值，这就是哈希冲突。

解决哈希冲突的方法有几种：

1. **链地址法（Chaining）**：将哈希表的每个槽（bucket）设为一个链表或者其他数据结构，当发生哈希冲突时，将冲突的元素插入到对应槽的链表中。

2. **开放寻址法（Open Addressing）**：当发生哈希冲突时，通过一定的方法（如线性探测、二次探测、双重散列等）寻找哈希表中的下一个可用位置，直到找到空槽或者找遍整个哈希表。

3. **再哈希法（Rehashing）**：当哈希表的负载因子达到一定阈值时，对哈希表进行扩容，并重新计算所有元素的哈希值，将它们重新插入到新的哈希表中，从而减少哈希冲突的概率。

4. **建立更好的哈希函数**：设计更好的哈希函数可以减少哈希冲突的概率，例如选择合适的哈希算法、考虑输入数据的特征等。

选择哪种解决哈希冲突的方法取决于具体的应用场景和需求。

## 7. 负载因子是0.75?

负载因子是指哈希表在自动扩容之前可以达到的容量与当前容量的比值。在哈希表中，负载因子的选择会影响到哈希表的性能和空间利用率。

负载因子为 0.75 是一个经验上的选择，它在性能和空间利用率之间取得了一种平衡。具体来说，负载因子为 0.75 的选择是基于以下考虑：

1. **性能优化**：较低的负载因子意味着哈希表在填充元素时会更加稀疏，这有助于减少哈希冲突的数量。当哈希表的负载因子较低时，查找、插入和删除操作的平均时间复杂度会更低，因为哈希冲突的概率更小。

2. **空间利用率**：较高的负载因子意味着哈希表会更加紧凑，占用的内存空间较少。然而，如果负载因子过高，会增加哈希冲突的概率，从而影响到性能。

3. **内存与时间的折衷**：选择负载因子 0.75 是在内存利用率和性能之间取得的一种折衷。它既能够保持较高的空间利用率，又能够在一定程度上减少哈希冲突，提高操作的效率。

总的来说，负载因子为 0.75 是经验上的一个常用选择，能够在绝大多数情况下取得较好的性能和空间利用率的平衡。

## 8. HashMap的新增流程？

在Java中，`HashMap`的新增（插入）流程涉及到几个关键步骤。以下是JDK 1.8版本中`HashMap`的`put`操作的一般流程：

1. **计算哈希值**：
   - 首先，通过调用键对象的`hashCode()`方法来计算键的哈希码。
   - 然后，使用这个哈希码通过特定的算法（如与数组长度减一的按位与操作）来计算数组索引，从而确定该键值对应该存储在数组的哪个位置。

2. **处理哈希冲突**：
   - 如果计算出的数组位置已经有元素（即发生了哈希冲突），则需要处理冲突。
   - 在JDK 1.8中，同一个桶（数组位置）上的数据结构可以是链表，也可以是红黑树。当桶中的元素数量小于一定阈值（TREEIFY_THRESHOLD，默认为8）时，使用链表存储。
   - 如果桶中的元素数量达到阈值，并且数组的长度大于等于64，链表会转换成红黑树。

3. **检查是否需要扩容**：
   - 在插入新元素之前，会检查当前数组的负载因子（当前元素数量除以数组容量）是否超过了阈值（默认为0.75）。如果超过，会先进行扩容操作。

4. **扩容操作**：
   - 如果需要扩容，通常会将数组的大小增加一倍。
   - 扩容过程中，需要重新计算所有现有元素的哈希值，并将它们放到新的数组位置上。

5. **插入元素**：
   - 如果没有哈希冲突，或者冲突的桶中的数据结构（链表或红黑树）允许插入，那么直接将新元素插入到桶中。
   - 如果桶中的数据结构是链表，并且链表长度小于阈值，那么新元素会被添加到链表的末尾。
   - 如果桶中的数据结构是红黑树，那么会按照红黑树的规则将新元素插入到树中。

6. **处理键值对相等的情况**：
   - 如果桶中已经存在一个具有相同哈希值且通过`equals()`方法比较后认为相等的键，那么新值会替换旧值。

7. **增加元素数量**：
   - 完成插入操作后，`HashMap`的元素数量会增加。

这个流程确保了`HashMap`可以在保持快速访问的同时，有效地处理哈希冲突和动态调整大小。在多线程环境下，由于`HashMap`不是线程安全的，这些操作可能会导致并发问题，如数据竞争和死锁。因此，在多线程环境中，建议使用`ConcurrentHashMap`或其他线程安全的集合类。

## 9. HashMap的查询流程？

在Java中，`HashMap`的查询流程是一个关键的操作，它涉及到以下几个步骤：

1. **计算哈希值**：
   - 当你尝试获取`HashMap`中某个键（Key）对应的值（Value）时，首先会调用该键的`hashCode()`方法来计算键的哈希值。

2. **确定数组索引**：
   - 使用计算得到的哈希值通过某种算法（通常是取模运算）来确定该键值对在内部数组（或称为“桶”）中的位置。

3. **处理哈希冲突**：
   - 如果该位置上已经存在一个或多个键值对（即发生了哈希冲突），则需要遍历该位置上的链表（在Java 8及之前版本中）或树（在Java 8中，当链表长度超过一定阈值时，链表会转换成红黑树）来查找与给定键相匹配的元素。

4. **比较键**：
   - 在遍历过程中，会使用`equals()`方法来比较当前遍历到的键与目标键是否相等。如果找到相等的键，则返回对应的值。

5. **返回值**：
   - 如果找到了匹配的键，则返回该键对应的值。如果没有找到，则返回`null`。

6. **使用`get()`方法**：
   - 在Java中，你通常使用`HashMap`的`get(Object key)`方法来执行上述查询流程。

以下是`HashMap`查询流程的简化代码示例：

```java
public class HashMap<K, V> {
    // ... 其他成员变量和方法

    public V get(Object key) {
        Node<K, V> e;
        K k = (K) key;
        int h = hash(k);
        e = getNode(h, k);
        return e == null ? null : e.value;
    }

    final Node<K, V> getNode(int hash, Object key) {
        Node<K, V>[] bucket = nodeArray;
        if (bucket == null) {
            return null;
        }
        int i = indexFor(hash, bucket.length);
        Node<K, V> first = bucket[i];
        Node<K, V> e = first;
        while (e != null) {
            K k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                return e;
            }
            e = e.next;
        }
        return null;
    }
}
```

在这个示例中，`getNode()`方法执行了查询流程，`indexFor()`方法用于计算数组索引，`nodeArray`是存储键值对的数组。

需要注意的是，`HashMap`的查询性能在很大程度上取决于哈希函数的质量以及哈希冲突的处理方式。在Java 8中，为了优化长链表的性能问题，引入了红黑树来替代链表。当链表的长度超过一定阈值时，链表会被转换成红黑树，以提高搜索效率。

## 10. HashMap 和 Hashtable 有什么区别?

`HashMap` 和 `Hashtable` 都是 Java 中用于存储键值对的集合类，但它们之间存在一些关键的区别：

1. **线程安全性**：
   - `Hashtable` 是线程安全的，它的所有公共方法都是同步的，这意味着在多线程环境中，`Hashtable` 可以安全地被多个线程访问。
   - `HashMap` 是非线程安全的，它在多线程环境中可能会出现数据不一致的问题。

2. **性能**：
   - 由于 `Hashtable` 的同步机制，`Hashtable` 的性能通常比 `HashMap` 差，尤其是在单线程环境中。
   - `HashMap` 由于没有同步机制，通常具有更好的性能。

3. **方法**：
   - `Hashtable` 提供了一些特定的方法，如 `elements()` 和 `keys()`，这些方法返回的是 `Enumeration` 类型，而不是 `Collection` 类型。
   - `HashMap` 提供了更现代的 `keySet()`、`values()` 和 `entrySet()` 方法，它们返回的是 `Set` 类型，更符合现代集合框架的使用习惯。

4. **null 键和值**：
   - `Hashtable` 不允许使用 `null` 作为键或值。
   - `HashMap` 允许使用 `null` 作为键或值，但只能有一个 `null` 键和多个 `null` 值。

5. **迭代器**：
   - `Hashtable` 使用的迭代器在遍历时如果检测到 `HashMap` 发生结构性修改（如添加或删除元素），会抛出 `ConcurrentModificationException`。
   - `HashMap` 的迭代器不会抛出 `ConcurrentModificationException`，但如果在迭代过程中修改 `HashMap`，迭代器的行为是未定义的。

6. **默认加载因子和初始容量**：
   - `Hashtable` 默认的加载因子是 0.75，初始容量是 11。
   - `HashMap` 默认的加载因子是 0.75，初始容量是 16。

7. **继承关系**：
   - `Hashtable` 继承自 `Dictionary` 类。
   - `HashMap` 继承自 `AbstractMap` 类。

8. **推荐使用**：
   - 由于 `Hashtable` 是一个遗留类，通常不推荐在新代码中使用，而是推荐使用 `HashMap` 或 `ConcurrentHashMap`（需要线程安全时）。

在实际应用中，如果你需要线程安全的 `Map` 实现，可以考虑使用 `ConcurrentHashMap`，它提供了更好的线程安全性和性能。如果你不需要线程安全，`HashMap` 通常是更好的选择。

## 11. 为什么Hashtable不允许插入null键和null值? 

`Hashtable` 不允许插入 `null` 键和 `null` 值的原因主要与它的设计和使用场景有关。以下是几个关键原因：

1. **避免空指针异常**：
   - 在 `Hashtable` 的实现中，如果允许 `null` 作为键或值，那么在执行诸如 `get()`、`put()` 或 `remove()` 等操作时，可能会引发 `NullPointerException`。这是因为在内部实现中，`Hashtable` 可能会尝试调用 `null` 对象的方法，如 `hashCode()` 或 `equals()`，从而导致运行时错误。

2. **确保键的唯一性**：
   - `Hashtable` 要求所有的键都是唯一的。如果允许 `null` 作为键，那么可能会有多个 `null` 键被插入，因为 `null` 键的 `hashCode()` 返回值总是 `0`，这会导致 `Hashtable` 无法区分不同的 `null` 键。

3. **简化实现**：
   - 不允许 `null` 作为键或值可以简化 `Hashtable` 的内部实现，避免在处理 `null` 值时需要进行额外的检查和处理。

4. **与 `HashMap` 的兼容性**：
   - 在 Java 早期版本中，`HashMap` 也不允许 `null` 作为键或值。虽然从 Java 1.2 开始，`HashMap` 允许一个 `null` 键和多个 `null` 值，但 `Hashtable` 保持了不允许 `null` 的设计，以保持与 `HashMap` 的一致性。

5. **避免歧义**：
   - 如果允许 `null` 作为键或值，那么在查询 `null` 键或值时可能会出现歧义。例如，当尝试获取一个不存在的键的值时，返回 `null` 可能意味着键不存在，或者键存在但值为 `null`。

6. **保持一致性**：
   - `Hashtable` 作为同步的 `Map` 实现，其设计目标是提供线程安全的访问。不允许 `null` 键和值有助于保持操作的一致性和可预测性。

需要注意的是，从 Java 1.2 开始，`HashMap` 允许 `null` 作为键和值，这是为了提供更灵活的使用方式。但在 `Hashtable` 中，由于上述原因，仍然不允许 `null` 键和值。在实际应用中，如果你需要线程安全的 `Map` 实现，可以考虑使用 `ConcurrentHashMap`，它提供了更好的线程安全性和性能，同时允许 `null` 键和值。

## 12. HashMap是线程安全的吗?为什么?

>扩容时：环形链表问题  修改时：数据覆盖问题

`HashMap` 在 Java 中是非线程安全的。这意味着在多线程环境中，如果没有采取额外的同步措施，多个线程同时访问和修改 `HashMap` 可能会导致数据不一致、数据损坏或其他不可预知的行为。以下是 `HashMap` 非线程安全的几个原因：

1. **并发修改导致的数据不一致**：
   - 当多个线程同时对 `HashMap` 进行读写操作时，没有同步机制来确保这些操作的原子性，可能会导致数据不一致。

2. **resize操作的竞态条件**：
   - 当 `HashMap` 需要扩容（即重新计算数组大小）时，如果没有适当的同步，多个线程可能会同时触发扩容操作，导致数据丢失或覆盖。

3. **哈希冲突的链表或红黑树**：
   - 在 `HashMap` 中，哈希冲突的元素会被存储在链表或红黑树中。如果没有适当的同步措施，多个线程同时对链表或红黑树进行操作可能会导致数据不一致。

4. **快速失败迭代器**：
   - `HashMap` 的迭代器是快速失败的，意味着在迭代过程中如果检测到 `HashMap` 发生结构性修改（如添加或删除元素），迭代器会立即抛出 `ConcurrentModificationException`。在多线程环境中，这种结构性修改更容易发生，导致迭代器更容易失败。

为了在多线程环境中使用 `HashMap`，可以采取以下措施：

1. **使用 `Collections.synchronizedMap` 方法**：
   - 可以将 `HashMap` 包装为线程安全的 `Map`，但这会降低性能，因为每次访问都需要获取锁。

2. **使用 `ConcurrentHashMap`**：
   - `ConcurrentHashMap` 是 Java 提供的线程安全的 `Map` 实现，它通过分段锁和细粒度锁提供了更好的并发性能。

3. **外部同步**：
   - 在使用 `HashMap` 的代码块外部使用同步机制，如 `synchronized` 块或 `ReentrantLock`，来确保同时只有一个线程能够修改 `HashMap`。

4. **避免在多线程环境中使用 `HashMap`**：
   - 如果可能，避免在多线程环境中使用 `HashMap`，而是使用线程安全的 `Map` 实现，如 `ConcurrentHashMap`。

总的来说，`HashMap` 由于其非线程安全的特性，在多线程环境中需要谨慎使用。在需要线程安全的 `Map` 时，推荐使用 `ConcurrentHashMap` 或其他线程安全的集合类。

##  13. HashMap扩容的时候为什么会死循环问题?

HashMap在JDK 1.7版本中因为采用了头插法（在链表中插入元素时，总是将新元素插入到链表的头部）进行扩容操作，这在多线程环境下可能会导致死循环的问题。具体来说，当多个线程同时对HashMap进行扩容操作时，可能会形成一个循环链表，导致在执行get操作时出现无限循环，从而使得CPU使用率飙升。

在JDK 1.8中，HashMap的扩容操作已经改为尾插法，并且引入了红黑树来优化长链表的性能问题，这样就避免了在多线程环境下形成循环链表的可能性。

为了避免死循环的问题，可以采取以下几种策略：
1. 使用线程安全的`ConcurrentHashMap`替代`HashMap`。
2. 使用`Hashtable`，但它的性能较低。
3. 在使用`HashMap`时，通过外部同步（例如使用`synchronized`或`ReentrantLock`）来保证多线程下的线程安全。

在实际应用中，推荐使用`ConcurrentHashMap`来替代`HashMap`，以获得更好的线程安全性和并发性能。

## 14. HashMap为什么会数据覆盖?

插入数据时候没有上锁

## 15. 如何保证HashMap线程安全?

为了保证 `HashMap` 在多线程环境下的线程安全，可以采取以下几种策略：

1. **使用 `ConcurrentHashMap`**：
   - `ConcurrentHashMap` 是 Java 提供的一个线程安全的哈希表实现，它通过分段锁（Segmentation）来允许多个线程同时访问和修改不同的段（Segment），从而提供了比 `Hashtable` 更好的并发性能。

2. **使用 `Collections.synchronizedMap`**：
   
   - 通过 `Collections.synchronizedMap` 方法可以将 `HashMap` 包装成一个线程安全的 `Map`。这种方法会在所有 `HashMap` 的访问操作上添加同步控制，但可能会因为锁的粒度较粗而影响性能。
   
   ```java
   Map<K, V> map = Collections.synchronizedMap(new HashMap<K, V>());
   ```
   
3. **使用 `Hashtable`**：
   - `Hashtable` 是一个古老的 `Map` 实现，它的所有公共方法都是同步的。但由于它的性能较差，通常不推荐使用，除非对性能要求不高。

4. **使用 `ReadWriteLock`**：
   - `ReadWriteLock` 允许多个线程同时进行读操作，但在写操作时会排他性地锁定。可以通过 `ReadWriteLock` 实现一个线程安全的 `HashMap`，允许多个线程同时读取，而在写入时进行同步。

5. **使用外部同步**：
   - 在使用 `HashMap` 的代码块外部使用同步机制，如 `synchronized` 关键字或显式的锁（如 `ReentrantLock`），来确保在修改 `HashMap` 时只有一个线程能够进行操作。

   ```java
   public class SafeHashMap<K, V> {
       private final Map<K, V> map = new HashMap<>();
       private final Object lock = new Object();
   
       public V put(K key, V value) {
           synchronized (lock) {
             return map.put(key, value);
         }
       }
   
       public V get(K key) {
           synchronized (lock) {
             return map.get(key);
         }
       }
   
       // 其他方法...
   }
   ```

6. **避免在多线程环境中使用 `HashMap`**：
   - 如果可能，避免在多线程环境中使用 `HashMap`，而是使用线程安全的替代品，如 `ConcurrentHashMap`。

7. **使用 `CopyOnWriteArrayList` 作为值容器**：
   - 当 `HashMap` 的值是列表时，可以使用 `CopyOnWriteArrayList` 作为列表的实现，以提高读操作的并发性能。

选择哪种策略取决于具体的应用场景和性能要求。通常情况下，`ConcurrentHashMap` 是首选，因为它提供了良好的并发性能和灵活性。

## 16. Hashtable是如何保证线程安全的?

`Hashtable` 保证线程安全的方式主要依赖于 synchronized 关键字，这使得它在多线程环境中能够安全地被使用。以下是 `Hashtable` 实现线程安全的具体方法：

1. **全局锁**：
   - `Hashtable` 的大部分方法，如 `put`、`get`、`remove` 等，都是同步的（synchronized）。这意味着在任何时候，只有一个线程可以执行这些方法，从而避免了多线程同时修改 `Hashtable` 导致的并发问题。

2. **方法同步**：
   - `Hashtable` 的每个公共方法，如 `put`、`get`、`remove` 等，都通过 `synchronized` 关键字进行了同步，这确保了在多线程环境中，这些方法不会被并发地调用。

3. **迭代器安全**：
   - `Hashtable` 提供的迭代器是弱一致的（weakly consistent），这意味着迭代器不会抛出 `ConcurrentModificationException`。但是，它不保证在迭代过程中 `Hashtable` 的修改会立即反映在迭代器上。

4. **不支持 null 键和值**：
   - 与 `HashMap` 不同，`Hashtable` 不允许使用 null 作为键（key）或值（value）。尝试插入 null 键或值会抛出 `NullPointerException`。这个限制有助于避免一些潜在的线程安全问题。

5. **性能开销**：
   - 由于 `Hashtable` 使用了全局锁，所以在高并发环境下，它的性能可能不如 `HashMap`。在单个线程中，每次对 `Hashtable` 的操作都需要获取锁，这可能导致线程争用和性能瓶颈。

6. **替代方案**：
   - 由于 `Hashtable` 的性能开销，现代 Java 编程中更推荐使用 `ConcurrentHashMap` 作为线程安全的 `Map` 实现。`ConcurrentHashMap` 通过分段锁（segmentation）和细粒度锁（fine-grained locking）提供了更好的并发性能。

总结来说，`Hashtable` 通过在所有公共方法上使用 `synchronized` 关键字来保证线程安全，但这也会带来性能上的考虑。在需要线程安全的 `Map` 时，可以考虑使用 `ConcurrentHashMap` 作为更高效的替代品。

## 17. ConcurrentHashMap为什么是线程安全的? 

`ConcurrentHashMap` 是线程安全的，它通过以下几种机制来实现线程安全：

1. **分段锁（Segmentation）**：
   - 在 `ConcurrentHashMap` 的早期实现（如 Java 5 和 Java 6）中，它使用分段锁机制。这意味着 `ConcurrentHashMap` 被分为多个段（segment），每个段是一个小的 `HashMap`，并且有自己的锁。当一个线程访问 `ConcurrentHashMap` 的一个段时，它不会影响其他段的访问。这种分段机制减少了锁的竞争，提高了并发性能。

2. **CAS 操作**：
   - `ConcurrentHashMap` 在某些操作中使用了原子操作，如 Compare-And-Swap (CAS)。CAS 操作是一种无锁的非阻塞算法，它允许多个线程在没有传统锁的情况下安全地更新共享数据。

3. **Node 和 TreeNode 结构**：
   - 在 Java 8 及以后的版本中，`ConcurrentHashMap` 使用了 `Node` 和 `TreeNode` 结构来存储键值对。这些结构支持无锁的链表和红黑树操作，进一步减少了锁的需求。

4. **Synchronized 代码块**：
   - 在某些情况下，`ConcurrentHashMap` 仍然使用 `synchronized` 代码块来确保线程安全。但是，这些同步代码块通常只锁定了 `ConcurrentHashMap` 的一小部分，而不是整个结构，这样可以在保持线程安全的同时提高并发性能。

5. **减少锁的竞争**：
   - `ConcurrentHashMap` 通过减少锁的竞争来提高并发性能。它允许多个线程同时读写不同的段或不同的节点，而不会相互干扰。

6. **扩容操作**：
   - 在 `ConcurrentHashMap` 中，扩容操作也是线程安全的。当需要扩容时，`ConcurrentHashMap` 会创建一个新的更大的数组，并且逐个重新映射旧数组中的元素到新数组中。这个过程中，读操作仍然可以继续执行，而写操作会在必要时等待或协助扩容。

7. **volatile 变量**：
   - `ConcurrentHashMap` 使用 `volatile` 关键字来声明一些变量，确保这些变量的读写操作对所有线程都是可见的，并且在多核处理器上正确地同步。

通过这些机制，`ConcurrentHashMap` 在保持高并发性能的同时，确保了线程安全。这使得它成为多线程环境中处理并发数据更新的首选数据结构之一。

## 18. 什么是分段锁？ 实现一个分段锁？

分段锁是一种用于提高并发数据结构性能的锁机制。它将数据结构分成多个段，每个段都由一个锁来保护。这样，当多个线程需要同时访问数据结构的不同段时，它们可以独立地获取各自段的锁，从而减少了锁竞争，提高了并发性能。

下面是一个简单的Java实现分段锁的例子：

```java
import java.util.concurrent.locks.ReentrantLock;

public class SegmentedLock {
    private final ReentrantLock[] locks;
    private final int segments;

    public SegmentedLock(int segments) {
        this.segments = segments;
        this.locks = new ReentrantLock[segments];
        for (int i = 0; i < segments; i++) {
            locks[i] = new ReentrantLock();
        }
    }

    public void lock(int hash) {
        locks[hash % segments].lock();
    }

    public void unlock(int hash) {
        locks[hash % segments].unlock();
    }

    public void execute(int hash, Runnable action) {
        lock(hash);
        try {
            action.run();
        } finally {
            unlock(hash);
        }
    }
}
```

在这个例子中，`SegmentedLock` 类有一个 `ReentrantLock` 数组，每个数组元素代表一个段的锁。`lock` 方法接受一个哈希值，计算出应该锁定的段，然后获取该段的锁。`unlock` 方法释放锁。`execute` 方法接受一个哈希值和一个 `Runnable` 动作，它锁定对应的段，执行动作，并在完成后释放锁。

使用这个分段锁的示例：

```java
import java.util.concurrent.locks.ReentrantLock;

class SegmentedLock {
    private final ReentrantLock[] locks;
    private final int segments;

    public SegmentedLock(int segments) {
        this.segments = segments;
        this.locks = new ReentrantLock[segments];
        for (int i = 0; i < segments; i++) {
            locks[i] = new ReentrantLock();
        }
    }

    public void lock(int hash) {
        locks[hash % segments].lock();
    }

    public void unlock(int hash) {
        locks[hash % segments].unlock();
    }

    public void execute(int hash, Runnable action) {
        lock(hash);
        try {
            action.run();
        } finally {
            unlock(hash);
        }
    }
}

class Main {
    public static void main(String[] args) {
        SegmentedLock segmentedLock = new SegmentedLock(10); // 创建一个有10个段的分段锁

        for (int i = 0; i < 20; i++) {
            int finalI = i;
            new Thread(() -> {
                segmentedLock.execute(finalI, () -> {
                    System.out.println("Thread " + Thread.currentThread().getName() + " locked on segment " + finalI);
                    // 模拟长时间操作
                    try {
                        Thread.sleep(10000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    System.out.println("Thread " + Thread.currentThread().getName() + " unlocked on segment " + finalI);
                }); 
            }).start();
        }
    }
}
```

在这个示例中，我们创建了一个 `SegmentedLock` 实例，它有10个段。然后，我们启动了20个线程，每个线程都尝试锁定一个段并执行一个操作。由于我们只有10个段，所以这个示例可能会导致一些线程竞争同一个段的锁。

请注意，这个示例是为了演示分段锁的概念而简化的。在实际应用中，你可能需要考虑更多的因素，比如锁的公平性、锁的可重入性、锁的获取和释放策略等。此外，Java的 `ConcurrentHashMap` 在JDK 1.7中使用了类似的分段锁机制，但在JDK 1.8中已经废弃了这种设计，转而使用CAS操作和synchronized同步块来提高性能。

## 19. 说一下ConcurrentHashMap的锁优化?

`ConcurrentHashMap` 在 Java 中是一个线程安全的哈希表，它通过不同的锁优化策略来提高并发性能。以下是 `ConcurrentHashMap` 在 JDK 1.7 和 JDK 1.8 中的锁优化方式：

### JDK 1.7 中的 `ConcurrentHashMap`：

在 JDK 1.7 版本中，`ConcurrentHashMap` 使用分段锁（Segmentation Lock）机制来提供线程安全。它内部由多个段（Segment）组成，每个段实际上是一个小的哈希表，有自己的锁（ReentrantLock）。当进行修改操作时，只需要锁定涉及到的那个段，而不是整个哈希表。这种分段锁的设计减少了锁的粒度，提高了并发性能。

### JDK 1.8 中的 `ConcurrentHashMap`：
到了 JDK 1.8，`ConcurrentHashMap` 的实现发生了显著变化，它摒弃了分段锁的设计，转而采用了 CAS（Compare-And-Swap）操作和 synchronized 同步块来保证线程安全。JDK 1.8 中的 `ConcurrentHashMap` 采用了数组+链表+红黑树的数据结构，当链表长度超过阈值时会转换为红黑树，以优化搜索性能。

在 JDK 1.8 中，`ConcurrentHashMap` 的主要锁优化包括：
1. **CAS 操作**：用于无锁地添加、删除和更新节点，减少了锁的使用。
2. **synchronized 同步块**：在必要时，如树化操作和扩容时，使用 synchronized 同步块来保护关键代码段。
3. **减少锁的竞争**：通过更细粒度的锁策略，允许多个线程并发地访问不同部分的数据。

### 总结：
`ConcurrentHashMap` 在 JDK 1.7 中通过分段锁来提高并发性能，在 JDK 1.8 中则通过 CAS 操作和 synchronized 同步块来进一步优化锁策略，同时引入了红黑树来提高长链表的搜索效率。这些改进使得 `ConcurrentHashMap` 在高并发环境下提供了更好的性能。

参考资料：
- [ConcurrentHashMap的演进：从Java 8之前到Java 17的实现原理深度剖析-阿里云开发者社区](https://cloud.tencent.com/developer/article/2398582) 
- [彻底搞清楚ConcurrentHashMap的实现原理(含JDK1.7和JDK1.8的区别) – mikechen](https://mikechen.cc/6790.html) 

## 20. ConcurrentHashMap为什么不能插入null?

`ConcurrentHashMap` 不允许插入 `null` 键（key）或 `null` 值（value）的原因主要有以下几点：

1. **避免空指针异常**：
   - 在 `ConcurrentHashMap` 的内部实现中，有许多地方使用了键（key）和值（value）的非空校验。如果允许 `null` 键或值，那么在执行某些操作时可能会抛出 `NullPointerException`，这会影响 `ConcurrentHashMap` 的稳定性和可靠性。

2. **保持与 `HashMap` 的一致性**：
   - 自 Java 8 起，`HashMap` 也不允许插入 `null` 键和 `null` 值。`ConcurrentHashMap` 作为线程安全的 `HashMap`，保持这一限制可以确保两者在行为上的一致性。

3. **简化实现**：
   - 不允许 `null` 可以简化 `ConcurrentHashMap` 的内部实现。例如，在扩容或重新哈希时，不需要额外处理 `null` 键或值的情况，这样可以减少实现的复杂性。

4. **提高确定性**：
   - 禁止 `null` 键和值可以提高 `ConcurrentHashMap` 的确定性。在并发环境中，不需要担心 `null` 值带来的不确定性，从而使得调试和维护更加容易。

5. **避免歧义**：
   - 如果允许 `null` 值，可能会在某些情况下造成歧义。例如，当尝试查找一个不存在的键时，返回 `null` 可能意味着键不存在，或者键存在但值就是 `null`。禁止 `null` 值可以消除这种歧义。

6. **提高性能**：
   - 在某些实现中，`null` 键或值可能会被用作哨兵值（sentinel value），用于表示特定的状态。如果允许 `null` 作为键或值，那么就需要额外的逻辑来区分这些哨兵值和实际的 `null` 值，这可能会影响性能。

由于上述原因，`ConcurrentHashMap` 被设计为不允许插入 `null` 键或 `null` 值，这样可以确保其在多线程环境中的稳定性、一致性和性能。



## 21. 链表的分类有哪些？

在Java中，链表可以根据其实现方式和特性进行分类。常见的链表分类包括：

1. 单向链表（Singly Linked List）：每个节点包含一个指向下一个节点的引用。
2. 双向链表（Doubly Linked List）：每个节点包含一个指向前一个节点和一个指向下一个节点的引用。
3. 循环链表（Circular Linked List）：尾节点指向头节点，形成一个循环。
4. 双向循环链表（Doubly Circular Linked List）：既是双向链表又是循环链表，头节点的前一个节点指向尾节点，尾节点的下一个节点指向头节点。

这些链表分类在Java中都有相应的实现方式，可以根据具体需求选择适合的链表类型。

## 22. 树的分类有哪些？

在Java中，树可以按照多种标准进行分类。以下是一些常见的树分类：

1. **二叉树（Binary Tree）**：每个节点最多有两个子节点，即左子节点和右子节点。

2. **二叉搜索树（Binary Search Tree）**：是一种特殊的二叉树，左子树上的所有节点都小于根节点，右子树上的所有节点都大于根节点。
3. 完全二叉树
4. **AVL树**：是一种自平衡二叉搜索树，通过旋转操作来保持平衡。

5. **红黑树（Red-Black Tree）**：是一种自平衡二叉搜索树，通过约束条件保持平衡，如节点颜色和路径黑高度。

6. **B树（B-Tree）**：一种多路搜索树，每个节点可以有多个子节点，用于磁盘和数据库索引等场景。

7. **B+树（B+ Tree）**：是一种B树的变体，用于数据库和文件系统中的索引结构，提供更好的范围查询性能。

8. **Trie树（字典树）**：是一种树形数据结构，用于存储关联数组，其中所有具有相同前缀的键都共享相同的前缀树。

以上是一些常见的树的分类，每种树都有其特定的应用场景和优势。

## 23. ArrayList 和 Vector 有什么区别?

`ArrayList` 和 `Vector` 都是 Java 中的两个非常常用的类，它们都实现了 `List` 接口，提供了动态数组的功能。尽管它们有很多相似之处，但它们之间存在一些关键的区别：

1. **同步性**：
   - `Vector` 是同步的。它的所有公共方法都是同步的，这意味着在多线程环境中，`Vector` 可以安全地被多个线程访问而不需要额外的同步措施。
   - `ArrayList` 是非同步的。它不是线程安全的，因此在多线程环境中使用 `ArrayList` 时需要额外的同步措施，比如通过外部同步（使用 `synchronizedList` 方法）或使用 `Collections.synchronizedList` 方法。

2. **性能**：
   - 由于 `Vector` 的同步特性，它在单线程环境中的性能通常比 `ArrayList` 差，因为每次操作都需要进行同步，这增加了额外的开销。
   - `ArrayList` 在单线程环境中提供了更好的性能，因为它没有同步的开销。

3. **方法**：
   - `Vector` 提供了一些额外的方法，如 `addElement()`、`removeElement()`、`insertElementAt()` 和 `elementAt()`，这些方法在 `ArrayList` 中没有直接对应的方法。
   - `ArrayList` 提供了 `trimToSize()`、`ensureCapacity()` 等方法，这些方法在 `Vector` 中没有直接对应的方法。

4. **初始容量和扩容**：
   - `Vector` 允许在创建时指定初始容量和扩容因子，如果 `Vector` 需要扩容，它会根据扩容因子来增加容量。
   - `ArrayList` 也有初始容量的概念，但它的扩容策略是将容量大约翻倍，而不是根据一个因子来增加。

5. **遗留类**：
   - `Vector` 是 Java 早期版本中的一个类，它存在于 `java.util` 包中，是一个遗留类。它的设计反映了早期 Java 集合框架的设计思想。
   - `ArrayList` 是 Java 集合框架的一个较新的实现，它提供了更好的性能和更丰富的 API。

6. **使用建议**：
   - 由于 `Vector` 的性能问题和同步开销，通常建议在需要线程安全的情况下使用 `ArrayList` 并结合外部同步措施，或者使用 `CopyOnWriteArrayList`。
   - `ArrayList` 是大多数情况下的首选，因为它提供了更好的性能和灵活性。

总的来说，`ArrayList` 是现代 Java 编程中更常用的选择，因为它提供了更好的性能和更简洁的 API。而 `Vector` 由于其同步特性，在某些特定的多线程环境中可能仍然有用，但它的使用通常不推荐，除非确实需要它的同步特性。

## 24. ArrayList是如何进行扩容的?

`ArrayList` 在 Java 中是通过一个动态数组来实现的，它允许在列表末尾高效地添加元素。但是，当添加的元素超过了数组的当前容量时，`ArrayList` 就需要进行扩容操作。以下是 `ArrayList` 扩容的详细过程：

1. **检查容量**：
   - 当尝试添加一个元素到 `ArrayList` 时，首先会检查当前数组的容量是否足够。如果容量不足，就会触发扩容操作。

2. **扩容机制**：
   - `ArrayList` 的扩容机制是通过创建一个新的数组来实现的，这个新数组的大小是当前数组大小的1.5倍（也就是原来的容量加上原来的容量的一半）。
   - 这种扩容策略是为了在动态数组需要增长时，尽量减少内存重新分配的次数，从而在添加元素时保持较好的性能。

3. **复制元素**：
   - 创建新数组后，`ArrayList` 会将所有旧数组中的元素复制到新数组中。这个复制过程是逐个元素进行的，从旧数组的起始位置到末尾。

4. **更新引用**：
   - 复制完成后，`ArrayList` 会更新内部的数组引用，使其指向新创建的数组。

5. **添加新元素**：
   - 在新数组中，`ArrayList` 会将新元素添加到数组的末尾。

6. **成本**：
   - 扩容操作的成本相对较高，因为它涉及到创建新数组和复制旧数组中的所有元素。因此，虽然 `ArrayList` 在添加元素时是常数时间复杂度（O(1)），但在需要扩容时，这个操作的时间复杂度是线性的（O(n)）。

7. **避免频繁扩容**：
   - 为了避免频繁扩容，可以在创建 `ArrayList` 时指定一个合理的初始容量，或者在知道将要添加大量元素时提前增加容量。

以下是扩容操作的简化代码示例：

```java
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(minCapacity, DEFAULT_CAPACITY);
    }
    return newCapacity(elementData.length, minCapacity);
}

private static int newCapacity(int current, int minCapacity) {
    // overflow-conscious code
    int newCapacity = current + (current >> 1);
    if (newCapacity - minCapacity <= 0) {
        newCapacity = Integer.MAX_VALUE;
    }
    return (newCapacity > minCapacity) ? newCapacity : minCapacity;
}
```

在这个示例中，`calculateCapacity` 方法用于计算新数组的容量，而 `newCapacity` 方法用于确定新容量应该是当前容量的1.5倍，但至少要大于所需的最小容量。如果计算出的新容量小于最小容量，那么新容量就会被设置为 `Integer.MAX_VALUE`，这是一个非常大的数，确保数组能够容纳足够多的元素。

## 25. Collection 和 Collections 有什么区别?

"Collection" 和 "Collections" 都是 Java 编程语言中的类。它们之间的区别在于：

1. Collection：是 Java 集合框架中的一个接口，用于表示一组对象的集合。它是所有集合类的根接口，定义了集合类的基本操作，如添加、删除、遍历等。常见的 Collection 接口的实现类有 List、Set 和 Queue 等。

2. Collections：是 Java 集合框架中的一个工具类，提供了一系列静态方法用于操作集合。这些方法包括对集合进行排序、查找最大值、最小值、反转集合等。Collections 类中的方法通常接收 Collection 类型的参数，用于对集合进行操作。

简而言之，Collection 是表示集合的接口，而 Collections 是用于操作集合的工具类。

Collections类是Java中用于操作集合的工具类，常用方法有很多，以下是其中的9个常用方法及对应的使用示例：

1. `sort(List<T> list)`：对List集合进行排序。

```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 2));
Collections.sort(numbers);
System.out.println(numbers); // 输出 [1, 2, 3]
```

2. `reverse(List<?> list)`：反转List集合中元素的顺序。

```java
List<String> names = new ArrayList<>(Arrays.asList("Alice", "Bob", "Charlie"));
Collections.reverse(names);
System.out.println(names); // 输出 ["Charlie", "Bob", "Alice"]
```

3. `shuffle(List<?> list)`：随机打乱List集合中元素的顺序。

```java
List<Character> letters = new ArrayList<>(Arrays.asList('a', 'b', 'c', 'd'));
Collections.shuffle(letters);
System.out.println(letters); // 输出 一个随机排列的字符列表
```

4. `binarySearch(List<? extends Comparable<? super T>> list, T key)`：在已排序的List中使用二分查找算法查找指定元素。

```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 3, 5, 7, 9));
int index = Collections.binarySearch(numbers, 5);
System.out.println(index); // 输出 2
```

5. `addAll(Collection<? super T> c, T... elements)`：将指定元素添加到集合中。

```java
List<String> colors = new ArrayList<>(Arrays.asList("Red", "Green"));
Collections.addAll(colors, "Blue", "Yellow");
System.out.println(colors); // 输出 ["Red", "Green", "Blue", "Yellow"]
```

6. `frequency(Collection<?> c, Object o)`：返回指定元素在集合中出现的次数。

```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 2, 2));
int count = Collections.frequency(numbers, 2);
System.out.println(count); // 输出 3
```

7. `max(Collection<? extends T> coll)`：返回集合中的最大元素。

```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 3, 8, 2, 6));
int max = Collections.max(numbers);
System.out.println(max); // 输出 8
```

8. `min(Collection<? extends T> coll)`：返回集合中的最小元素。

```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 3, 8, 2, 6));
int min = Collections.min(numbers);
System.out.println(min); // 输出 2
```

9. `replaceAll(List<T> list, T oldVal, T newVal)`：替换List中所有指定的元素。

```java
List<String> fruits = new ArrayList<>(Arrays.asList("Apple", "Banana", "Apple", "Orange"));
Collections.replaceAll(fruits, "Apple", "Pear");
System.out.println(fruits); // 输出 ["Pear", "Banana", "Pear", "Orange"]
```

这些是Collections类中的一些常用方法及对应的使用示例，希望对你有帮助。

## 26. CopyOnWriteArrayList是线程安全的吗?

`CopyOnWriteArrayList` 是 Java 中 `java.util.concurrent` 包提供的一个线程安全的列表实现。它通过写时复制（Copy-On-Write, COW）的策略来实现线程安全，特别适用于读多写少的场景。以下是 `CopyOnWriteArrayList` 的一些关键特点和原理：

1. **线程安全**：`CopyOnWriteArrayList` 在进行修改操作如添加、删除或更新元素时，会先复制一份当前数组的内容，然后在这份副本上进行修改，最后将修改后的副本替换原来的数组。这种机制确保了在多线程环境下的线程安全性。

2. **读写分离**：由于写操作需要复制数组，读操作可以直接访问原始数组，因此 `CopyOnWriteArrayList` 实现了读写分离，提高了读操作的并发性能。

3. **内存占用**：写操作时复制数组可能会导致内存占用增加，尤其是在列表元素较多时，频繁的复制操作会增加内存消耗。

4. **数据一致性**：`CopyOnWriteArrayList` 只能保证数据的最终一致性，不能保证实时一致性。这意味着在写操作完成之前，读操作可能获取到的是旧数据。

5. **性能问题**：虽然读操作性能很高，但写操作性能可能会下降，因为每次写操作都需要复制整个数组，这在高并发写操作时可能会成为性能瓶颈。

6. **使用场景**：`CopyOnWriteArrayList` 适用于读多写少的场景，如配置信息的读取、状态信息的监控等。

7. **实现原理**：内部使用 `ReentrantLock` 来保证写操作的线程安全，读操作则直接访问数组，不需要加锁。

8. **扩容机制**：与 `ArrayList` 不同，`CopyOnWriteArrayList` 没有自动扩容的概念，每次写操作实际上是在创建一个新的数组。

9. **适用场景**：适用于读多写少的场景，如配置列表、观察者列表等。

10. **优化策略**：可以通过减少写操作的频率、选择合适的并发容器或合理控制数组大小来优化 `CopyOnWriteArrayList` 的性能。

总的来说，`CopyOnWriteArrayList` 是一个在特定场景下非常有用的并发容器，但在使用时需要注意其适用场景和潜在的性能问题。

## 27. 什么是写时复制技术？

写时复制（Copy-On-Write，简称 COW）是一种计算机编程中的优化策略，用于提高程序的性能，特别是在读多写少的场景下。这种策略的核心思想是，当多个线程或进程需要访问同一份数据时，它们可以共享同一份数据副本。只有当某个线程或进程需要修改这份数据时，系统才会真正复制一份数据给它，让它在这份副本上进行修改。其他线程或进程仍然访问原始数据，直到它们也需要进行修改，这时同样会复制一份新的副本。

写时复制技术的关键特点包括：

1. **提高读操作的性能**：因为多个读操作可以共享同一份数据，不需要加锁，从而提高了读取的并发性能。

2. **延迟写操作**：写操作被延迟到真正需要的时候才执行，这样可以减少不必要的数据复制，提高性能。

3. **内存效率**：在数据被真正修改之前，所有读操作都不需要额外的内存开销，因为它们共享同一份数据。

4. **数据一致性**：写时复制可能导致数据一致性问题，因为读操作可能读取到旧的数据。因此，需要确保在适当的时机更新所有相关线程或进程的数据视图。

5. **适用场景**：写时复制技术适用于写操作较少，读操作较多的场景。例如，在某些缓存系统、文件系统和数据库管理系统中，读操作远多于写操作，使用写时复制可以提高系统的整体性能。

在Java中，`CopyOnWriteArrayList` 和 `CopyOnWriteArraySet` 就是使用了写时复制技术的线程安全集合类。在这些类中，所有可变操作（如添加、删除、更新元素）都是通过创建底层数组的新副本来实现的。这样，读操作（如迭代）可以在不加锁的情况下进行，从而提高了并发读取的效率。然而，写操作需要复制整个底层数组，这在写操作频繁时可能会导致性能问题。因此，写时复制技术需要根据具体的应用场景进行权衡和选择。

## 28. HashMap设置初始容量为17，那么它的实际容量是多少?

默认初始是16

2的n次方
所以是32

## 29. 开放地址法如何找下一个空地址?

开放地址法是一种解决哈希冲突的方法，其中当发生哈希冲突时，会尝试在哈希表中的其他位置寻找下一个空地址。具体来说，有几种常见的方法可以用来找到下一个空地址：

1. 线性探测：线性探测是一种简单的方法，当发生哈希冲突时，顺序地检查哈希表中的下一个位置，直到找到一个空地址为止。

2. 二次探测：二次探测是一种改进的方法，当发生哈希冲突时，不是顺序地检查下一个位置，而是按照某种固定的步长进行检查，比如依次检查1, 4, 9, 16等位置。

3. 双重哈希：双重哈希是一种更复杂的方法，它使用两个不同的哈希函数来计算下一个位置，以增加地址的散列性。

无论使用哪种方法，找到下一个空地址的关键是要确保在哈希表中的每个位置都有机会被检查，以便最终找到一个空地址来解决哈希冲突。

## 30. 集合和数组的区别和联系？

集合（Collection）和数组（Array）是 Java 中常用的数据结构，它们有一些区别和联系：

1. **大小和可变性**：
   - 数组的大小在创建时确定，并且无法改变。
   - 集合的大小可以动态增长或缩小，根据需要进行调整。

2. **元素类型**：
   - 数组可以包含任何类型的元素，包括基本数据类型和引用数据类型。
   - 集合通常只能包含对象类型的元素，不能直接包含基本数据类型，但可以使用装箱（boxing）操作将基本数据类型包装成对应的包装类。

3. **泛型支持**：
   - 数组不支持泛型，即无法在声明时指定元素类型。
   - 集合支持泛型，可以在声明集合时指定元素的类型，从而提高类型安全性和代码清晰度。

4. **功能和性能**：
   - 数组的功能相对简单，只提供了基本的元素存储和访问功能。
   - 集合提供了丰富的操作方法，如添加、删除、搜索、排序等，更适合复杂的数据操作需求。但是，与数组相比，集合的性能可能会稍低，因为集合通常会涉及更多的内存分配和管理。

尽管集合在许多情况下更灵活和方便，但数组仍然具有其独特的优势，特别是在需要==高性能和固定大小的情况==下。因此，在选择使用集合还是数组时，需要根据具体的需求和情况来进行权衡。

## 31. 为什么签到用bitmap?bitmap有什么好处?

bitmap -> 位数组优势!

1. 节约内存空间

2. 查询快 -> O(1)