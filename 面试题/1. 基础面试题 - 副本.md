# Java基础面试题

## 1. Java多继承？

> 为什么？菱形继承
>
> 解决：接口；组合类；抽象类；

### 为什么 Java 不支持多继承？

1. **避免复杂性**：多继承会增加语言的复杂性，使得继承关系难以理解和维护。
2. **菱形继承问题**：在多继承中，如果多个父类有相同的方法或属性，子类在调用时可能会产生冲突。
3. **接口的使用**：Java 通过接口（Interface）来实现多继承的功能，接口可以被多个类实现，从而提供类似多继承的效果。

### 如何解决多继承的需求？

1. **使用接口**：
   - 接口是 Java 中实现多继承的主要方式。一个类可以实现多个接口，从而获得多个接口中定义的方法。
   - 接口中可以定义方法和常量，但不包含方法的实现。

2. **组合**：
   - 通过组合（Composition）的方式来实现多继承的效果。即在一个类中包含多个其他类的实例，这样可以通过这些实例调用其他类的方法和属性。

3. **内部类**：
   - 内部类可以访问外部类的私有成员，同时也可以继承其他类。这在一定程度上可以模拟多继承的效果。

4. **抽象类**：
   - 抽象类可以包含抽象方法，这些方法可以被子类实现。通过抽象类，可以在一定程度上模拟多继承的效果。

### 示例代码

#### 使用接口实现多继承

```java
interface A {
    void methodA();
}

interface B {
    void methodB();
}

class C implements A, B {
    public void methodA() {
        System.out.println("Implementing method A");
    }

    public void methodB() {
        System.out.println("Implementing method B");
    }
}

public class Main {
    public static void main(String[] args) {
        C obj = new C();
        obj.methodA();
        obj.methodB();
    }
}
```

#### 使用组合实现多继承

```java
class A {
    void methodA() {
        System.out.println("Method A from class A");
    }
}

class B {
    void methodB() {
        System.out.println("Method B from class B");
    }
}

class C {
    A a = new A();
    B b = new B();

    void methodC() {
        a.methodA();
        b.methodB();
    }
}

public class Main {
    public static void main(String[] args) {
        C obj = new C();
        obj.methodC();
    }
}
```

通过这些方式，Java 可以在不直接支持多继承的情况下，实现类似的功能。



## 2. 面向对象编程？

问面向对象编程？
1. 是什么
2. 核心概念
3. 优点
4. 设计原则

Java是一种面向对象的编程语言，它支持面向对象编程（Object-Oriented Programming，OOP）的核心概念。以下是面向对象编程的一些关键点：

### 核心概念：

1. **类（Class）**：类是对象的蓝图或模板，它定义了对象的属性（数据）和方法（行为）。

2. **对象（Object）**：对象是类的实例，具有类定义的属性和方法。

3. **封装（Encapsulation）**：封装是将数据（属性）和操作数据的方法（行为）捆绑在一起的过程，并隐藏内部细节，只提供必要的接口。

4. **继承（Inheritance）**：继承是一种机制，允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。

5. **多态（Polymorphism）**：多态性允许不同类的对象对同一消息做出响应。这通常通过方法重载（同一个类中同名方法的不同实现）和方法重写（子类覆盖父类的方法）来实现。

6. **抽象（Abstraction）**：抽象是将复杂现实世界简化为基本元素的过程。在编程中，它通常通过创建只包含关键信息的类来实现。

### 优点：

1. **代码重用**：通过继承和多态，可以重用代码，减少重复代码的编写。

2. **易于维护和扩展**：面向对象的设计使得代码更加模块化，易于理解和维护。添加新功能或修改现有功能通常更简单。

3. **提高代码的可读性**：通过封装和命名规范，代码更加清晰，易于理解。

4. **提高代码的灵活性**：多态性使得代码更加灵活，能够适应不同的对象和情况。

5. **模拟现实世界**：面向对象编程允许开发者通过类和对象来模拟现实世界中的实体和它们之间的关系。

### 设计原则：

1. **单一职责原则（Single Responsibility Principle）**：一个类应该只有一个引起它变化的原因。

2. **开闭原则（Open/Closed Principle）**：软件实体应该对扩展开放，对修改关闭。

3. **里氏替换原则（Liskov Substitution Principle）**：子类对象应该能够替换其父类对象被使用。

4. **接口隔离原则（Interface Segregation Principle）**：客户端不应该依赖于它不使用的接口。

5. **依赖倒置原则（Dependency Inversion Principle）**：高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。

6. **合成/聚合复用原则（Composite/Aggregate Reuse Principle）**：尽量使用对象的组合/聚合来实现代码复用，而不是通过继承关系来实现。

这些原则被称为SOLID原则，它们是面向对象设计的核心，帮助开发者创建更加健壮、灵活和可维护的系统。

## 3. 抽象类和接口？

>区别：1、扩展规则 2、访问控制符 3、方法实现 4、使用目的（抽象类是为了代码的复用 接口是为了定义规范）

在面向对象编程中，抽象类和接口都是用来实现抽象化的手段，但它们之间有一些关键的区别：

1. **定义方式**：
   - **抽象类**：在Java中，通过使用`abstract`关键字来定义一个抽象类。抽象类可以包含构造方法、成员变量、方法实现等。
   - **接口**：在Java中，通过使用`interface`关键字来定义一个接口。接口中只能包含常量和抽象方法（Java 8之前），从Java 8开始，接口中可以包含默认方法和静态方法。

2. **多继承**：
   - **抽象类**：Java不支持类的多重继承，即一个类不能继承多个类。但是，一个类可以实现多个接口。
   - **接口**：一个类可以实现多个接口，这允许实现多重继承的特性。

3. **成员变量**：
   - **抽象类**：可以包含实例变量和静态变量，这些变量可以是`public`、`protected`、默认（包）访问权限或`private`。
   - **接口**：在Java 8之前，接口只能包含`public static final`常量。从Java 8开始，接口可以包含`public static`变量和`default`方法。

4. **方法实现**：
   - **抽象类**：可以包含有具体实现的方法（即非抽象方法），也可以包含抽象方法。
   - **接口**：在Java 8之前，接口只能包含抽象方法。从Java 8开始，接口可以包含默认方法（即带有实现的方法）和静态方法。

5. **构造方法**：
   - **抽象类**：可以有构造方法，但是这些构造方法不能被直接调用，只能通过子类调用。
   - **接口**：不能有构造方法。

6. **访问控制**：
   - **抽象类**：可以定义不同访问级别的成员和方法。
   - **接口**：除了可以定义默认方法和静态方法外，接口中的方法默认都是`public`的，不能指定其他访问级别。

7. **使用场景**：
   - **抽象类**：当你想在子类之间共享代码时，可以使用抽象类。抽象类提供了一个通用的模板，子类可以继承并实现抽象类中的方法。
   - **接口**：当你想为不同的类定义一个规范或行为契约时，可以使用接口。接口主要用于定义方法签名，而不关心实现细节。

在设计面向对象的系统时，选择使用抽象类还是接口，取决于你的具体需求。如果你需要共享代码或行为，并且有共同的属性和方法实现，那么抽象类可能是更好的选择。如果你想要定义一个规范，并且希望不同的类以不同的方式实现这个规范，那么接口可能更合适。

## 4. 方法重载与返回值的关系？

>不算的原因：1、JVM的方法签名 2、不知道调用哪个

在Java中，方法重载（Method Overloading）是指在同一个类中存在多个同名方法，但这些方法的参数列表不同。参数列表不同可以是参数的类型不同、参数的数量不同，或者两者都不同。返回值类型不同并不影响方法重载的判断。

**方法重载的规则**【JVM的方法签名规定的】：

1. **方法名相同**：重载的方法必须在同一个类中有相同的方法名。
2. **参数列表不同**：参数的数量、类型或顺序必须至少有一个不同。
3. **返回值类型不影响重载**：即使两个方法的返回值类型不同，如果它们的参数列表相同，它们也不会被认为是重载的方法。
4. **访问修饰符不影响重载**：方法的访问修饰符（如public、protected、private）不影响重载。

**示例**：

```java
public class Example {
    // 重载方法1：无参数
    public void display() {
        System.out.println("Display without parameters");
    }

    // 重载方法2：一个整数参数
    public void display(int i) {
        System.out.println("Display with one integer parameter: " + i);
    }

    // 重载方法3：两个整数参数
    public void display(int i, int j) {
        System.out.println("Display with two integer parameters: " + i + ", " + j);
    }

    // 以下方法不会构成重载，因为参数列表相同
    // public int display(int i) {
    //     System.out.println("Display with one integer parameter and return int");
    //     return i;
    // }
}
```

在上面的示例中，`display` 方法被重载了三次，每次的参数列表都不同。即使最后一个示例中的方法返回了一个整型值，它也不会与前面的无返回值的 `display` 方法构成重载，因为它们的参数列表相同。

总结：返回值类型不同**不算**方法重载。重载的决定因素是方法名和参数列表。

## 5. 方法重载和方法重写？

>区别：1、位置 2、参数要求 3、参数要求 4、使用目的 5、静态绑定和动态绑定

方法重载（Method Overloading）和方法重写（Method Overriding）是面向对象编程中的两个重要概念，它们在Java等语言中有着不同的应用和规则。以下是它们的主要区别：

### 方法重载（Method Overloading）

1. **定义**：方法重载是指在同一个类中，可以有多个同名方法，只要它们的参数列表不同（参数的数量、类型或顺序不同）。返回值类型不同并不影响方法重载。

2. **作用域**：方法重载发生在同一个类中。

3. **目的**：允许开发者编写具有相同名称但执行不同任务的方法，这使得代码更加清晰和易于理解。

4. **编译时决策**：编译器在编译时根据方法的参数列表来决定调用哪个重载的方法。

5. **示例**：
   ```java
   public class Calculator {
       public int add(int a, int b) {
           return a + b;
       }
   
       public double add(double a, double b) {
           return a + b;
       }
   }
   ```

### 方法重写（Method Overriding）

1. **定义**：方法重写是指在子类中重新定义父类的方法。子类的方法应该具有与父类方法相同的方法名、参数列表和返回值类型。

2. **作用域**：方法重写发生在继承关系中，即子类重写父类的方法。

3. **目的**：允许子类改变从父类继承来的方法的行为。

4. **运行时决策**：运行时，根据对象的实际类型来决定调用哪个方法。

5. **要求**：
   - 子类方法的访问修饰符应该与父类方法相同或更宽松。
   - 子类方法不能抛出新的检查异常或比父类方法声明更广泛的异常。

6. **示例**：
   ```java
   class Animal {
       public void makeSound() {
           System.out.println("Some sound");
       }
   }
   
   class Dog extends Animal {
       @Override
       public void makeSound() {
           System.out.println("Bark");
       }
   }
   ```

### 总结

- **方法重载**是同一个类中方法的参数列表不同，用于提供多个具有相同名称但不同行为的方法。
- **方法重写**是子类中重新定义父类的方法，用于改变继承来的方法的行为。

这两个概念在面向对象编程中非常重要，它们提供了代码的灵活性和可扩展性。



在讨论方法重写（Method Overriding）和方法重载（Method Overloading）在性能上的区别之前，需要明确一点：它们主要影响的是代码的可读性、可维护性和设计模式，而不是直接的性能。然而，它们在编译和运行时的行为确实有所不同，这些差异可能会间接影响性能。以下是一些可能的性能考虑：

### 方法重载（Method Overloading）

1. **编译时决策**：方法重载的决策是在编译时进行的。编译器根据方法的签名（方法名和参数列表）来确定调用哪个方法。这意味着重载方法的选择在程序运行之前就已经确定，因此，运行时不需要额外的决策开销。

2. **方法调用**：调用重载方法时，由于编译器已经确定了要调用的方法，所以调用过程是直接的，没有额外的查找或决策过程。

3. **内存使用**：每个重载的方法都需要独立的内存空间来存储其代码。如果一个方法被重载多次，那么每个版本的实现都需要占用额外的内存。

### 方法重写（Method Overriding）

1. **运行时决策**：方法重写的决策是在运行时进行的，这个过程称为动态绑定或晚期绑定。这意味着，即使方法调用在编译时看起来是明确的，实际调用的方法版本是在运行时根据对象的实际类型来确定的。这可能会引入一些额外的开销，尤其是在虚拟机需要查找实际要执行的方法时。

2. **性能开销**：虽然现代虚拟机（如Java虚拟机）已经非常优化了方法调用的过程，但方法重写仍然可能引入微小的性能开销，尤其是在调用非常频繁的情况下。

3. **内存使用**：方法重写通常不会导致额外的内存开销，因为子类和父类共享相同的方法实现，除非子类提供了一个不同的实现。

### 性能影响

- **方法重载**通常对性能的影响较小，因为它在编译时就已经确定了调用哪个方法，没有运行时的决策开销。
- **方法重写**可能会有轻微的性能开销，尤其是在动态绑定过程中，但这种开销通常非常小，对于大多数应用来说可以忽略不计。

总的来说，方法重载和方法重写在性能上的差异通常不是决定性的，它们更多地影响代码的设计和可维护性。在大多数情况下，选择使用重载还是重写应该基于代码清晰度、可读性和设计原则，而不是性能。如果性能成为关注点，通常需要通过更详细的性能分析和优化来解决。



## 6. ==和equals？

>基本数据类型：==的作用是比较值。equals的作用也是比较值（需要重写）

>引用类型：==用于比较引用地址，equals也是用于比较地址，但是常重写用于比较值
## 7. final、finally、finalize?

>final:修饰类、方法、变量
>finally:try-catch中无论是否发生异常都执行，用于释放资源，关闭连接
>finalize：手动释放资源

在Java中，final、finally和finalize是三个不同的概念，它们分别用于不同的场景。

1. final：final是Java中的关键字，用于修饰类、方法和变量。当final修饰一个类时，表示该类不能被继承；当final修饰一个方法时，表示该方法不能被子类重写；当final修饰一个变量时，表示该变量的值不能被修改（对于基本数据类型来说，值不能被修改；对于引用类型来说，引用不能被修改，但对象本身可以被修改）。

2. finally：finally是Java中的关键字，用于定义在try-catch语句块中的一个代码块，无论是否发生异常，finally中的代码都会被执行。通常用于释放资源、关闭连接等操作。

3. finalize：finalize是Object类中的一个方法，用于在对象被垃圾回收前执行一些清理操作。但是，由于finalize方法的执行时机不确定且不可靠，因此不推荐在实际开发中过多依赖finalize方法来释放资源，应该使用try-with-resources或者手动释放资源的方式来确保资源的正确释放。

总结：
- final用于修饰类、方法和变量，表示不可改变或不可继承；
- finally用于try-catch语句块中，无论是否发生异常都会执行；
- finalize是Object类中的方法，用于对象垃圾回收前的清理操作，但不推荐过多依赖。

## 8. String底层？

>final+（char后面是byte）数组

String 底层是基于数组实现的，并且数组使用了 fina 修饰，不同版本中的数组类型也是不同的:·
- JDK9 之前(不含 JDK 9)String 类是使用 char[](字符数组)实现的。·
- JDK9 之后，String 使用的是 byte[](字节数组)实现的。
PS:1个字符(char)=2个字节(byte)。

## 9. String被final修饰？

>1、线程安全 2、键值对的保障 3、效率

在Java中，`String` 类被声明为 `final`，这意味着它不能被继承。`String` 类被设计为 `final` 主要基于以下几个原因：

1. **不可变性（Immutability）**：
   - `String` 对象是不可变的，一旦创建，它们的值就不能被改变。这种不可变性使得 `String` 对象在多线程环境中是安全的，无需额外的同步措施。
   - 不可变性还使得字符串的比较操作更加高效，因为可以直接比较字符串的内容，而不需要考虑对象的可变性。

2. **性能优化**：
   - 由于 `String` 对象是不可变的，它们可以被缓存。Java中的字符串常量池就是一个很好的例子，它存储了所有字符串字面量和字符串常量，这样可以避免重复创建相同的字符串对象，从而节省内存空间和提高性能。

3. **安全性**：
   - `String` 类在Java中被广泛使用，包括在安全敏感的环境中。如果 `String` 类可以被继承，那么继承的类可能会破坏 `String` 的不可变性，引入安全风险。

4. **一致性**：
   - 将 `String` 类声明为 `final` 确保了所有字符串都是通过 `String` 类来处理的，这保证了行为的一致性。

5. **避免不必要的复杂性**：
   - 如果允许继承 `String` 类，那么可能会产生许多不必要的复杂性，因为开发者需要考虑到所有继承类的行为，这可能会引入错误和不一致性。

6. **历史原因**：
   - 在Java的早期版本中，`String` 类就已经被设计为 `final`，并且这种设计一直延续至今。

总的来说，将 `String` 类声明为 `final` 是为了确保其不可变性、提高性能、保证安全性和一致性，以及避免不必要的复杂性。这些设计决策使得 `String` 类在Java中成为了一个非常强大和广泛使用的类。

## 10. String、stringBuilder、stringBuffer?

>String：不可变
>StringBuilder：可变、线程不安全
>StringBuffer：可变、线程安全

在Java中，String、StringBuilder和StringBuffer都用来表示字符串，但它们之间有一些重要的区别：

1. **String**:
   - String是不可变的，一旦创建了String对象，就不能修改它的值。任何对String对象的操作都会创建一个新的String对象。
   - 由于String是不可变的，所以在频繁操作字符串时会产生大量的临时对象，影响性能。
   - String适用于那些不经常改变数值的情况，比如字符串常量、配置信息等。

2. **StringBuilder**:
   - StringBuilder是可变的，可以通过调用其方法来修改字符串的内容，而不会创建新的对象。
   - StringBuilder的性能比String好，特别是在需要频繁修改字符串内容的情况下。
   - StringBuilder不是线程安全的，适用于单线程环境。

3. **StringBuffer**:
   - StringBuffer也是可变的，和StringBuilder类似，但StringBuffer是线程安全的，所有的方法都是同步的。
   - 在多线程环境下，应该使用StringBuffer来操作字符串，以避免线程安全问题。
   - 由于StringBuffer是线程安全的，所以性能比StringBuilder略差。

综上所述，如果在单线程环境下需要频繁修改字符串内容，建议使用StringBuilder；如果在多线程环境下需要频繁修改字符串内容，建议使用StringBuffer。如果字符串内容不需要修改，可以使用String来提高性能。

## 11. 包装类？

>1、oop的要求 2、泛型要求 3、可以提供额外方法 4、null

在Java中，包装类（Wrapper Classes）是指那些用于包装基本数据类型的类。例如，`Integer` 包装类用于包装基本数据类型 `int`，`Double` 用于包装 `double`，以此类推。包装类的存在有多个原因：

1. **对象引用**：
   - 基本数据类型不是对象，它们不能直接作为对象使用。在需要对象引用的场合，如集合框架（如 `ArrayList`、`HashMap` 等），包装类就非常有用。

2. **可变性**：
   - 基本数据类型是不可变的，一旦创建，它们的值就不能改变。而包装类的对象可以被重新赋值，这意味着它们的值可以改变。

3. **与Java API的兼容性**：
   - 许多Java API，如输入/输出流、属性类等，需要对象作为参数，而不是基本数据类型。包装类使得基本数据类型可以被这些API使用。

4. **参与运算**：
   - 基本数据类型不能直接参与某些运算，比如算术运算。包装类提供了方法来执行这些运算。

5. **可比较性**：
   - 包装类的对象可以被比较，例如使用 `equals()` 方法来比较它们的值。基本数据类型不能直接使用 `equals()` 方法进行比较。

6. **可序列化**：
   - 包装类的对象可以实现 `Serializable` 接口，这意味着它们可以被序列化和反序列化，这对于网络传输和持久化存储非常有用。

7. **数值范围**：
   - 包装类提供了一些方法来处理数值范围的问题，比如 `Integer.parseInt()` 可以将字符串解析为 `int` 类型的值。

8. **自动装箱和拆箱**：
   - 自动装箱（Autoboxing）和自动拆箱（Unboxing）是Java 5引入的特性，它们允许自动地在基本数据类型和对应的包装类之间转换，这简化了代码。

9. **泛型**：
   - 泛型只能使用对象类型，不能使用基本数据类型。包装类使得基本数据类型可以被用作泛型参数。

10. **数值缓存**：
    - 对于常用的数值，如 `-128` 到 `127` 之间的整数，Java在包装类中实现了缓存机制，这样可以减少对象的创建，提高性能。

包装类的存在使得基本数据类型可以以对象的形式参与到面向对象编程的各个方面，增加了代码的灵活性和功能性。

## 12. 类型擦除？泛型？

>1、兼容没有泛型时的代码 2、实现简单 3、节约空间

### 类型擦除（Type Erasure）

类型擦除是Java泛型实现的一种机制，它在编译时将泛型类型信息删除，使得泛型信息在运行时不存在。这意味着所有的泛型类型信息仅在编译时起作用，而在运行时，所有的泛型类型都会被替换为它们的边界（如果指定了边界）或者 `Object`。

#### 好处：

1. **兼容性**：类型擦除使得泛型代码可以与没有泛型信息的旧代码兼容。这是因为在运行时，所有的泛型类型都被转换为它们的原始类型或边界。

2. **性能**：由于类型擦除，JVM不需要为每个泛型类型创建新的类。这减少了内存的使用，并提高了性能。

3. **简化实现**：类型擦除简化了JVM的实现，因为它不需要处理泛型类型。所有的泛型类型在运行时都被转换为它们的原始类型。

### 泛型的作用

泛型是Java中一种强大的特性，它允许在编译时提供类型安全检查，同时保持代码的灵活性和可重用性。以下是泛型的主要作用：

1. **类型安全**：泛型提供了编译时类型检查，减少了运行时类型转换的错误。这使得代码更加安全，减少了 `ClassCastException` 的发生。

2. **代码复用**：泛型允许开发者编写可重用的代码。例如，可以编写一个泛型类或方法，它可以处理任何类型的数据，而不需要为每种数据类型编写单独的类或方法。

3. **性能提升**：泛型避免了类型转换的需要，从而提高了代码的性能。在没有泛型之前，通常需要使用 `Object` 类型来编写代码，然后在使用时进行类型转换。

4. **可读性**：泛型提供了更清晰的代码，使得代码的意图更加明显。通过查看泛型类型，开发者可以更容易地理解代码的用途。

5. **协变和逆变**：泛型支持协变和逆变，这允许在子类型关系中更灵活地使用泛型类型。协变允许子类型作为参数传递给接受父类型的泛型方法，而逆变则相反。

6. **限制类型**：泛型允许开发者限制可以使用的类型。例如，可以限制一个泛型类只能接受实现了特定接口的类型。

### 示例

```java
public class Box<T> {
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}

// 使用
Box<Integer> integerBox = new Box<>();
integerBox.set(10);
Integer i = integerBox.get();

Box<String> stringBox = new Box<>();
stringBox.set("Hello, World!");
String s = stringBox.get();
```

在这个例子中，`Box` 类是一个泛型类，它可以存储任何类型的数据。泛型提供了类型安全，同时允许代码的复用。类型擦除确保了在运行时，所有的泛型信息都被删除，从而保持了与旧代码的兼容性和性能。

## 13. Java值传递？

>值传递

在Java中，Java是值传递。在Java中，当你传递一个对象作为参数时，实际上是将对象的引用（地址）传递给了方法，而不是对象本身。因此，虽然看起来似乎是引用传递，但实际上是将引用的值（地址）传递给了方法，所以在方法内部对对象的修改会影响到原对象，但重新赋值不会影响原对象。

## 14. Exception和Error？

>联系：Exception 和 Error 都是继承于 Throwable 的子类
>Exception：==由应用程序引起可处理、可恢复的异常==
>Error : ==JVM 引起，不可恢复的错误==
>区别：异常级别不同、来源不同、代码处理方式不同，以及对程序的影响程度不同等方面。

在Java中，`Exception` 和 `Error` 都是 `Throwable` 类的子类，它们都用于表示程序运行时可能出现的问题。尽管它们有共同的祖先，但它们之间存在一些重要的区别和联系：

### 联系：

1. **继承关系**：`Exception` 和 `Error` 都是 `Throwable` 类的直接子类。这意味着它们共享 `Throwable` 类的一些方法和属性，如 `getMessage()`、`printStackTrace()` 等。

2. **异常处理**：它们都可以被 `try-catch` 语句捕获和处理，这使得程序员可以在程序中添加错误处理逻辑。

### 区别：

1. **严重性**：
   - **Exception**：通常指的是程序可以处理的异常情况。这些异常通常是由于程序逻辑错误或外部因素（如文件未找到、网络问题等）引起的。
   - **Error**：指的是程序无法处理的严重问题，通常是虚拟机内部错误或系统问题，如 `OutOfMemoryError`、`StackOverflowError` 等。这些错误通常表明JVM本身遇到了问题，应用程序无法恢复。

2. **可控性**：
   - **Exception**：通常是可以被程序控制的，开发者可以通过捕获异常并提供相应的处理逻辑来避免程序崩溃。
   - **Error**：通常是不可控制的，应用程序无法通过捕获和处理这些错误来恢复。

3. **检查性**：
   - **Exception**：分为可检查（checked）异常和非检查（unchecked）异常。可检查异常必须在编译时被捕获或声明抛出，而非检查异常（如 `RuntimeException` 及其子类）则不需要。
   - **Error**：不需要也不应该被捕获或声明抛出，因为它们通常是不期望被程序处理的。

4. **使用场景**：
   - **Exception**：用于那些可以通过程序逻辑来预防或恢复的异常情况。
   - **Error**：用于那些通常与系统或虚拟机相关的问题，这些问题通常是不可恢复的。

5. **自定义异常**：
   - **Exception**：开发者可以创建自己的异常类，这些类通常继承自 `Exception` 或其子类。
   - **Error**：通常不鼓励开发者创建自己的错误类，因为错误通常与JVM的状态有关。

### 示例：

```java
try {
    // 可能会抛出异常的代码
    int[] numbers = {1, 2, 3};
    System.out.println(numbers[10]); // 这里会抛出 ArrayIndexOutOfBoundsException
} catch (Exception e) {
    // 处理异常
    e.printStackTrace();
}
```

在这个例子中，`ArrayIndexOutOfBoundsException` 是一个 `RuntimeException` 的子类，它是一个非检查异常。程序可以通过捕获这个异常来避免崩溃。

总的来说，`Exception` 和 `Error` 都是用来表示程序运行时的问题，但它们的严重性、可控性和使用场景有所不同。开发者应该根据具体情况来决定如何处理这些异常和错误。

## 15. 反射？

>- 是什么：反射(Reflection)是指在程序运行时==获取和操作类的一种能力==。通过反射机制，可以在运行时动态地创建对象调用方法、访问和修改属性，以及获取类的信息。
>- 反射的原理：Java类加载：java类加载就是类加载器根据类的全限定名把.==class的二进制字节码代表的静态存储结构转化为方法区的运行时数据结构，然后在内存中生成代表该类的Class对象，一个类有且只有一个Class对象。每次生成Java对象实际上都是通过这个Class对象获取整个类的结构并生成相应的java对象==。(接口和抽象类也会被加载为class对象)==所以如果能够在运行时拿到Class对象，就可以生成java对象并进行调用，这就是java反射的本质。==
>- 为什么需要反射：反射的作用可以用一句话概括：==反射赋予了jvm动态编译的能力。动态编译可以最大限度的体现Java的灵活性（多态）。==【1.有的类不能通过new 2.性能更好 3.通用性框架的需要】
>否则类的元信息只能通过静态编译的形式实现（在编译期确定类型，绑定对象），而不能实现动态编译（在运行期确定类型，绑定对象）。也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译，在Java中就需要反射机制。
>   - 情景一：不得已而为之
>   有的类是我们在编写程序的时候无法使用new一个对象来实例化对象的。例如：
>    ==调用的是来自网络的二进制.class文件，而没有其.java代码==
> 注解 - 注解本身仅仅是起到标记作用，它==需要利用反射机制，根据注解标记去调用注解解释器==，执行行为。如果没有反射机制，注解并不比注释更有用。
>   - 情景二：动态加载（可以最大限度的体现Java的灵活性，并降低类的耦合性：多态）
>==有的类可以在用到时再动态加载到jvm中，这样可以减少jvm的启动时间，同时更重要的是可以动态的加载需要的对象（多态）。例如：==
>==动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了==
>  - 情景三：避免将程序写死到代码里
>因为java代码是先通过编译器将.java文件编译成.class的二进制字节码文件，因此如果我们使用new Person()来实例化对象person会出现的问题就是如果我们希望更换person的实例对象，就要在源代码种更改然后重新编译再运行，但是如果我们将person的实例对象类名等信息编写在配置文件中，利用反射的Class.forName(className)方法来实例化java对象（因为实例化java对象都是根据全限定名查找到jvm内存中的class对象，并根据class对象中的累信息实例化得到java对象，因此xml文件中只要包含了权限定类名就可以通过反射实例化java对象），那么我们就可以更改配置文件，无需重新编译。例如：
>==开发通用框架== - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
>
>- 反射的缺点:反射的缺点
>  - 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。
>  - 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。
>  - 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。



>场景：Spring AOP、Mybatis Plus、Junit

以下是一个简单的 Java 反射使用案例，演示如何通过反射获取类的信息并调用类的方法：

```java
import java.lang.reflect.Method;

public class ReflectionExample {

    public static void main(String[] args) {
        try {
            // 获取要反射的类
            Class<?> myClass = Class.forName("MyClass");

            // 创建类的实例
            Object obj = myClass.getDeclaredConstructor().newInstance();

            // 获取类的方法
            Method myMethod = myClass.getMethod("myMethod");

            // 调用方法
            myMethod.invoke(obj);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static class MyClass {
        public void myMethod() {
            System.out.println("Hello, this is myMethod!");
        }
    }
}
```

在这个例子中，我们首先通过 `Class.forName()` 方法获取了名为 `MyClass` 的类，然后通过反射创建了该类的实例，并获取了名为 `myMethod` 的方法。最后，我们通过 `myMethod.invoke(obj)` 调用了这个方法。

请注意，这只是一个简单的示例，实际应用中可能会涉及更复杂的反射操作和异常处理。希望这个例子能帮助你理解 Java 反射的基本用法！

## 16. 反射执行慢?

>1、因为是动态的，性能消耗大 
>2、安全性检查 
>3、方法调用不是直接调用，而是通过Method的方法调用 
>4、每次调用都需要重新获取Method的方法

在Java中，反射执行比直接调用方法慢的主要原因有以下几点：

1. **动态性能损耗**：反射是一种动态性的机制，它需要在运行时动态地获取类的信息、方法的信息等，这会导致一定的性能损耗。==相比之下，直接调用方法是在编译时确定的，不需要额外的动态性能开销。==

2. **安全性检查**：在使用反射时，Java会进行一些安全性检查，比如检查是否有权限访问私有方法或字段，这些检查也会增加执行的开销。

3. **方法调用开销**：通过反射执行方法时，==需要通过Method对象的invoke()方法来调用目标方法，这个过程会引入额外的方法调用开销。==

4. **缓存未命中**：反射调用的性能还受到缓存未命中的影响。==每次通过反射调用方法时，都需要重新获取Method对象==，如果没有进行适当的缓存处理，会导致性能下降。

因此，虽然反射提供了一种强大的动态性机制，但在性能要求较高的场景下，建议尽量避免过多地使用反射，尤其是在需要频繁调用的地方。如果性能是一个关键问题，最好考虑其他替代方案来实现相同的功能。

## 17. 代理？

>- 什么是代理：代理就是通过代理对象去访问实际的目标对象，比如我们在生活中租房，可以直接找房东，也可以通过某些租房平台去租房，通过租房平台的这种方式就是代理。在java中这种租房平台就被叫做代理类，==代理通常用于控制对对象的访问，以便在访问对象时可以添加额外的功能，例如日志记录、性能监控、安全检查等==。据我所知java中的代理方式有静态代理和动态代理。
>- 静态代理：在静态代理中，代理类在编译时就已经确定，并且为每个被代理的类创建一个代理类。静态代理需要为每个被代理的类编写一个代理类，这样会导致代码冗余和维护困难。
>- 动态代理：动态代理是在运行时动态生成代理类，而不需要手动编写代理类。Java中的动态代理是通过反射机制实现的，可以在运行时为接口创建代理对象，而无需为每个接口编写代理类。动态代理可以更灵活地处理代理逻辑，减少重复代码，提高代码的可维护性。（动态代理有基于接口的jdk实现方式、也有基于类的CGlib实现方式）
>- 使用场景:平常我的业务代码中虽然几乎没有使用过动态代理，但是我工作中使用的Spring系列框架中的AOP，以及RPC框架中都用到了动态代理，以AOP为例，AOP通过动态代理对目标对象进行了增强，比如我们最常用的前置通知、后置通知等。
---
#### 静态代理实现
好的，我可以为您提供一个简单的Java示例来演示静态代理模式。在这个例子中，我们将创建一个房东和中介两个类，房东类负责提供房屋信息，中介类负责帮助租客找到合适的房屋。

首先，让我们创建一个`Landlord`（房东）类：

```java
public interface Rentable {
    void rent();
}

public class Landlord implements Rentable {
    @Override
    public void rent() {
        System.out.println("房东提供房屋信息");
    }
}
```

然后，让我们创建一个`Agent`（中介）类作为静态代理类：

```java
public class Agent implements Rentable {
    private Landlord landlord;

    public Agent(Landlord landlord) {
        this.landlord = landlord;
    }

    @Override
    public void rent() {
        System.out.println("中介帮助租客找到合适的房屋");
        landlord.rent();
    }
}
```

最后，让我们创建一个`Main`类来测试这个例子：

```java
public class Main {
    public static void main(String[] args) {
        Landlord landlord = new Landlord();
        Agent agent = new Agent(landlord);

        agent.rent();
    }
}
```

在这个例子中，`Agent`类是`Rentable`接口的实现类，它持有一个`Landlord`对象的引用，并在`rent()`方法中调用`Landlord`对象的`rent()`方法。通过这种方式，中介类实际上是房东类的代理，它可以在调用房东类方法的前后执行一些额外的逻辑，比如帮助租客找到合适的房屋。

这就是一个简单的用中介租房子的例子，同时也展示了静态代理的基本概念。

---
在Java中，动态代理可以通过两种方式来实现：基于接口的动态代理和基于类的动态代理。
#### jdk基于接口的动态代理
1. 基于接口的动态代理：
基于接口的动态代理是通过Java自带的java.lang.reflect.Proxy类实现的。该类提供了一个静态方法newProxyInstance，可以动态地创建一个实现了指定接口的代理类实例。在这种方式下，代理类需要实现InvocationHandler接口，并重写其invoke方法，该方法在代理对象的方法被调用时会被执行，从而实现对方法的代理。下面是一个简单的示例代码：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Rent {
    void rent();
}

class Landlord implements Rent {
    public void rent() {
        System.out.println("房东出租房子");
    }
}

class DynamicProxy implements InvocationHandler {
    private Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("中介收取中介费");
        Object result = method.invoke(target, args);
        return result;
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        Rent landlord = new Landlord();
        DynamicProxy handler = new DynamicProxy(landlord);
        Rent proxy = (Rent) Proxy.newProxyInstance(landlord.getClass().getClassLoader(), landlord.getClass().getInterfaces(), handler);
        proxy.rent();
    }
}
```
#### CGLIB动态代理
2. 基于类的动态代理：
基于类的动态代理是通过CGLIB库实现的。CGLIB是一个强大的、高性能的代码生成库，它可以在运行时动态生成指定类的子类，并覆盖其中的方法来实现代理。在这种方式下，代理类不需要实现接口，而是直接继承被代理类。下面是一个简单的示例代码：

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

class Landlord {
    public void rent() {
        System.out.println("房东出租房子");
    }
}

class DynamicProxy implements MethodInterceptor {
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("中介收取中介费");
        Object result = proxy.invokeSuper(obj, args);
        return result;
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Landlord.class);
        enhancer.setCallback(new DynamicProxy());
        Landlord proxy = (Landlord) enhancer.create();
        proxy.rent();
    }
}
```

这两种方式各有优劣，基于接口的动态代理要求被代理类必须实现接口，而基于类的动态代理则可以代理没有实现接口的类。在实际应用中，可以根据具体需求选择合适的动态代理实现方式。

## 18. 序列化？

### 什么是序列化和反序列化？

**序列化** 是将对象的状态信息转换为可以存储或传输的形式的过程。在Java中，这通常意味着将对象转换为字节流，以便可以将其写入文件、数据库或通过网络发送到其他Java虚拟机（JVM）。

**反序列化** 是序列化的逆过程，它将流转换回对象。这意味着从文件、数据库或网络接收字节流，并将其重新构建为Java对象。

### 序列化的场景

1. **网络传输**：在分布式系统中，对象序列化常用于在网络上传输对象。例如，当一个Java程序需要将对象发送到远程服务器时，它会先将对象序列化，然后通过网络发送序列化后的数据。

2. **数据存储**：对象序列化可以用于将对象的状态保存到文件系统或数据库中。这允许对象在程序关闭后被持久化，并在需要时重新加载。

3. **远程方法调用（RMI）**：在Java的远程方法调用（RMI）中，对象序列化用于在网络上传递对象作为参数或返回值。

4. **对象持久化**：对象序列化可以用于将对象的状态保存到磁盘上，以便在程序重新启动时恢复对象。

5. **缓存**：序列化可以用于将对象存储在缓存中，以便快速检索。

6. **分布式缓存**：在分布式系统中，对象序列化可以用于在不同的节点之间共享对象。

7. **消息队列**：在使用消息队列（如Apache Kafka、RabbitMQ）时，对象序列化用于将对象转换为消息队列可以处理的格式。

8. **Web服务**：在Web服务中，对象序列化用于将对象转换为可以在网络上传输的格式，如JSON或XML。

### 序列化的优点

- **跨平台**：序列化允许在不同的操作系统和平台之间传输对象。
- **跨语言**：虽然序列化最初是为Java设计的，但许多其他语言也支持序列化，使得跨语言的数据传输成为可能。
- **数据持久化**：序列化提供了一种将对象状态保存到磁盘的方法，这对于数据恢复和备份非常重要。

### 序列化的缺点

- **性能开销**：序列化和反序列化过程可能会消耗大量的CPU资源和时间。
- **安全风险**：序列化数据可能会暴露敏感信息，如果不正确地处理，可能会成为安全漏洞。
- **版本兼容性**：如果对象的类定义在序列化后和反序列化前发生变化，可能会导致兼容性问题。

在设计需要序列化的系统时，应该考虑到这些优点和缺点，并选择合适的序列化机制（如Java自带的序列化机制、JSON、XML等）。

## 19. 克隆？

在Java中，深克隆和浅克隆是针对对象复制时的两种不同方式。浅克隆只会复制对象本身，而不会复制对象内部的引用对象；而深克隆则会递归复制对象内部的引用对象。下面是一个简单的示例代码，演示如何实现深克隆和浅克隆：

```java
import java.util.ArrayList;
import java.util.List;

// 定义一个简单的对象类
class Person implements Cloneable {
    private String name;
    private List<String> hobbies;

    public Person(String name, List<String> hobbies) {
        this.name = name;
        this.hobbies = hobbies;
    }

    // 实现深克隆
    @Override
    public Person clone() {
        try {
            Person cloned = (Person) super.clone();
            cloned.hobbies = new ArrayList<>(this.hobbies);
            return cloned;
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    // 实现浅克隆
    public Person shallowClone() {
        try {
            return (Person) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}

public class CloneExample {
    public static void main(String[] args) {
        List<String> hobbies = new ArrayList<>();
        hobbies.add("Reading");
        hobbies.add("Swimming");

        Person person1 = new Person("Alice", hobbies);

        // 浅克隆
        Person person2 = person1.shallowClone();
        System.out.println("浅克隆：");
        System.out.println("Person 1: " + person1);
        System.out.println("Person 2: " + person2);

        // 深克隆
        Person person3 = person1.clone();
        System.out.println("\n深克隆：");
        System.out.println("Person 1: " + person1);
        System.out.println("Person 3: " + person3);

        // 修改原对象的爱好列表
        person1.hobbies.add("Cycling");

        System.out.println("\n修改原对象后：");
        System.out.println("Person 1: " + person1);
        System.out.println("Person 2: " + person2);
        System.out.println("Person 3: " + person3);
    }
}
```

在上面的示例中，我们定义了一个`Person`类，其中包含一个姓名和一个爱好列表。我们实现了`clone()`方法来实现深克隆，以及`shallowClone()`方法来实现浅克隆。在`main`方法中，我们创建了一个`Person`对象`person1`，然后分别进行了浅克隆和深克隆，最后修改了原对象的爱好列表，展示了不同克隆方式的效果。

## 20. BIO、NIO、AIO有什么区别？ 
先讲讲什么是IO
>I0(Input/0utput)是指输入/输出，用于描述==计算机与外部设备==(如文件、网络、键盘、显示器等)之间的==数据交换过程==。
>计算机在运行过程中，需要与外部世界进行数据的输入和输出。例如，==从文件中读取数据、将数据写入到网络传输中、从键盘接收用户的输入等都属于 I0 操作==。
>需要 IO 的主要原因是:
>1. ==数据持久化==:将数据从内存写入到磁盘或其他存储介质中，实现数据的持久化和长期存储。
>2. ==数据交互==:与外部设备进行数据的输入和输出，在计算机与用户、计算机与计算机之间传输数据
>3. ==程序与外部设备的交互==：程序需要和外部设备(如键盘、鼠标、显示器、网络等)进行交互，接收用户输入展示输出结果。I0 操作是计算机系统中的重要组成部分，它通过数据的输入和输出实现了与外部设备的交互和数据的持久化。在计算机软件开发和系统运行中，I0 是不可或缺的一部分。

BIO、NIO、AIO在Java网络编程中代表了三种不同的I/O模型，它们的主要区别体现在处理I/O操作的方式、效率和适用场景上。以下是对这三种模型的详细区分：

1. **BIO（Blocking I/O，同步阻塞I/O）**
   - **处理方式**：同步并阻塞，服务实现模式为一个连接对应一个线程，即客户端发送一个连接，服务端要有一个线程来处理。
   - **效率**：如果连接多了，线程数量不够，就只能等待，即会发生阻塞。因此，BIO适用于连接数目比较小且固定的架构。
   - **数据处理**：主要以I/O流的形式处理数据，如字节流和字符流操作。
   - **数据传输方向**：是单向的，要么是输入流要么是输出流。

2. **NIO（Non-blocking I/O，同步非阻塞I/O）**
   - **处理方式**：同步非阻塞，服务实现模式是一个线程可以处理多个连接，即客户端发送的连接都会注册到多路复用器上，然后进行轮询连接，有I/O请求就处理。
   - **效率**：NIO模型更加高效，能够处理大量的连接，适用于连接数目多且连接比较短的架构，如聊天服务器、弹幕系统等。
   - **数据处理**：以I/O块（buffer）的形式处理数据，相较于BIO的流处理，块处理效率更高。
   - **数据传输方向**：是双向的，可以从channel往buffer读写数据，同时buffer也可以向channel读写数据。
   - **核心组件**：NIO的三大核心组件是selector（选择器）、channel（通道）和buffer（缓冲区）。

3. **AIO（Asynchronous I/O，异步非阻塞I/O）**
   - **处理方式**：异步非阻塞，引入了异步通道，采用的是proactor模式，特点是有效的请求才启动线程，先有操作系统完成再通知服务端。
   - **效率**：AIO是最高效的I/O模型，适用于连接数目多且连接长的架构，如相册服务器。
   - **数据处理**：基于异步通道和回调函数进行数据处理。

总结来说，BIO、NIO、AIO的主要区别在于它们处理I/O操作的方式不同，从而导致了在效率、编程复杂度和适用场景上的差异。在选择使用哪种I/O模型时，需要根据具体的业务需求和系统环境来权衡。

由于编写完整的BIO（Blocking I/O，阻塞I/O）、AIO（Asynchronous I/O，异步I/O）和NIO（Non-blocking I/O，非阻塞I/O）的Java代码案例可能会很长，并且对于简洁展示其特点而言不是最佳选择。以下我会为你分别提供一个简单的示例来说明它们的核心思想。

下面我将分别为 BIO、NIO 和 AIO 提供一个简单的 Java 使用示例。请注意，这些示例仅用于演示每种 I/O 模型的基本用法，并未涵盖错误处理和优化，这在实际应用中是非常重要的。

### BIO 示例

BIO 是 Java 最早的 I/O 模型，它是阻塞的，即当一个线程执行 I/O 操作时，它会被阻塞直到操作完成。

**BIO 服务器端示例**：

```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class BioServer {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8080)) {
            System.out.println("BIO 服务器启动，等待客户端连接...");

            while (true) {
                try (Socket clientSocket = serverSocket.accept();
                     BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                     PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {
                    
                    System.out.println("客户端连接：" + clientSocket.getInetAddress().getHostAddress());
                    String inputLine;
                    while ((inputLine = in.readLine()) != null) {
                        System.out.println("收到消息：" + inputLine);
                        out.println("服务器响应：" + inputLine);
                    }
                } catch (IOException e) {
                    System.out.println("连接处理错误：" + e.getMessage());
                }
            }
        } catch (IOException e) {
            System.out.println("服务器启动失败：" + e.getMessage());
        }
    }
}
```

**BIO 客户端示例**：

```java
import java.io.*;
import java.net.Socket;

public class BioClient {
    public static void main(String[] args) {
        try (Socket socket = new Socket("localhost", 8080);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
             BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))) {
            
            String userInput;
            while ((userInput = stdIn.readLine()) != null) {
                out.println(userInput);
                System.out.println("服务器响应：" + in.readLine());
            }
        } catch (IOException e) {
            System.out.println("连接服务器失败：" + e.getMessage());
        }
    }
}
```

### NIO 示例

NIO 是 Java 1.4 引入的新 I/O 模型，它支持非阻塞模式，可以使用选择器（Selector）来管理多个通道（Channel）。

**NIO 服务器端示例**：

```java
import java.io.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.StandardCharsets;
import java.util.Iterator;

public class NioServer {
    public static void main(String[] args) {
        try {
            ServerSocketChannel serverChannel = ServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(8080));
            serverChannel.configureBlocking(false);

            Selector selector = Selector.open();
            serverChannel.register(selector, SelectionKey.OP_ACCEPT);

            System.out.println("NIO 服务器启动，等待客户端连接...");

            while (true) {
                selector.select();
                Iterator<SelectionKey> keys = selector.selectedKeys().iterator();

                while (keys.hasNext()) {
                    SelectionKey key = keys.next();
                    keys.remove();

                    if (key.isAcceptable()) {
                        SocketChannel client = serverChannel.accept();
                        client.configureBlocking(false);
                        client.register(selector, SelectionKey.OP_READ);
                        System.out.println("客户端连接：" + client.getRemoteAddress());
                    } else if (key.isReadable()) {
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        int read = client.read(buffer);
                        if (read == -1) {
                            client.close();
                        } else {
                            buffer.flip();
                            String message = new String(buffer.array(), StandardCharsets.UTF_8);
                            System.out.println("收到消息：" + message);
                            client.write(ByteBuffer.wrap(("服务器响应：" + message).getBytes(StandardCharsets.UTF_8)));
                            buffer.clear();
                        }
                    }
                }
            }
        } catch (IOException e) {
            System.out.println("服务器启动失败：" + e.getMessage());
        }
    }
}
```

**NIO 客户端示例**：

```java
import java.io.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.StandardCharsets;

public class NioClient {
    public static void main(String[] args) {
        try {
            SocketChannel socketChannel = SocketChannel.open();
            socketChannel.connect(new InetSocketAddress("localhost", 8080));
            socketChannel.configureBlocking(false);

            ByteBuffer buffer = ByteBuffer.allocate(1024);
            BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));

            String userInput;
            while ((userInput = stdIn.readLine()) != null) {
                buffer.clear();
                buffer.put(userInput.getBytes(StandardCharsets.UTF_8));
                buffer.flip();
                while (buffer.hasRemaining()) {
                    socketChannel.write(buffer);
                }
                buffer.clear();

                buffer = ByteBuffer.allocate(1024);
                int read = socketChannel.read(buffer);
                if (read > 0) {
                    buffer.flip();
                    System.out.println("服务器响应：" + new String(buffer.array(), StandardCharsets.UTF_8));
                    buffer.clear();
                }
            }

            socketChannel.close();
        } catch (IOException e) {
            System.out.println("连接服务器失败：" + e.getMessage());
        }
    }
}
```

### AIO 示例

AIO 是 Java 7 引入的异步 I/O 模型，它允许应用程序发起 I/O 操作后立即返回，当操作完成时通过回调函数来处理结果。

**AIO 服务器端示例**：

```java
import java.io.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;
import java.util.concurrent.*;

public class AioServer {
    public static void main(String[] args) {
        try {
            AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open();
            serverChannel.bind(new InetSocketAddress(8080));
            System.out.println("AIO 服务器启动，等待客户端连接...");

            serverChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() {
                public void completed(AsynchronousSocketChannel client, Void attachment) {
                    System.out.println("客户端连接：" + client.getRemoteAddress());
                    client.read(ByteBuffer.allocate(1024), client, new CompletionHandler<Integer, AsynchronousSocketChannel>() {
                        public void completed(Integer result, AsynchronousSocketChannel attachment) {
                            ByteBuffer buffer = attachment.blockingRead(ByteBuffer.allocate(1024));
                            String message = new String(buffer.array()).trim();
                            System.out.println("收到消息：" + message);
                            attachment.write(ByteBuffer.wrap(("服务器响应：" + message).getBytes()));
                            attachment.read(ByteBuffer.allocate(1024), attachment, this);
                        }

                        public void failed(Throwable exc, AsynchronousSocketChannel attachment) {
                            try {
                                attachment.close();
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    });
                    serverChannel.accept(null, this);
                }

                public void failed(Throwable exc, Void attachment) {
                    exc.printStackTrace();
                }
            });
        } catch (IOException e) {
            System.out.println("服务器启动失败：" + e.getMessage());
        }
    }
}
```

**AIO 客户端示例**：

```java
import java.io.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;
import java.util.concurrent.*;

public class AioClient {
    public static void main(String[] args) {
        try {
            AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open();
            clientChannel.connect(new InetSocketAddress("localhost", 8080), new CompletionHandler<Void, Void>() {
                public void completed(Void result, Void attachment) {
                    System.out.println("连接到服务器成功。");
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));

                    String userInput;
                    while ((userInput = stdIn.readLine()) != null) {
                        buffer.clear();
                        buffer.put(userInput.getBytes());
                        buffer.flip();
                        clientChannel.write(buffer, null, new CompletionHandler<Integer, ByteBuffer>() {
                            public void completed(Integer result, ByteBuffer attachment) {
                                attachment.clear();
                                clientChannel.read(attachment, attachment, new CompletionHandler<Integer, ByteBuffer>() {
                                    public void completed(Integer result, ByteBuffer attachment) {
                                        attachment.flip();
                                        System.out.println("服务器响应：" + new String(attachment.array()).trim());
                                        attachment.clear();
                                    }

                                    public void failed(Throwable exc, ByteBuffer attachment) {
                                        try {
                                            clientChannel.close();
                                        } catch (IOException e) {
                                            e.printStackTrace();
                                        }
                                    }
                                });
                            }

                            public void failed(Throwable exc, ByteBuffer attachment) {
                                try {
                                    clientChannel.close();
                                } catch (IOException e) {
                                    e.printStackTrace();
                                }
                            }
                        });
                    }
                }

                public void failed(Throwable exc, Void attachment) {
                    System.out.println("连接服务器失败：" + exc.getMessage());
                }
            });
        } catch (IOException e) {
            System.out.println("客户端启动失败：" + e.getMessage());
        }
    }
}
```



## 21. java中的异常?

Java 中常见的异常主要分为三类：Checked Exception（受检异常）、Unchecked Exception（非受检异常，也称运行时异常）和 Error。以下是它们的一些常见例子：

1. **Checked Exception（受检异常）**：
   - IOException：读写文件或网络时发生的异常。
   - SQLException：与数据库交互时出现的异常。
   - ClassNotFoundException：尝试加载不存在的类时发生的异常。
   - InterruptedException：线程被中断时发生的异常。
   - FileNotFoundException：尝试打开不存在的文件时发生的异常。

2. **Unchecked Exception（非受检异常，也称运行时异常）**：
   - NullPointerException：当尝试访问 null 对象的成员时发生的异常。
   - ArrayIndexOutOfBoundsException：访问数组时超出了有效范围。
   - ClassCastException：试图将对象强制转换为不兼容的类型时发生的异常。
   - IllegalArgumentException：方法接收到不合法的参数时抛出的异常。
   - IllegalStateException：对象在不合适的状态下调用方法时抛出的异常。

3. **Error**：
   - OutOfMemoryError：内存耗尽时抛出的错误。
   - StackOverflowError：方法调用栈溢出时抛出的错误。
   - VirtualMachineError：虚拟机发生内部错误时抛出的错误。

对于 Checked Exception，Java 强制要求进行异常处理，要么通过 try-catch 块捕获异常，要么通过 throws 关键字声明方法可能抛出的异常；而对于 Unchecked Exception 和 Error，则可以选择处理或者让程序崩溃。

## 22. Java自定义异常？

在Java中，可以通过自定义类来创建受检异常（checked exception）和不受检异常（unchecked exception）。受检异常是指在方法中抛出时必须显式处理的异常，而不受检异常是指在方法中抛出时可以选择性地处理的异常。

要自定义受检异常，需要创建一个继承自Exception类或其子类的异常类。例如：

```java
public class CustomCheckedException extends Exception {
    public CustomCheckedException(String message) {
        super(message);
    }
}
```

要自定义不受检异常，需要创建一个继承自RuntimeException类或其子类的异常类。例如：

```java
public class CustomUncheckedException extends RuntimeException {
    public CustomUncheckedException(String message) {
        super(message);
    }
}
```

在使用自定义异常时，可以在方法中使用throw关键字抛出异常，然后在调用该方法的地方使用try-catch块或throws关键字处理异常。

受检异常的处理方式示例：

```java
public void doSomething() throws CustomCheckedException {
    if (someCondition) {
        throw new CustomCheckedException("Custom checked exception occurred");
    }
}
```

不受检异常的处理方式示例：

```java
public void doSomething() {
    if (someCondition) {
        throw new CustomUncheckedException("Custom unchecked exception occurred");
    }
}
```

需要注意的是，自定义异常类的命名应该清晰明了，以便在代码中容易理解异常的含义和用途。

## 23. catch中如果return了，finally中的代码还会执行吗?

在Java中，如果在try块中的代码中出现了异常，并且该异常被catch块捕获并处理，那么在catch块中的return语句将会被执行。此时，如果还有finally块存在，finally块中的代码也会被执行，然后整个方法的执行流程将继续执行finally块之后的代码。

如果在catch块中的return语句之前有finally块，那么无论是否发生了异常，finally块中的代码都会被执行，然后catch块中的return语句将覆盖之前的返回值。

下面是一个示例代码，说明了try-catch-finally块中return语句的执行顺序：

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(test()); // 输出 2
    }
    
    public static int test() {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            System.out.println("Finally block executed");
        }
    }
}
```

在上面的代码中，try块中的return语句将会被执行，但是finally块中的代码也会在return语句执行之后被执行。所以最终的输出是2，并且会输出"Finally block executed"。

## 24. try-catch-finally结构，finally中的代码什么情况不会执行？

1. 如果在 `try` 或 `catch` 块中调用了 `System.exit()`，JVM 将会停止运行，因此 `finally` 块不会执行。
2. 如果在执行 `try` 或 `catch` 块的过程中，JVM 发生了错误（如硬件故障），导致进程终止，`finally` 块也不会执行。
3. 在极少数情况下，如果 `try` 块中发生了一个严重的错误，如 `StackOverflowError` 或 `OutOfMemoryError`，并且没有足够的资源让JVM继续运行，`finally` 块可能也无法执行。
4. 代码流程并未进入try语句块，那指定不会执行

## 25. 如何让对象支持链式调用?

**Lombok @Accessors 注解方式**
**Lombok @Builder 注解方式**
在Java中，支持链式调用的对象通常通过返回对象本身（即this）来实现。这种方法称为“Fluent Interface”（流畅接口）模式。要实现链式调用，需要按照以下步骤进行操作：

1. 在方法内部进行所需的操作。
2. 在方法的最后返回this（即当前对象的引用）。

下面是一个简单的示例，演示如何在Java中实现链式调用：

```java
public class MyClass {
    private int value;

    public MyClass setValue(int value) {
        this.value = value;
        return this;
    }

    public MyClass add(int num) {
        this.value += num;
        return this;
    }

    public int getValue() {
        return this.value;
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        int result = obj.setValue(5).add(3).getValue(); // 链式调用
        System.out.println("Result: " + result); // 输出: Result: 8
    }
}
```


在上面的示例中，setValue和add方法返回了当前对象的引用（即this），因此可以使用链式调用的方式依次调用这两个方法，并最终获取结果。

## 26. 为什么类一定要实现Serializable才能被序列化?

>  性能开销;安全性

在Java中，要将一个对象序列化，该对象的类必须实现`java.io.Serializable`接口。这不是因为`Serializable`接口本身提供了序列化的方法，而是因为以下几点原因：

1. **标记接口**：
   `Serializable`接口是一个标记接口（Marker Interface），它不包含任何方法。它的主要作用是标记类是可序列化的，即对象的状态可以被保存到一个流中，以便以后可以将其恢复。

2. **序列化兼容性**：
   实现`Serializable`接口是告诉Java序列化机制，该类的实例可以被序列化和反序列化。这允许序列化机制在运行时识别和处理对象的序列化和反序列化。

3. **版本控制**：
   `Serializable`接口定义了`serialVersionUID`字段，这是一个唯一的版本标识符，用于确保序列化的兼容性。如果类的结构发生变化，应该更改这个字段的值，以确保版本一致性。

4. **安全考虑**：
   通过实现`Serializable`接口，类的设计者明确表示允许对象被序列化。这可以防止无意中序列化包含敏感数据的对象。

5. **对象图的遍历**：
   序列化过程中，序列化机制需要遍历对象图以保存对象的状态。实现`Serializable`接口的类可以确保序列化机制能够正确地访问对象的私有字段。

6. **自定义序列化**：
   实现`Serializable`接口的类可以自定义序列化过程，通过实现`writeObject`和`readObject`方法来控制对象的序列化和反序列化行为。

7. **序列化代理**：
   实现了`Serializable`接口的类可以使用序列化代理（Serialization Proxy）机制，这允许类在不更改`serialVersionUID`的情况下进行某些类型的修改。

8. **反序列化**：
   当从流中反序列化对象时，必须确保类是可序列化的，这样反序列化机制才能正确地重建对象。

总之，实现`Serializable`接口是Java序列化机制的一个约定，它确保对象可以安全、一致地被序列化和反序列化。如果不实现这个接口，对象将无法被序列化，尝试序列化未实现`Serializable`接口的对象将抛出`java.io.NotSerializableException`异常。

## 27. 什么是SPI？它有哪些使用场景？

SPI（Service Provider Interface）是一种服务提供者接口，它是一种在Java中用于发现和加载服务提供者的机制。SPI允许将接口和实现分离，使得在运行时可以灵活地替换实现，而不需要修改代码。这种机制在Java服务提供者框架（Java Service Provider Interface，JSP）中得到了广泛应用。

### SPI的工作原理：

1. **服务接口定义**：
   - 定义一个服务接口，该接口规定了服务提供者必须实现的方法。

2. **服务提供者注册**：
   - 在`META-INF/services`目录下创建一个文件，文件名为服务接口的全限定名。文件内容是服务提供者的实现类名，每行一个。

3. **服务加载**：
   - 使用`ServiceLoader`类或者自定义的加载逻辑来加载服务提供者。`ServiceLoader`会读取`META-INF/services`目录下的文件，并加载服务提供者。

### SPI的使用场景：

1. **插件开发**：
   - 开发者可以编写插件并实现一个通用接口，然后在`META-INF/services`中注册，使得插件可以在运行时被发现和加载。

2. **模块化设计**：
   - 在大型应用程序中，可以使用SPI将应用程序分割成多个模块，每个模块实现特定的接口。

3. **框架扩展**：
   - 框架开发者可以定义扩展点，允许第三方开发者实现这些点并提供额外的功能。

4. **依赖注入**：
   - 在依赖注入容器中，SPI可以用于查找和加载特定的实现，例如数据库连接池、日志记录器等。

5. **协议实现**：
   - 在网络编程中，可以使用SPI来动态选择和加载不同的协议实现，例如HTTP、FTP等。

6. **数据源连接**：
   - 在数据库连接池管理中，可以使用SPI来动态加载不同的数据库驱动实现。

7. **文件格式处理**：
   - 在处理不同文件格式时，可以使用SPI来加载和使用不同的解析器和编码器。

8. **国际化和本地化**：
   - 在需要支持多种语言和区域设置的应用程序中，可以使用SPI来加载不同的资源文件。

### 示例：

假设有一个`Payment`接口，不同的支付服务提供者可以实现这个接口：

```java
public interface Payment {
    void pay(String orderId);
}
```

在`META-INF/services`目录下创建一个名为`Payment`的文件，内容为：

```
com.example.paypal.PalPay
com.example.alipay.Alipay
```

然后，可以使用`ServiceLoader`来加载这些服务：

```java
ServiceLoader<Payment> serviceLoader = ServiceLoader.load(Payment.class);
for (Payment payment : serviceLoader) {
    payment.pay("12345");
}
```

这样，`ServiceLoader`会根据`META-INF/services`中的配置自动加载并实例化`PalPay`和`Alipay`的实现。

SPI是一种强大的机制，它提供了一种灵活、可扩展的方式来管理和使用服务提供者。

## 28. 讲讲java序列化的过程？

Java序列化是将对象的状态信息转换为可以存储或传输的形式的过程。在Java中，序列化通常用于将对象写入文件、数据库或通过网络发送到其他JVM。以下是Java序列化的基本过程：

1. **实现Serializable接口**：
   - 要序列化的对象类必须实现`java.io.Serializable`接口。这个接口是一个标记接口，不包含任何方法，它的目的是告诉Java虚拟机这个类的对象可以被序列化。

2. **定义serialVersionUID**：
   - 为了确保序列化的兼容性，通常在类中定义一个`static final`的`serialVersionUID`字段。如果类的结构发生变化，应该更改这个字段的值。

3. **编写序列化方法**：
   - Java提供了默认的序列化机制，你不需要编写任何序列化代码。但是，如果需要自定义序列化过程，可以定义`private void writeObject(ObjectOutputStream oos)`和`private void readObject(ObjectInputStream ois)`方法。

4. **使用ObjectOutputStream进行序列化**：
   - 创建一个`ObjectOutputStream`对象，并使用它的`writeObject(Object obj)`方法将对象写入输出流。这个过程会将对象的状态信息转换为字节序列。

5. **将对象写入文件**：
   - 通常，`ObjectOutputStream`会封装一个`FileOutputStream`，以便将序列化数据写入文件。

6. **反序列化**：
   - 要恢复序列化的对象，可以使用`ObjectInputStream`的`readObject()`方法从输入流中读取字节序列，并将其转换回对象。

7. **处理序列化过程中的异常**：
   - 在序列化和反序列化过程中可能会抛出异常，如`IOException`和`ClassNotFoundException`。应该适当地处理这些异常。

以下是一个简单的序列化和反序列化的示例：

```java
import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        // 序列化对象
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("object.dat"))) {
            MySerializableClass obj = new MySerializableClass("data");
            oos.writeObject(obj);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 反序列化对象
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("object.dat"))) {
            MySerializableClass obj = (MySerializableClass) ois.readObject();
            System.out.println(obj.toString());
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class MySerializableClass implements Serializable {
    private String data;

    public MySerializableClass(String data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "MySerializableClass{" +
                "data='" + data + '\'' +
                '}';
    }
}
```

在这个示例中，`MySerializableClass`实现了`Serializable`接口，并且被序列化到文件`object.dat`中。然后，它被反序列化回一个对象，并打印出来。

请注意，序列化过程是平台依赖的，这意味着在不同的平台上可能需要考虑字节顺序和数据表示的差异。此外，序列化机制并不适用于所有对象，例如，那些包含对数据库连接或打开的文件句柄的引用的对象通常不应该被序列化。



## 29. JVM、JRE和JDK的关系

>JVM
>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。
>JRE
>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。
>JDK
>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等



## 30. java中有哪些访问权限控制符？ 

>所有都可以访问——包外不能访问但子类可以访问——包外也不能访问——包内也不能访问

在Java中，有四种访问权限控制符：public、protected、default（包级别）和private。下面我将为你举例说明每种访问权限控制符的使用范围。

1. **public：可以被任何类访问。**
```java
public class MyClass {
    public int publicVar;
    public void publicMethod() {
        // 可以被任何类访问
    }
}
```

2. **protected：可以被同一包内的类和子类访问。**
```java
public class MyClass {
    protected int protectedVar;
    protected void protectedMethod() {
        // 可以被同一包内的类和子类访问
    }
}
```

3. **default（包级别）：可以被同一包内的类访问。**
```java
class MyClass {
    int defaultVar;
    void defaultMethod() {
        // 可以被同一包内的类访问
    }
}
```

4. **private：只能被本类访问。**
```java
public class MyClass {
    private int privateVar;
    private void privateMethod() {
        // 只能被本类访问
    }
}
```

这些访问权限控制符可以帮助你控制类的成员变量和方法的访问范围，从而实现封装和安全性。

## 31. **八种基本数据类型的大小，以及他们的封装类**

![image-20240909080252433](./1. 基础面试题 - 副本.assets/image-20240909080252433.png)

## 32. instanceof关键字

在 Java 中，`instanceof` 关键字在多态性中发挥作用的方式主要体现在运行时类型识别上。多态性允许我们通过父类型引用来操作子类型对象，这样做的好处是提高了代码的灵活性和可扩展性。然而，在某些情况下，我们可能需要知道对象的实际类型，以便调用特定于该类型的某些方法或属性。这时，`instanceof` 就派上用场了。

以下是 `instanceof` 在多态性中发挥作用的几个场景：

### 1. 安全向下转型

在多态的情况下，我们通常通过父类的引用来调用方法。如果需要调用子类特有的方法，我们可能需要先将父类引用向下转型为子类类型。在使用 `instanceof` 检查之后，我们可以安全地进行向下转型：

```java
public class Main {
    public static void main(String[] args) {
        Object obj = new ArrayList<>();

        if (obj instanceof ArrayList) {
            ArrayList<?> list = (ArrayList<?>) obj;
            // 现在可以调用 ArrayList 的特定方法
            list.add("Element");
        }
    }
}
```

### 2. 区分实现类

当一个接口或抽象类有多个实现时，我们可能需要区分具体是哪个实现类。通过 `instanceof` 我们可以检查对象的实际类型，并根据类型执行不同的逻辑：

```java
public interface Shape {
    void draw();
}

public class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing a circle");
    }
}

public class Square implements Shape {
    public void draw() {
        System.out.println("Drawing a square");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle();

        if (shape instanceof Circle) {
            System.out.println("This is a circle");
        } else if (shape instanceof Square) {
            System.out.println("This is a square");
        }
        shape.draw();
    }
}
```

### 3. 动态行为选择

在某些设计模式中，如访问者模式，我们可能需要根据对象的实际类型来执行不同的操作。`instanceof` 可以帮助我们识别对象类型，并选择相应的行为：

```java
public class Element {
    // ...
}

public class CompositeElement extends Element {
    // ...
}

public class Visitor {
    public void visit(Element element) {
        if (element instanceof CompositeElement) {
            // 处理 CompositeElement
        } else {
            // 处理其他 Element
        }
    }
}
```

### 4. 条件方法调用

有时候，子类可能会重写父类的方法，并且我们可能希望在运行时基于对象的实际类型来调用特定的重写版本：

```java
public class Animal {
    public void makeSound() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    public void makeSound() {
        System.out.println("Bark");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();

        if (myAnimal instanceof Dog) {
            // 虽然 myAnimal 是 Animal 类型的引用，但我们希望调用 Dog 的 makeSound 方法
            ((Dog) myAnimal).makeSound();
        } else {
            myAnimal.makeSound();
        }
    }
}
```

在上述示例中，即使 `myAnimal` 是 `Animal` 类型的引用，我们仍然希望调用 `Dog` 类的 `makeSound` 方法。通过 `instanceof` 检查后，我们可以安全地将 `myAnimal` 向下转型为 `Dog` 类型，并调用 `Dog` 类的 `makeSound` 方法。

总之，`instanceof` 在多态性中的作用是允许我们在运行时识别对象的实际类型，并根据类型执行特定的操作。这为我们编写灵活且可扩展的代码提供了一种机制。

## 33. **Java**创建对象有几种方式？

java中提供了以下四种创建对象的方式:

- new创建新对象
- 通过反射机制
- 采用clone机制
- 通过序列化机制

## 34. a=a+b与a+=b有什么区别吗?

在某些情况下，如使用泛型时，`a = a + b` 可能需要显式类型转换，而 `a += b` 可能不需要，因为编译器可以更直接地推断出结果类型



## 35. Java 中的 I/O 流库



- **字节流**：适用于二进制数据和需要处理原始字节的场景。
- **字符流**：适用于文本数据和需要处理特定字符编码的场景

1. **基本字节流（Basic Byte Streams）**：
   - `InputStream`：所有字节输入流的超类。
     - `FileInputStream`：从文件读取字节数据。
     - `ByteArrayInputStream`：从字节数组读取数据。
   - `OutputStream`：所有字节输出流的超类。
     - `FileOutputStream`：向文件写入字节数据。
     - `ByteArrayOutputStream`：向字节数组写入数据。

2. **基本字符流（Basic Character Streams）**：
   - `Reader`：所有字符输入流的超类。
     - `FileReader`：从文件读取字符数据。
     - `CharArrayReader`：从字符数组读取数据。
     - `StringReader`：从字符串读取数据。
   - `Writer`：所有字符输出流的超类。
     - `FileWriter`：向文件写入字符数据。
     - `CharArrayWriter`：向字符数组写入数据。
     - `StringWriter`：向字符串写入数据。

3. **缓冲字节流（Buffered Byte Streams）**：
   - `BufferedInputStream`：提供缓冲的字节输入流。
   - `BufferedOutputStream`：提供缓冲的字节输出流。
   - `BufferedReader`：提供缓冲的字符输入流。
   - `BufferedWriter`：提供缓冲的字符输出流。

4. **转换流（Transforming Streams）**：
   - `InputStreamReader`：桥梁，将字节流转换为字符流。
   - `OutputStreamWriter`：桥梁，将字符流转换为字节流。

5. **高级字节流（Advanced Byte Streams）**：
   - `DataInputStream`：提供对原始 Java 数据类型的输入操作。
   - `DataOutputStream`：提供对原始 Java 数据类型的输出操作。

6. **对象流（Object Streams）**：
   - `ObjectInputStream`：用于对象的反序列化。
   - `ObjectOutputStream`：用于对象的序列化。

7. **文件流（File Streams）**：
   - 已包含在基本字节流和基本字符流中。

8. **管道流（Pipe Streams）**：
   - `PipedInputStream`：从另一个线程读取字节数据。
   - `PipedOutputStream`：向另一个线程写入字节数据。
   - `PipedReader`：从另一个线程读取字符数据。
   - `PipedWriter`：向另一个线程写入字符数据。

9. **随机访问流（Random Access Streams）**：
   - `RandomAccessFile`：提供对文件的随机访问能力。

10. **打印流（Print Streams）**：
    - `PrintStream`：用于打印数据到输出流。
    - `PrintWriter`：用于打印数据到输出流，支持字符编码。

11. **序列化流（Serialization Streams）**：
    - `ObjectInputStream` 和 `ObjectOutputStream` 也用于对象的序列化和反序列化。

12. **其他特殊流**：
    - `SequenceInputStream`：将多个输入流合并为一个输入流。
    - `FilterInputStream`、`FilterOutputStream`、`FilterReader`、`FilterWriter`：用作其他流的包装器，提供额外的功能。

这些流类提供了丰富的功能，使得 Java I/O 操作变得灵活和强大。开发者可以根据具体的应用场景选择合适的流类来实现数据的输入输出。

## 36. String str = new String("abc")创建了几个对象

在 Java 中，`String` 类是不可变的，这意味着一旦创建了一个 `String` 对象，它的值就不能被改变。当使用 `new` 关键字创建一个 `String` 对象时，如 `String str = new String("abc");`，通常会认为这会创建一个新的对象。然而，由于 `String` 类的特殊性，实际情况可能略有不同。

以下是这行代码可能创建的对象数量和原因：

1. **字符串常量池中的 "abc"**：
   - 如果没有使用 `new` 关键字，即 `String str = "abc";`，Java 编译器和运行时通常会优化字符串字面量，将其存储在字符串常量池中。字符串常量池是 JVM 内部的一个结构，用于存储所有字符串字面量，以避免相同字符串的重复创建。

2. **堆中的新 String 对象**：
   - 当使用 `new` 关键字时，如 `String str = new String("abc");`，Java 会在堆（Heap）上创建一个新的 `String` 对象。这是因为 `new` 操作符明确指示 JVM 在堆上为新对象分配内存。

3. **总结**：
   - 在上述代码中，至少会创建两个对象：字符串常量池中的 `"abc"` 和堆中的新 `String` 对象。
   - 但是，由于字符串池的实现可能因 JVM 而异，并且在不同的 Java 版本中有所变化，所以实际上可能会有更多的对象被创建，或者在某些情况下，JVM 可能会优化掉一些对象的创建。

4. **字符串池的检查**：
   - 在 Java 7 及以后的版本中，字符串常量池被从 `String` 类移动到了 `Heap` 中，以减少 `PermGen`（永久代，Java 8 之前的版本中的一个内存区域）的内存消耗。这意味着字符串常量池中的字符串也是在堆上创建的。

因此，`String str = new String("abc");` 这行代码在 Java 7 及以后的版本中，通常会在堆上创建两个对象：一个在字符串常量池中的 `"abc"`，另一个是使用 `new` 创建的新 `String` 对象。在 Java 8 及以后的版本中，这两个对象都会位于堆上。
