## 1. 什么是设计模式?为什么要用设计模式?

**典型回答**

设计模式是在软件工程中，针对在特定场景下反复出现的、具有普遍性的问题，而总结出的一套最佳实践和可重用解决方案。

**为什么要用设计模式?**

使用设计模式的好处有以下几个:

1. **代码复用**:设计模式为开发人员提供了一种标准的方式来组织代码结构，使得已经验证过的解决方案可以被重复应用于不同的项目和上下文中，减少重复劳动，提高开发效率。
2. **模块化与解耦**:使用设计模式有助于创建更松散耦合的系统，各部分之间通过接口交互而不是具体实现，这样有利于代码维护、扩展和替换组件，降低系统的复杂性和风险。
3. **灵活性与可扩展性**:设计模式考虑到了未来的需求变化，允许在不修改原有代码的基础上，增加新的功能或者应对需求变更，增强了系统的灵活性和可扩展性。
4. **可读性和减少沟通**:由于设计模式是经过广泛认可的标准，因此采用它们的代码更容易被其他熟悉这些模式的开发人员理解和维护，提高了团队间的沟通效率。
5. **提升软件质量**:经过时间考验的设计模式通常能够帮助避免常见的设计缺陷，并提高软件的整体质量和稳定性。
6. **架构一致性**:在大型项目中，遵循一致的设计模式可以帮助保持整个软件体系结构的连贯性和一致性，从而促进整体项目的成功。

## 2. 设计模式中要遵循哪些基本原则?

**典型回答**
设计模式中要遵循的原则有以下几个:

1. **单一职责原则**(Single Responsibility Principle-SRP):一个类应该只有一个引起它变化的原因。换句话说，一个类应该只有一个职责，这有助于类的高内聚性。
2. **开放-封闭原则**(Open-closed Principle-0cP):软件实体(类、模块、函数等)应该是可扩展的，但不可修改的。这意味着在不修改现有代码的情况下，应该能够添加新功能或修改行为。
3. **里氏替换原则**(Liskov Substitution Principle-LSP):子类应该能够替换父类，而不会影响程序的正确性。这保证了继承关系的正确性和稳定性。
4. **依赖倒置原则**(Dependency Inversion Principle-DIP):高层模块不应该依赖于低层模块，二者都应该依赖于抽象的定义。抽象不应该依赖于细节，细节应该依赖于抽象。例如，程序应该依赖抽象类(或接口)而不是具体的实现类。
5. **接口隔离原则**(Interface segregation Principle-ISP):接口应该足够小，以满足客户端的需求。不应L该强迫客户端依赖于它们不使用的接口。
6. **聚合(合成)原则**(Composition/Aggregation Principle-CAP):要优先使用合成/聚合关系(Composition/Aggregation)，而不是继承关系，以实现代码的松耦合。例如能使用 DI(依赖注入)就不要使用继承。
7. **迪米特法则**(Law of Demeter-LoD)一个对象应该对其他对象有最少的了解和依赖，以减少对象之间的耦合，只与最直接相关的类通信。

## 3. 单例模式的实现方式有几种?它有哪些使用场景?

**1.典型回答**
单例模式常见的实现方法有 3 种:饿汉模式、懒汉模式、静态内部类。
**① 饿汉模式**
饿汉模式也叫预加载模式，它是在类加载时直接创建并初始化单例对象，所以它并不存在线程安全的问题。它是依靠 ClassLoader 类机制，在程序启动时只加载一次，因此不存在线程安全问题，它的实现代码如下:

```java
public class singleton {
    // 1.防止外部直接 new 对象破坏单例模式
    private singleton(){}
    // 2.通过私有变量保存单例对象
    private static singleton instance = new singleton();
    //3.提供公共获取单例对象的方法
    public static singleton getInstance(){
        return instance;
    }
}
```

**优点:**实现简单、不存在线程安全问题
**缺点:**类加载时就创建了对象，创建之后如果没被使用，就造成了资源浪费的情况。

**② 懒汉模式**

懒汉模式和饿汉模式正好是相反的，所谓的懒汉模式也就是懒加载(延迟加载)，指的是它只有在第一次被使用时，才会被初始化，它的实现代码如下:

```java
public class singleton {
    //1.防止外部直接 new 对象破坏单例模式
    private singleton(){}
    //2.通过私有变量保存单例对象
    private static volatile singleton instance = null;
    //3.提供公共获取单例对象的方法
    public static singleton getInstance(){
        if(instance == null){ 
            // 第一次效验
            synchronized(singleton.class){
                if(instance == null){
                    // 第二次效验
                    instance = new singleton();
                }
            }
        }
        return instance;
    }
}
```

懒汉模式使用的是双重效验锁和 volatile 来保证线程安全的，从上述代码可以看出，无论是饿汉模式还是懒汉模式，它们的实现步骤都是一样的:

1. 创建一个私有的构造方法，防止其他调用的地方直接 new 对象，这样创建出来的对象就不是单例对象了
2. 创建一个私有变量来保存单例对象
3. 提供一个公共的方法返回单例对象。

懒汉模式相比于饿汉模式来说，不会造成资源的浪费，但写法要复杂一些。

**③ 静态内部类**
静态内部类既能保证线程安全，又能保证懒加载，它只有在被调用时，才会通过 ClassLoader 机制来加载和初始化内部静态类，因此它是线程安全的，此模式的实现代码如下:

```java
public class Singleton {
    private Singleton(){}
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**2.知识扩展**
单例模式的使用场景有哪些?
单例模式的典型使用场景是 **Spring 中 Bean 的实例**，Bean 实例默认使用的就是单例模式,除此之外，**单例模式的使用场景还有数据库连接池、Redis 连接池、线程池等使用场景**。

## 4. 什么是工厂模式?它的使用场景有哪些?

**1.典型回答**
工厂模式是一种创建型设计模式，**它提供了一种封装对象实例化过程的方法**，使客户端无需了解具体的实现细节即可获得所需的对象。通过定义一个用于创建对象的接口(工厂)，让子类决定具体实例化哪一个产品类，从而使得代码在应对变化时更加灵活且易于扩展。

> 通俗地讲，工厂模式的本质就是用工厂方法，代替 new 操作创建一种实例化对象的方式。

**优缺点分析**
工厂模式优点和缺点如下。
**优点分析**

1. **封装对象创建过程**:工厂模式封装了对象的创建过程，客户端代码无需了解具体的对象创建细节，从而降低了耦合性。
2. **可维护性和扩展性**:如果需要添加新类型的对象，只需创建一个新的工厂类，而不需要修改现有的客户端代码，这有助于代码的可维护性和扩展性。
3. **隐藏细节**:工厂模式隐藏了对象创建的细节，客户端代码只需要关心所需对象的接口或抽象类，而不需要关心具体的实现细节。

**缺点分析**

1. **增加类和复杂性**:使用工厂模式会引入额外的工厂类，可能会增加类的数量和复杂性。

2. **抽象性增加**:工厂模式引入了抽象层级，可能会增加代码的抽象性，有时会让代码难以理解。
3. **不适用于简单情况**:对于只有一个具体类的情况，使用工厂模式可能会显得过于繁琐，不适用于简单的对象创建。

**2.知识扩展**
工厂模式的使用场景有哪些?
工厂模式的常见使用场最有两个

1. 线程池中的线程通过线程工厂创建线程。
2. Spring 中的 Bean 通过 FactoryBean 创建 Bean 对象。

## 5. 抽象工厂和工厂模式有什么区别?

抽象工厂(Abstract Factory Pattern)可以看作是对工厂(Factory Pattern)模式的升级。抽象工厂模式在工厂模式上，添加了一个创建不同工厂的抽象接口(抽象类或接口实现)该接口也可以叫作超级工厂

举个例子，以苹果和华为为例。
工厂模式是苹果和华为两家公司前期的状态，那个时候他们只造手机，所以，我们只需要传递不同的公司名字，就能得到一部该公司的手机，这就是工厂模式。

而抽象工厂模式针对的是多个产品维度分类，比如苹果公司既制造手机又制造笔记本电脑，同样，华为公司既制造手机也制造笔记本电脑。

这样，就需要在同一个厂商有多个维度的产品时，如果使用工厂模式，则势必会存在多个独立的工厂，这样的话设计和物理世界是不对应的。正确的做法是通过抽象工厂模式来实现，我们可以将抽象工厂类比成厂商(苹果、华为)，将通过抽象工厂创建出来的工厂类比成不同产品的生产线(手机生产、笔记本电脑生产线)，在需要生产产品时根据抽象工厂生产。

我们定义一个抽象工厂，在抽象工厂中定义好要生产的产品(手机或者电脑)，然后在抽象工厂的实现类中根据不同类型的产品和产品规格生产不同的产品返回给用户。抽象工厂的 UML 图如下:

## 6. 什么是模板方法模式?它的使用场景有哪些?

**1.典型回答**
模板方法模式(Template Method Pattern)定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

> 模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

**优缺点分析**
**优点分析**

1. **代码复用**:它在父类中提取了公共的部分代码。
2. **方便扩展**:它封装了不变部分，扩展可变部分，
3. **符合开闭原则**:模版方法对于修改关闭，对于扩展开放，子类可以通过扩展方式增加相应的功能，符合开闭原则。

**缺点分析**

1. **更加复杂化**:对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
2. **提高了代码阅读的难度**:父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度。

**2.知识扩展**
**模板方法模式的使用场景有哪些?**
模版方法模式的典型使用场景是 **Spring 中 AbstractApplicationContext，它定义了整个 Spring 上下文(ApplicationContext)的创建和管理流程，包括配置读取、Bean 的实例化和依赖注入等过程，以及容器的启动和关闭**。AbstractApplicationContext 中提供了一个模板方法 refresh()，该方法定义了 Spring 上下文的创建和初始化的整体流程，它包含了一系列的具体步骤，如读取配置信息、创建Beanfactory、加载 Bean 的定义、实例化Bean 等。
子类通过继承 AbstractApplicationContext，实现其中的具体步骤，来完成对应的功能。不同的子类可以通过重写模板方法中的具体步骤来定制自己的行为，以适应不同的应用场景。具体的子类，如ClassPathXmlApplicationContext(根据 XML 配置文件初始化 Spring 容器上下文)AnnotationConfigApplicationContext(根据注解初始化 Spring 容器上下文)等，根据不同的配置方式和上下文要求，提供了不同的实现方式。

## 7. 什么是代理模式?它的使用场景有哪些?

代理模式(Proxy Pattern)提供了一个代理对象，用于控制对真实对象的访问。代理对象充当了真实对象的中间人，从而可以在访问真实对象的前后流程中，添加一些额外的逻辑。

代理模式有以下优点和缺点。
优点:

1. **控制访问**:代理模式允许代理对象控制对真实对象的访问。这可以用于实现访问控制、权限验证等
2. **增加附加功能**:代理对象可以在调用真实对象的方法之前或之后执行额外的操作，例如记录日志、性能优化、缓存等。
3. **保护隐私**:代理模式可以用于隐藏真实对象的内部细节，以保护其隐私和安全性。

缺点:

1. **复杂性增加**:引入代理对象可能会增加代码复杂性，因为需要创建和维护额外的类。
2. **性能损失**:代理模式可能引入性能开销，特别是在代理对象需要执行额外操作的情况下。

**代理模式的使用场景有哪些?**
Java 中的 JDK Proxy、Spring 中的 AOP、声明式事务 @Transactional 等，都是通过代理模式实现的。



## 8. 什么是适配器模式?它的使用场景有哪些?

**1.典型回答**

适配器模式(Adapter Pattern)是用于将一个类的接口转换成另一个客户端所期望的接口，从而使原本不兼容的接口能够一起工作。

> 以生活中的例子来说，比如有一个充电器是 USB 接口，而手机充电口却是 Typec 的，这个时候就需要一个把USB 转换成 Typec 的适配器，来进行转换之后才能正常使用。

优缺点分析
**优点:**

1. 可以让两个没有关联的类一起运行，起着中间转换的作用
2. 灵活性好，不会破坏原有的系统。

**缺点:**

1. 过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A接口，内部调用的却是 B接口的实现。



**适配器模式的使用场景有哪些?**
适配器的常见使用场景有以下几个:

1. HandlerAdapter:在 Spring MVC 中，HandlerAdapter 是用于适配处理器(handler)的接口。Spring MVC1.框架根据请求的不同，选择合适的 HandlerAdapter 实现类来适配不同类型的处理器，以使其能够正确地处理请求。例如，RequestMappingHandlerAdapter 用于适配带有 @RequestMapping 注解的方法处理器;而HttpRequestHandlerAdapter 用于适配实现了 HttpRequestHandler 接口的处理器，用于处理来自客户端的HTTP 请求。
2. MessageConverter:在 Spring Web 中，MessageConverter 是用于适配不同格式的消息(message)的接口。通过使用不同的 MessageConverter 实现类，Spring 能够将 HTTP 请求的消息体(body)转换为适合应用程序处理的格式，以及将应用程序生成的响应消息转换为适合发送给客户端的格式。例如，HttpMessageConverter 用于处理与 HTTP 请求和响应相关的消息转换，用于处理各种格式的消息，如 JSON.XML、表单数据等:WebSocketMessageBrokerConfiqurer 用于处理 WebSocket 的传输。

## 9. 什么是装饰模式?它有哪些使用场景?

**1.典型回答**
装饰模式(Decorator Pattern)允许动态地将额外的功能附加到对象上。该模式通过创建一个包装类(装饰器)来包装原始对象，并且在保持接口完整性的同时，增加了对象的功能。这种方式不仅灵活，而且使得对象可以按需动态地具备额外的行为。
装饰模式的核心概念是使用装饰器类，实现了与原始对象相同的接口，但在方法中调用原始对象的对应方法，然后再添加自定义的行为。这样，通过不同的装饰器组合，可以形成一条装饰链，每个装饰器按需增强对象的功能。
**优缺点分析**
**优点:**

1. 装饰模式可以动态地为对象添加行为和功能，而无需修改原始对象的代码。
2. 装饰模式可以避免使用继承来扩展对象的功能，使得代码更加灵活可扩展。
3. 装饰模式符合开闭原则，允许在运行时添加或删除功能。

**缺点:**

1. 过多的装饰器可能会导致类的数量增加，使代码更加复杂
2. 对于多层装饰时，调试和理解代码的难度可能会增加
3. 装饰模式增加了代码的复杂性，可能会给阅读和维护带来困难



**装饰模式的使用场景有哪些?**
装饰模式的使用场景有以下几个:

1. Spring AOP:Spring 中的 AOP 功能实际上使用了装饰模式的思想。通过创建代理对象，可以在不修改原始对1象的情况下，动态地为目标对象增加额外的功能，如事务管理、日志记录等。
2. Filter 过滤器:在 Spring Web 应用中，可以使用 Servlet Filter 对请求进行预处理和后处理。这是典型的装饰模式的应用，因为 Filter 类实现了与原始 Servlet 相同的接口，可以在添加自定义行为的同时调用原始 Servlet的方法。
3. Spring Security:Spring Security 是用于身份验证和授权的库，它使用装饰模式来提供功能强大的安全性。
   Spring Security 使用包装器模式来对原始的 Web 请求进行保护、处理认证和授权等操作。

## 10. 什么是建造者模式?它的使用场景有哪些?

**1.典型回答**
建造者模式(Builder Pattern)是一种创建型设计模式，用于通过一系列的步骤来创建复杂的对象。它将对象的构建过程与其表示相分离，使得同样的构建过程可以创建不同的表示。使用建造者模式，可以更灵活地创建对象，并且可以逐步构建对象的不同属性和部件
**优缺点分析**
**优点:**

1. 将对象的构建过程与表示解耦，使得同样的构建过程可以创建不同的表示。
2. 可以逐步构建对象的属性和部件，使得构建过程更灵活
3. 通过指导者和多个不同的建造者，可以实现复杂对象的组装和构建

**缺点:**

1. 建造者模式增加了代码的复杂性(需要定义多个角色和接口)
2. 如果对象的属性较少，或者建造者的步骤固定，则建造者模式可能会显得冗余和复杂。

建造者模式通常用于创建复杂对象，当一个对象需要多个步骤或参数来构建时，可以使用建造者模式。这种模式可以帮助我们更灵活地构建对象，同时也可以隐藏对象的构建细节。

在Java中，我们可以通过创建一个建造者类来实现建造者模式。下面是一个简单的示例，假设我们要构建一个汽车对象，汽车对象有多个属性需要设置：

```java
// 产品类
class Car {
    private String brand;
    private String model;
    private int year;
    
    public Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }
    
    @Override
    public String toString() {
        return "Car{" +
                "brand='" + brand + '\'' +
                ", model='" + model + '\'' +
                ", year=" + year +
                '}';
    }
}

// 建造者类
class CarBuilder {
    private String brand;
    private String model;
    private int year;
    
    public CarBuilder setBrand(String brand) {
        this.brand = brand;
        return this;
    }
    
    public CarBuilder setModel(String model) {
        this.model = model;
        return this;
    }
    
    public CarBuilder setYear(int year) {
        this.year = year;
        return this;
    }
    
    public Car build() {
        return new Car(brand, model, year);
    }
}

// 客户端代码
public class BuilderPatternExample {
    public static void main(String[] args) {
        Car car = new CarBuilder()
                .setBrand("Toyota")
                .setModel("Camry")
                .setYear(2022)
                .build();
        
        System.out.println(car);
    }
}
```

在上面的示例中，CarBuilder类用于构建Car对象，客户端代码可以通过链式调用设置Car对象的属性，最后调用build方法来构建Car对象。这样可以更清晰地设置对象的属性，同时也可以隐藏对象的构建细节。

## 11. JDK中包含了哪些设计模式?举例说明一下

一、单例模式
在 JDK 中，Runtime 类和 Toolkit 类都使用了单例模式，这些类只能有一个实例，并提供了一个全局访问点。

二、工厂模式

在 JDK 中，Calendar 类使用了工厂方法模式，通过 qetInstance()方法创建 Calendar 对象，能够根据特定的条件返回不同的实现类的实例。

三、适配器模式

在 JDK 中，java.util.Arrays.asList(T... a)方法将数组转换为列表，这可以视为适配器模式的应用，因为它让数组表现得像一个实现了 List 接口的对象，具体实现代码如下

四、装饰模式

在 java.io 包中，I/0 流的实现广泛使用了装饰者模式，例如以下这些:

BufferedReader 是对 Reader 的装饰，添加了缓冲功能。
DataInputStream 是对 InputStream 的装饰，用于处理字节流中的基本数据类型。

五、代理模式
JDK 中的动态代理(JDK Proxy)本身就是代理模式，它的使用示例如下

## 12. sping中包含的设计模式

Spring 框架中常用的设计模式有很多种，以下是其中七种常见的设计模式及其举例：

1. **单例模式（Singleton Pattern）**：Spring 中的 Bean 默认是单例的，即容器中的 Bean 只会被创建一次并在整个应用中共享。例如，ApplicationContext 是一个单例 Bean，整个应用只会有一个 ApplicationContext 实例。

2. **工厂模式（Factory Pattern）**：Spring 中的 BeanFactory 和 ApplicationContext 是工厂模式的典型应用，它们负责创建和管理 Bean 实例。

3. **代理模式（Proxy Pattern）**：Spring AOP（面向切面编程）就是基于代理模式实现的，通过代理可以在目标方法执行前后添加额外的逻辑。

4. **观察者模式（Observer Pattern）**：Spring 中的事件监听机制就是观察者模式的应用，通过 ApplicationEvent 和 ApplicationListener 实现事件的发布和订阅。

5. **模板模式（Template Pattern）**：Spring 中的 JdbcTemplate 是模板模式的典型应用，它定义了数据库操作的基本流程，具体的 SQL 语句由子类实现。

6. **装饰者模式（Decorator Pattern）**：Spring 中的装饰者模式体现在 AOP 的实现上，通过动态代理和切面可以在不修改原有代码的情况下增强对象的功能。

7. **策略模式（Strategy Pattern）**：Spring 中的注解驱动开发就是策略模式的应用，通过不同的注解（如 @Component、@Service、@Controller 等）指定不同的策略来实现不同的功能。

这些设计模式在 Spring 框架中发挥着重要作用，帮助开发者编写可维护、可扩展的应用程序。

## 13. Mybatis中包含的设计模式

MyBatis 中包含的设计模式有：

1. **工厂模式（Factory Pattern）**：MyBatis 使用工厂模式来创建 SqlSessionFactory 对象，通过 SqlSessionFactory 创建 SqlSession 对象。

2. **建造者模式（Builder Pattern）**：在 MyBatis 的配置文件中，可以使用建造者模式来构建 Configuration 对象，简化配置的过程。

3. **装饰者模式（Decorator Pattern）**：MyBatis 中的插件机制就是基于装饰者模式实现的，可以在 SQL 执行的各个阶段插入自定义的逻辑。

4. **代理模式（Proxy Pattern）**：MyBatis 中的 Mapper 接口在运行时会被动态代理，实现了接口方法与 SQL 语句的映射。

5. **模板方法模式（Template Method Pattern）**：MyBatis 中的 Executor 接口和 BaseExecutor 类使用了模板方法模式，定义了 SQL 执行的基本流程，具体的实现由子类完成。

6. **观察者模式（Observer Pattern）**：MyBatis 的事件机制使用了观察者模式，可以在 SQL 执行的各个阶段注册监听器，实现自定义的事件处理逻辑。

7. **策略模式（Strategy Pattern）**：MyBatis 中的 StatementHandler 接口使用了策略模式，根据不同的 SQL 类型选择不同的 Statement 处理策略。

这些设计模式的应用使得 MyBatis 在实现数据访问时更加灵活、可扩展和易于维护。