# 重点面试题

## 1. Java 支持多继承吗? 为什么? 如何解决？
>不支持原因：1.菱形继承，无法确认使用哪个类或者属性 2.需要考虑多个父类之间的冲突，复杂性增加 3.增加耦合度，扩展的时候需要考虑多个父类情况
>解决方法：1.多接口 2.组合类 3.组合+接口

1. **Diamond继承问题**：当一个类同时继承自两个==具有相同父类的类时==，如果父类中有相同的方法或属性，编译器无法确定使用哪个父类的方法或属性

2. **复杂性增加**：要考虑多个父类之间的冲突

3. **耦合度增加**：多继承会增加类与类之间的耦合度，使得代码的灵活性降低。如果一个类继承自多个父类，那么这个类与每个父类之间都存在一定的耦合关系，导致代码的扩展和修改变得困难。
## 2. 面向对象编程（答：是什么、核心概念、优点、原则）

问面向对象编程？
1. 是什么
2. 核心概念
3. 优点
4. 设计原则

>什么是：一种==编程范式==，把==数据和操作==组合成==对象来解决问题==
>概念：类、对象、多态、封装、继承
>优点：模块化、扩展性、可重用、可扩展
>原则：单一、开闭、里氏替换、依赖倒置、接口隔离、迪米特

面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它以对象为基础，将数据和操作封装在一起，通过对象之间的交互来实现程序的功能。在Java中，面向对象编程是核心的编程方法之一，它包括以下几个基本概念：

1. **类（Class）**：==类是面向对象编程的基本组成单元==，它==描述了对象的属性和行为==。==类可以看作是对象的模板，用于创建对象实例。==

2. **对象（Object）**：==对象是类的实例==，具有该类所==描述的属性和行为==。在Java中，通过关键字`new`来创建对象实例。

3. **封装（Encapsulation）**：封装是将==数据和操作（方法）封装在类的内部==，外部==只能通过类的公共接口==来访问对象的状态和行为，而==不能直接访问对象的内部实现细节==。

4. **继承（Inheritance）**：继承是一种==机制==，允许一个类（子类）继承==另一个类（父类）的属性和方法==。子类可以==重用父类的代码==，并可以在此基础上添加新的属性和方法。

5. **多态（Polymorphism）**：==多态是指同一个方法调用可以在不同的对象上产生不同的行为==。在Java中，多态可以通过方法重写（Override）和方法重载（Overload）来实现。

通过面向对象编程，可以将复杂的系统分解为多个相互关联的对象，使得代码更加模块化、可维护和可扩展。 Java作为一种面向对象的编程语言，提供了丰富的面向对象编程特性和语法，使得开发者可以更轻松地使用面向对象的思想来设计和实现程序。

---
面向对象编程是一种编程规范(或叫做编程方法或编程思想)，它将问题转换为对象，并通过对象之间的调用来完
成程序开发。面向对象编程的核心组件是”对象”，“对象”是类的实例，每个类中包含了若干个属性和方法。并且面向对象编程有三大特性:封装、继承和多态。
面向对象编程有以下几个优点

1. 可重用性:通过将相似的功能封装为对象，可以提高代码的可重用性，减少代码的兄余。
2. 模块化:通过将问题划分为多个对象，可以将复杂的问题拆分为小的模块，提供了更好的代码组织和维护性。
3. 扩展性:通过继承和多态，可以在已有的代码基础上进行扩展和修改，使得程序更具灵活性和可扩展性。
4. 可维护性:面向对象编程将数据和操作数据的方法封装在一起，提供了更好的代码组织结构和抽象，使得代码更易于理解、调试和修改。

所以，面向对象编程是一种将问题划分为对象，并通过对象之间的消息传递进行交互的编程思想，以提高代码的可重用性、扩展性和维护性。

---
面向对象编程遵循以下原则：

1. **单一职责原则（Single Responsibility Principle）**：一个类应该只有一个引起变化的原因，即一个类应该只有一个责任。

2. **开放-封闭原则（Open-Closed Principle）**：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭，可以通过扩展已有的代码来实现新的功能，而不是修改已有的代码。

3. **里氏替换原则（Liskov Substitution Principle）**：子类对象可以替换父类对象并且程序不会产生错误，即子类应该能够替换父类并且不影响程序的正确性。

4. **接口隔离原则（Interface Segregation Principle）**：一个类对另一个类的依赖应该建立在最小的接口上，一个类不应该依赖它不需要的接口。

5. **依赖倒置原则（Dependency Inversion Principle）**：高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于具体实现细节，具体实现细节应该依赖于抽象。
6. **迪米特法则**：一个对象应该只与其直接合作的对象交互。这个原则关注将对象的依赖关系限制在最小范围

通过遵循这些原则，面向对象编程可以提高代码的可维护性、可扩展性和复用性，使代码更加清晰、灵活和易于理解。
## 3. 抽象类和接口有什么区别？
>区别：1、扩展规则 2、访问控制符 3、方法实现 4、使用目的（抽象类是为了代码的复用 接口是为了定义规范）

**1.典型回答**
接口和抽象类都是用来**定义对象公共行为**的，二者的主要区别有以下几点不同:

1. **类型扩展不同**:抽象类是单继承，而接口是多继承(多实现)。
2. **方法/属性访问控制符不同**:抽象类方法和属性使用访问修饰符无限制，只是抽象类中的抽象方法不能被private 修饰;而接口有限制，
   接口默认的是 public 控制符，不能使用其他修饰符。
3. **方法实现不同**:抽象类中的普通方法必须有实现，抽象方法必须没有实现;而接口中普通方法不能有实现(不考虑 JDK8 中 defualt 默认方法)
4. **使用目的不同**:接口是为了定义规范，而抽象类是为了复用代码。

## 4. 返回值不同算方法重载吗？

>不算的原因：1、JVM的方法签名 2、不知道调用哪个


原因一：JVM 方法签名层面
方法签名由以下两部分组成:
1:方法名称:方法的名称用于标识该方法的功能和用途。
2.参数列表:参数列表指定了方法接收的参数类型和参数顺序，每个参数都包括参数的类型和参数的名称。JM 是通过方法签名来定位到要调用的方法的，而在方法签名中并没有返回值，因此返回值并不能作为方法重载的依据。
原因二：只通过返回值不同就算方法重载的话，编译器是没办法确实到底要调用哪个方法
## 5. 方法重载和方法重写的区别？
>区别：1、位置 2、参数要求 3、参数要求 4、使用目的 5、静态绑定和动态绑定


方法重载(Method Overloading)和方法重写(Method Overriding)是实现多态性的两种方式。
- 方法重载(Method overoading):指的是在同一个类中定义多个方法，它们具有相同的名称，但参数却不同(参数个数、参数类型或参数顺序不同)
- 方法重写(Method overriding):指的是在子类中对父类中已有的方法进行重新定义(方法名、参数列表和返回类型都相同)。重写方法的目的是为了改变或增加父类方法的实现。它们的区别主要体现在以下几点:
1. 定义位置不同:方法重载发生在同一个类中的多个同名方法之间，而方法重写发生在父类和子类之间。
2. 参数要求不同:方法重载要求方法的参数列表不同(参数类型、参数个数、参数顺序至少有一个不同)，方法重写要求方法的参数列表相同。
3. 返回值要求不同:方法重载不考虑返回值类型，只要参数列表不同即可。方法重写要求返回值类型相同或是其子类类型。
4. 业务功能不同:方法重载是为了提供多个相似功能的方法，可以根据参数的不同选择不同的方法进行调用。方法重写是为了子类能够覆盖父类中的方法，实现特定的功能需求。
5. 静态绑定与动态绑定:方法重载是静态绑定的，即在编译时就确定了调用的方法:方法重写是动态绑定的，即在运行时根据对象的实际类型选择调用的方法，

## 6. ==和equals有什么区别？
>基本数据类型：==的作用是比较值。equals的作用也是比较值（需要重写）

>引用类型：==用于比较引用地址，equals也是用于比较地址，但是常重写用于比较值
## 7. final、finally、finalize有什么区别?
>final:修饰类、方法、变量
>finally:try-catch中无论是否发生异常都执行，用于释放资源，关闭连接
>finalize：手动释放资源

在Java中，final、finally和finalize是三个不同的概念，它们分别用于不同的场景。

1. final：final是Java中的关键字，用于修饰类、方法和变量。==当final修饰一个类时，表示该类不能被继承；当final修饰一个方法时，表示该方法不能被子类重写；当final修饰一个变量时，表示该变量的值不能被修改（对于基本数据类型来说，值不能被修改；对于引用类型来说，引用不能被修改，但对象本身可以被修改）。==

2. finally：finally是Java中的关键字，用于定义在try-catch语句块中的一个代码块，无论是否发生异常，finally中的代码都会被执行。==通常用于释放资源、关闭连接等操作。==

3. finalize：finalize是Object类中的一个方法，用于在对象被垃圾回收前执行一些清理操作。但是，由于finalize方法的执行时机不确定且不可靠，因此不推荐在实际开发中过多依赖finalize方法来释放资源，应该使用try-with-resources或者手动释放资源的方式来确保资源的正确释放。

总结：
- final用于修饰类、方法和变量，表示不可改变或不可继承；
- finally用于try-catch语句块中，无论是否发生异常都会执行；
- finalize是Object类中的方法，用于对象垃圾回收前的清理操作，但不推荐过多依赖。
## 8. String底层是如何实现的？
>final+（char后面是byte）数组

String 底层是基于数组实现的，并且数组使用了 fina 修饰，不同版本中的数组类型也是不同的:·
- JDK9 之前(不含 JDK 9)String 类是使用 char[](字符数组)实现的。·
- JDK9 之后，String 使用的是 byte[](字节数组)实现的。
PS:1个字符(char)=2个字节(byte)。

## 9. String为什么被final修饰？✔
>1、线程安全 2、键值对的保障 3、效率

在Java中，String类被设计为不可变类（immutable class），这意味着一旦一个String对象被创建，它的值就不能被修改。为了实现这种不可变性，String类被使用final关键字修饰，这样就不能被继承并修改其行为。

通过将String类设计为不可变类，Java获得了一些重要的优势，例如：
1. 线程安全：由于String对象的值不可变，多个线程可以安全地共享String对象而不必担心数据被修改。
2. 缓存hashcode：由于String对象的值不可变，可以在第一次计算hashcode后缓存起来，提高性能。
3. 安全性：不可变的String对象可以被安全地用作Map中的键，而不必担心键的值被修改。

因此，通过final修饰String类，Java确保了String对象的不可变性，从而提高了程序的性能和安全性。
## 10. String、stringBuilder、stringBuffer有什么区别?
>String：不可变
>StringBuilder：可变、线程不安全
>StringBuffer：可变、线程安全

在Java中，String、StringBuilder和StringBuffer都用来表示字符串，但它们之间有一些重要的区别：

1. **String**:
   - String是不可变的，一旦创建了String对象，就不能修改它的值。任何对String对象的操作都会创建一个新的String对象。
   - 由于String是不可变的，所以在频繁操作字符串时会产生大量的临时对象，影响性能。
   - String适用于那些不经常改变数值的情况，比如字符串常量、配置信息等。

2. **StringBuilder**:
   - StringBuilder是可变的，可以通过调用其方法来修改字符串的内容，而不会创建新的对象。
   - StringBuilder的性能比String好，特别是在需要频繁修改字符串内容的情况下。
   - StringBuilder不是线程安全的，适用于单线程环境。

3. **StringBuffer**:
   - StringBuffer也是可变的，和StringBuilder类似，但StringBuffer是线程安全的，所有的方法都是同步的。
   - 在多线程环境下，应该使用StringBuffer来操作字符串，以避免线程安全问题。
   - 由于StringBuffer是线程安全的，所以性能比StringBuilder略差。

综上所述，如果在单线程环境下需要频繁修改字符串内容，建议使用StringBuilder；如果在多线程环境下需要频繁修改字符串内容，建议使用StringBuffer。如果字符串内容不需要修改，可以使用String来提高性能。
## 11. 为什么要有包装类？
>1、oop的要求 2、泛型要求 3、可以提供额外方法 4、null

1. 面向对象要求:Java 是一门面向对象的编程语言，要求所有的数据都应该是对象。但是，基本数据类型(如1.int、char、double等)并不是对象，它们没有成员方法和其他面向对象的特性。为了满足面向对象编程的要求，Java 引入了包装类，将基本数据类型封装成对象，使得它们也具有面向对象的特性。例如集合的操作只能是对象，而不能为基础数据类型。
2. 提供了更多的功能和方法:包装类提供了一些额外的方法和功能，例如执行数学运算、比较大小、转换数据类型 IntegervalueOf(n)等方法。
3. 泛型要求:泛型(Generics)是 Java 中很重要的特性，它提供了类型安全和代码重用的功能。但是，泛型要求类型参数必须是对象类型，不能是基本数据类型，因此，如果想在泛型中使用基本数据类型，就需要使用对应的包装类。
4. 表示 nu 值:包装类可以表示 nu 值，而基本数据类型不能。这在某些场景下很有用，比如在接口传参中如果使用包装类即使前端不传参也不会报错，而使用基本数据类型，如果前端忘记传参就会报错。

## 12. 泛型的作用是什么？ 什么是类型擦除？有什么好处？

>1、兼容没有泛型时的代码 2、实现简单 3、节约空间

类型擦除(Type Erasure)也叫做泛型檫除，它是指在 Java 中，泛型的参数类型在编译后，被擦除掉的机制。例如编译器会将"new ArrayList<Integer>()“变为“new ArrayList()”，这就是类型檫除。类型檫除的好处是可以直接兼容之前的代码、节约内存空间，以及 JM 层面实现更加简单。

>为什么要有泛型?
>泛型是从 Java 5 (JDK 5)开始引入的。在 Java5 之前的版本中，Java 语言是不支持泛型的，只能使用 Object 类型进行通用编程。这导致了在处理集合等数据结构时，需要进行显式的类型转换，为了解决这个问题，于是在Java5引入了泛型机制，使得在编译时可以进行类型检查，并且可以减少类型转换的代码。
>==引入泛型的目的是为了增强类型安全性和代码的可读性，并减少运行时类型转换的错误。通过使用泛型，可以在编译时捕获类型错误，并提供更好的代码组织和抽象。==



## 13. Java是值传递还是引用传递？
>值传递

在Java中，Java是值传递。在Java中，当你传递一个对象作为参数时，实际上是将对象的引用（地址）传递给了方法，而不是对象本身。因此，虽然看起来似乎是引用传递，但实际上是将引用的值（地址）传递给了方法，所以在方法内部对对象的修改会影响到原对象，但重新赋值不会影响原对象。

## 14. Exception和Error有什么联系和区别？ ★

>联系：Exception 和 Error 都是继承于 Throwable 的子类
>Exception：==由应用程序引起可处理、可恢复的异常==
>Error : ==JVM 引起，不可恢复的错误==
>区别：异常级别不同、来源不同、代码处理方式不同，以及对程序的影响程度不同等方面。

Exception 和 Error 都是**继承于 Throwable 的子类**，Exception 是由**应用程序引起可处理、可恢复的异常**，而Error 是由 **JVM 引起，不可恢复的错误**。
它们的区别主要体现在:**异常级别不同、来源不同、代码处理方式不同，以及对程序的影响程度不同等方面。**

Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出(throw)或者捕获(catch)，它是异常处理机制的基本组成类型。它们的区别主要有以下几点:
1. 级别不同:Exception 是表示可恢复的异常情况，而 Error 表示不可恢复的严重错误.
2. 来源不同:Exception 通常由应用程序代码引起，表示可预料的异常情况，如输入错误、文件不存在等。而Error 通常由 Java 虛拟机,(JVM)引起，表示严重的系统层面的错误(如内存溢出、栈溢出等)，通常无法通过代码来处理。
3. 代码处理不同:Exception 通常需要程序员在代码中明确地捕获并处理，以防止应用程序的崩溃或异常终止。而 Error 通常是无法通过代码处理的，它表示系统出现了严重的问题，无法恢复。
4. 程序影响不同:==Exception 是一种正常的控制流程，可能会影响应用程序的正常执行，但不会导致应用程序终止。而 Error 是一种严重的问题，可能会导致应用程序的崩溃或终止。==

总的来说，Exception 表示可以通过代码处理的可恢复的异常情况，通常由应用程序引起;而 Error 表示不可恢复的严重错误，通常由 Java 虚拟机(JVM)引起，无法通过代码处理。

Exception 又分为可检査(checked)异常和不检查(unchecked)异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
- 可检查(checked)异常:是指在编译时必须显式处理或声明的异常。这些异常是 Exception 类的子类，但不包括 RuntimeException 及其子类。可检査异常例如 Thread.sleep()抛出的 InterruptedException。
- 不检查(unchecked)异常:就是所谓的运行时异常，类似NullPointerException.ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。
## 15. 什么是反射？反射的原理是什么？为什么需要反射？反射的作用有哪些？反射的缺点？★

>- 是什么：反射(Reflection)是指在程序运行时==获取和操作类的一种能力==。通过反射机制，可以在运行时动态地创建对象调用方法、访问和修改属性，以及获取类的信息。
>- 反射的原理：Java类加载：java类加载就是类加载器根据类的全限定名把.==class的二进制字节码代表的静态存储结构转化为方法区的运行时数据结构，然后在内存中生成代表该类的Class对象，一个类有且只有一个Class对象。每次生成Java对象实际上都是通过这个Class对象获取整个类的结构并生成相应的java对象==。(接口和抽象类也会被加载为class对象)==所以如果能够在运行时拿到Class对象，就可以生成java对象并进行调用，这就是java反射的本质。==
>- 为什么需要反射：反射的作用可以用一句话概括：==反射赋予了jvm动态编译的能力。动态编译可以最大限度的体现Java的灵活性（多态）。==【1.有的类不能通过new 2.性能更好 3.通用性框架的需要】
>否则类的元信息只能通过静态编译的形式实现（在编译期确定类型，绑定对象），而不能实现动态编译（在运行期确定类型，绑定对象）。也就是说在编译以后，程序在运行时的行为就是固定的了，如果要在运行时改变程序的行为，就需要动态编译，在Java中就需要反射机制。
>   - 情景一：不得已而为之
>   有的类是我们在编写程序的时候无法使用new一个对象来实例化对象的。例如：
>    ==调用的是来自网络的二进制.class文件，而没有其.java代码==
> 注解 - 注解本身仅仅是起到标记作用，它==需要利用反射机制，根据注解标记去调用注解解释器==，执行行为。如果没有反射机制，注解并不比注释更有用。
>   - 情景二：动态加载（可以最大限度的体现Java的灵活性，并降低类的耦合性：多态）
>==有的类可以在用到时再动态加载到jvm中，这样可以减少jvm的启动时间，同时更重要的是可以动态的加载需要的对象（多态）。例如：==
>==动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了==
>  - 情景三：避免将程序写死到代码里
>因为java代码是先通过编译器将.java文件编译成.class的二进制字节码文件，因此如果我们使用new Person()来实例化对象person会出现的问题就是如果我们希望更换person的实例对象，就要在源代码种更改然后重新编译再运行，但是如果我们将person的实例对象类名等信息编写在配置文件中，利用反射的Class.forName(className)方法来实例化java对象（因为实例化java对象都是根据全限定名查找到jvm内存中的class对象，并根据class对象中的累信息实例化得到java对象，因此xml文件中只要包含了权限定类名就可以通过反射实例化java对象），那么我们就可以更改配置文件，无需重新编译。例如：
>==开发通用框架== - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
>
>- 反射的缺点:反射的缺点
>  - 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。
>  - 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。
>  - 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。



>场景：Spring AOP、Mybatis Plus、Junit

以下是一个简单的 Java 反射使用案例，演示如何通过反射获取类的信息并调用类的方法：

```java
import java.lang.reflect.Method;

public class ReflectionExample {

    public static void main(String[] args) {
        try {
            // 获取要反射的类
            Class<?> myClass = Class.forName("MyClass");

            // 创建类的实例
            Object obj = myClass.getDeclaredConstructor().newInstance();

            // 获取类的方法
            Method myMethod = myClass.getMethod("myMethod");

            // 调用方法
            myMethod.invoke(obj);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static class MyClass {
        public void myMethod() {
            System.out.println("Hello, this is myMethod!");
        }
    }
}
```

在这个例子中，我们首先通过 `Class.forName()` 方法获取了名为 `MyClass` 的类，然后通过反射创建了该类的实例，并获取了名为 `myMethod` 的方法。最后，我们通过 `myMethod.invoke(obj)` 调用了这个方法。

请注意，这只是一个简单的示例，实际应用中可能会涉及更复杂的反射操作和异常处理。希望这个例子能帮助你理解 Java 反射的基本用法！

## 16. 为什么反射执行比较慢? ★
>1、因为是动态的，性能消耗大 
>2、安全性检查 
>3、方法调用不是直接调用，而是通过Method的方法调用 
>4、每次调用都需要重新获取Method的方法

在Java中，反射执行比直接调用方法慢的主要原因有以下几点：

1. **动态性能损耗**：反射是一种动态性的机制，它需要在运行时动态地获取类的信息、方法的信息等，这会导致一定的性能损耗。==相比之下，直接调用方法是在编译时确定的，不需要额外的动态性能开销。==

2. **安全性检查**：在使用反射时，Java会进行一些安全性检查，比如检查是否有权限访问私有方法或字段，这些检查也会增加执行的开销。

3. **方法调用开销**：通过反射执行方法时，==需要通过Method对象的invoke()方法来调用目标方法，这个过程会引入额外的方法调用开销。==

4. **缓存未命中**：反射调用的性能还受到缓存未命中的影响。==每次通过反射调用方法时，都需要重新获取Method对象==，如果没有进行适当的缓存处理，会导致性能下降。

因此，虽然反射提供了一种强大的动态性机制，但在性能要求较高的场景下，建议尽量避免过多地使用反射，尤其是在需要频繁调用的地方。如果性能是一个关键问题，最好考虑其他替代方案来实现相同的功能。
## 17. 什么是代理？什么是动态代理？什么是静态代理？ 使用场景？★
>- 什么是代理：代理就是通过代理对象去访问实际的目标对象，比如我们在生活中租房，可以直接找房东，也可以通过某些租房平台去租房，通过租房平台的这种方式就是代理。在java中这种租房平台就被叫做代理类，==代理通常用于控制对对象的访问，以便在访问对象时可以添加额外的功能，例如日志记录、性能监控、安全检查等==。据我所知java中的代理方式有静态代理和动态代理。
>- 静态代理：在静态代理中，代理类在编译时就已经确定，并且为每个被代理的类创建一个代理类。静态代理需要为每个被代理的类编写一个代理类，这样会导致代码冗余和维护困难。
>- 动态代理：动态代理是在运行时动态生成代理类，而不需要手动编写代理类。Java中的动态代理是通过反射机制实现的，可以在运行时为接口创建代理对象，而无需为每个接口编写代理类。动态代理可以更灵活地处理代理逻辑，减少重复代码，提高代码的可维护性。（动态代理有基于接口的jdk实现方式、也有基于类的CGlib实现方式）
>- 使用场景:平常我的业务代码中虽然几乎没有使用过动态代理，但是我工作中使用的Spring系列框架中的AOP，以及RPC框架中都用到了动态代理，以AOP为例，AOP通过动态代理对目标对象进行了增强，比如我们最常用的前置通知、后置通知等。
---
#### 静态代理实现
好的，我可以为您提供一个简单的Java示例来演示静态代理模式。在这个例子中，我们将创建一个房东和中介两个类，房东类负责提供房屋信息，中介类负责帮助租客找到合适的房屋。

首先，让我们创建一个`Landlord`（房东）类：

```java
public interface Rentable {
    void rent();
}

public class Landlord implements Rentable {
    @Override
    public void rent() {
        System.out.println("房东提供房屋信息");
    }
}
```

然后，让我们创建一个`Agent`（中介）类作为静态代理类：

```java
public class Agent implements Rentable {
    private Landlord landlord;

    public Agent(Landlord landlord) {
        this.landlord = landlord;
    }

    @Override
    public void rent() {
        System.out.println("中介帮助租客找到合适的房屋");
        landlord.rent();
    }
}
```

最后，让我们创建一个`Main`类来测试这个例子：

```java
public class Main {
    public static void main(String[] args) {
        Landlord landlord = new Landlord();
        Agent agent = new Agent(landlord);

        agent.rent();
    }
}
```

在这个例子中，`Agent`类是`Rentable`接口的实现类，它持有一个`Landlord`对象的引用，并在`rent()`方法中调用`Landlord`对象的`rent()`方法。通过这种方式，中介类实际上是房东类的代理，它可以在调用房东类方法的前后执行一些额外的逻辑，比如帮助租客找到合适的房屋。

这就是一个简单的用中介租房子的例子，同时也展示了静态代理的基本概念。

---
在Java中，动态代理可以通过两种方式来实现：基于接口的动态代理和基于类的动态代理。
#### jdk基于接口的动态代理
1. 基于接口的动态代理：
基于接口的动态代理是通过Java自带的java.lang.reflect.Proxy类实现的。该类提供了一个静态方法newProxyInstance，可以动态地创建一个实现了指定接口的代理类实例。在这种方式下，代理类需要实现InvocationHandler接口，并重写其invoke方法，该方法在代理对象的方法被调用时会被执行，从而实现对方法的代理。下面是一个简单的示例代码：

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Rent {
    void rent();
}

class Landlord implements Rent {
    public void rent() {
        System.out.println("房东出租房子");
    }
}

class DynamicProxy implements InvocationHandler {
    private Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("中介收取中介费");
        Object result = method.invoke(target, args);
        return result;
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        Rent landlord = new Landlord();
        DynamicProxy handler = new DynamicProxy(landlord);
        Rent proxy = (Rent) Proxy.newProxyInstance(landlord.getClass().getClassLoader(), landlord.getClass().getInterfaces(), handler);
        proxy.rent();
    }
}
```
#### CGLIB动态代理
2. 基于类的动态代理：
基于类的动态代理是通过CGLIB库实现的。CGLIB是一个强大的、高性能的代码生成库，它可以在运行时动态生成指定类的子类，并覆盖其中的方法来实现代理。在这种方式下，代理类不需要实现接口，而是直接继承被代理类。下面是一个简单的示例代码：

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

class Landlord {
    public void rent() {
        System.out.println("房东出租房子");
    }
}

class DynamicProxy implements MethodInterceptor {
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("中介收取中介费");
        Object result = proxy.invokeSuper(obj, args);
        return result;
    }
}

public class ProxyTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Landlord.class);
        enhancer.setCallback(new DynamicProxy());
        Landlord proxy = (Landlord) enhancer.create();
        proxy.rent();
    }
}
```

这两种方式各有优劣，基于接口的动态代理要求被代理类必须实现接口，而基于类的动态代理则可以代理没有实现接口的类。在实际应用中，可以根据具体需求选择合适的动态代理实现方式。

## 18. 什么是序列化和反序列化？序列化的场景？
- 序列化(Serialization)序列化是将对象转换为可存储或传输的形式的过程(例如:将对象转换为字节流)
- 反序列化(Deserialization)是将序列化后的数据(例如:二进制文件)转换回原始对象的过程。通过反席列化可以从存储介质(如磁盘、数据库)或通过网络传输的数据中恢复出对象的状态和数据。

- 序列化使用的主要场景:
  - 数据持久化:通过序列化，可以将对象保存到磁盘或数据库中，以实现数据的持久化。这样，在程序重新启动后，可以从磁盘或数据库中读取对象，并将其恢复成内存中的对象。
  - 网络传输:通过序列化，可以将对象转换为字节流，便于在网络中进行传输。网络传输需要将对象打包成字节流，然后发送给接收方，接收方再将字节流进行反序列化，恢复成对象。
## 19. 深克隆和浅克隆有什么区别？ ★

在Java中，深克隆和浅克隆是针对对象复制时的两种不同方式。浅克隆只会复制对象本身，而不会复制对象内部的引用对象；而深克隆则会递归复制对象内部的引用对象。下面是一个简单的示例代码，演示如何实现深克隆和浅克隆：

```java
import java.util.ArrayList;
import java.util.List;

// 定义一个简单的对象类
class Person implements Cloneable {
    private String name;
    private List<String> hobbies;

    public Person(String name, List<String> hobbies) {
        this.name = name;
        this.hobbies = hobbies;
    }

    // 实现深克隆
    @Override
    public Person clone() {
        try {
            Person cloned = (Person) super.clone();
            cloned.hobbies = new ArrayList<>(this.hobbies);
            return cloned;
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    // 实现浅克隆
    public Person shallowClone() {
        try {
            return (Person) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", hobbies=" + hobbies +
                '}';
    }
}

public class CloneExample {
    public static void main(String[] args) {
        List<String> hobbies = new ArrayList<>();
        hobbies.add("Reading");
        hobbies.add("Swimming");

        Person person1 = new Person("Alice", hobbies);

        // 浅克隆
        Person person2 = person1.shallowClone();
        System.out.println("浅克隆：");
        System.out.println("Person 1: " + person1);
        System.out.println("Person 2: " + person2);

        // 深克隆
        Person person3 = person1.clone();
        System.out.println("\n深克隆：");
        System.out.println("Person 1: " + person1);
        System.out.println("Person 3: " + person3);

        // 修改原对象的爱好列表
        person1.hobbies.add("Cycling");

        System.out.println("\n修改原对象后：");
        System.out.println("Person 1: " + person1);
        System.out.println("Person 2: " + person2);
        System.out.println("Person 3: " + person3);
    }
}
```

在上面的示例中，我们定义了一个`Person`类，其中包含一个姓名和一个爱好列表。我们实现了`clone()`方法来实现深克隆，以及`shallowClone()`方法来实现浅克隆。在`main`方法中，我们创建了一个`Person`对象`person1`，然后分别进行了浅克隆和深克隆，最后修改了原对象的爱好列表，展示了不同克隆方式的效果。

## 20. BIO、NIO、AIO有什么区别？ ★
先讲讲什么是IO
>I0(Input/0utput)是指输入/输出，用于描述==计算机与外部设备==(如文件、网络、键盘、显示器等)之间的==数据交换过程==。
>计算机在运行过程中，需要与外部世界进行数据的输入和输出。例如，==从文件中读取数据、将数据写入到网络传输中、从键盘接收用户的输入等都属于 I0 操作==。
>需要 IO 的主要原因是:
>1. ==数据持久化==:将数据从内存写入到磁盘或其他存储介质中，实现数据的持久化和长期存储。
>2. ==数据交互==:与外部设备进行数据的输入和输出，在计算机与用户、计算机与计算机之间传输数据
>3. ==程序与外部设备的交互==：程序需要和外部设备(如键盘、鼠标、显示器、网络等)进行交互，接收用户输入展示输出结果。I0 操作是计算机系统中的重要组成部分，它通过数据的输入和输出实现了与外部设备的交互和数据的持久化。在计算机软件开发和系统运行中，I0 是不可或缺的一部分。

BIO、NIO、AIO在Java网络编程中代表了三种不同的I/O模型，它们的主要区别体现在处理I/O操作的方式、效率和适用场景上。以下是对这三种模型的详细区分：

1. **BIO（Blocking I/O，同步阻塞I/O）**
   - **处理方式**：同步并阻塞，服务实现模式为一个连接对应一个线程，即客户端发送一个连接，服务端要有一个线程来处理。
   - **效率**：如果连接多了，线程数量不够，就只能等待，即会发生阻塞。因此，BIO适用于连接数目比较小且固定的架构。
   - **数据处理**：主要以I/O流的形式处理数据，如字节流和字符流操作。
   - **数据传输方向**：是单向的，要么是输入流要么是输出流。

2. **NIO（Non-blocking I/O，同步非阻塞I/O）**
   - **处理方式**：同步非阻塞，服务实现模式是一个线程可以处理多个连接，即客户端发送的连接都会注册到多路复用器上，然后进行轮询连接，有I/O请求就处理。
   - **效率**：NIO模型更加高效，能够处理大量的连接，适用于连接数目多且连接比较短的架构，如聊天服务器、弹幕系统等。
   - **数据处理**：以I/O块（buffer）的形式处理数据，相较于BIO的流处理，块处理效率更高。
   - **数据传输方向**：是双向的，可以从channel往buffer读写数据，同时buffer也可以向channel读写数据。
   - **核心组件**：NIO的三大核心组件是selector（选择器）、channel（通道）和buffer（缓冲区）。

3. **AIO（Asynchronous I/O，异步非阻塞I/O）**
   - **处理方式**：异步非阻塞，引入了异步通道，采用的是proactor模式，特点是有效的请求才启动线程，先有操作系统完成再通知服务端。
   - **效率**：AIO是最高效的I/O模型，适用于连接数目多且连接长的架构，如相册服务器。
   - **数据处理**：基于异步通道和回调函数进行数据处理。

总结来说，BIO、NIO、AIO的主要区别在于它们处理I/O操作的方式不同，从而导致了在效率、编程复杂度和适用场景上的差异。在选择使用哪种I/O模型时，需要根据具体的业务需求和系统环境来权衡。

由于编写完整的BIO（Blocking I/O，阻塞I/O）、AIO（Asynchronous I/O，异步I/O）和NIO（Non-blocking I/O，非阻塞I/O）的Java代码案例可能会很长，并且对于简洁展示其特点而言不是最佳选择。以下我会为你分别提供一个简单的示例来说明它们的核心思想。

BIO（Blocking I/O）

#### BIO使用`ServerSocket`和`Socket`进行简单的阻塞式通信。

```java
// Server
ServerSocket serverSocket = new ServerSocket(8080);
while (true) {
    Socket socket = serverSocket.accept(); // 阻塞等待连接
    // 处理连接...
    socket.close();
}

// Client
Socket socket = new Socket("localhost", 8080);
// 发送和接收数据...
socket.close();
```

 NIO（Non-blocking I/O）

#### NIO使用`Selector`、`ServerSocketChannel`、`SocketChannel`、`ByteBuffer`等进行非阻塞式通信。

```java
// Server
Selector selector = Selector.open();
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.bind(new InetSocketAddress(8080));
serverSocketChannel.configureBlocking(false);
serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    int readyChannels = selector.select(); // 非阻塞等待，或设置超时时间
    if (readyChannels == 0) continue;
    // 处理就绪的通道...
}

// Client（NIO客户端通常与BIO类似，但也可以使用NIO）
```

AIO（Asynchronous I/O）

#### AIO在Java中主要通过`AsynchronousServerSocketChannel`和`AsynchronousSocketChannel`实现。

```java
// Server
AsynchronousServerSocketChannel server = AsynchronousServerSocketChannel.open();
server.bind(new InetSocketAddress(8080));
server.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() {
    @Override
    public void completed(AsynchronousSocketChannel result, Void attachment) {
        // 连接建立后的处理...
    }

    @Override
    public void failed(Throwable exc, Void attachment) {
        // 处理异常...
    }
});

// Client
AsynchronousSocketChannel client = AsynchronousSocketChannel.open();
client.connect(new InetSocketAddress("localhost", 8080), null, new CompletionHandler<Void, Void>() {
    @Override
    public void completed(Void result, Void attachment) {
        // 连接建立后的处理...
    }

    @Override
    public void failed(Throwable exc, Void attachment) {
        // 处理异常...
    }
});
```

请注意，这些示例仅用于说明每种I/O模型的核心概念，并未包含完整的错误处理和数据处理逻辑。在实际应用中，你需要添加更多的代码来处理各种边界情况和数据交换。

此外，AIO在Java中的使用相对较少，因为它在Java 7中引入，并且其API相对于NIO来说更为复杂。在高性能网络应用中，更常见的做法是使用NIO或者更高级的框架（如Netty）来构建非阻塞的服务器和客户端。
# 一般性问题
## 1. 常见的异常有哪些? ★ 
Java 中常见的异常主要分为三类：Checked Exception（受检异常）、Unchecked Exception（非受检异常，也称运行时异常）和 Error。以下是它们的一些常见例子：

1. **Checked Exception（受检异常）**：
   - IOException：读写文件或网络时发生的异常。
   - SQLException：与数据库交互时出现的异常。
   - ClassNotFoundException：尝试加载不存在的类时发生的异常。
   - InterruptedException：线程被中断时发生的异常。
   - FileNotFoundException：尝试打开不存在的文件时发生的异常。

2. **Unchecked Exception（非受检异常，也称运行时异常）**：
   - NullPointerException：当尝试访问 null 对象的成员时发生的异常。
   - ArrayIndexOutOfBoundsException：访问数组时超出了有效范围。
   - ClassCastException：试图将对象强制转换为不兼容的类型时发生的异常。
   - IllegalArgumentException：方法接收到不合法的参数时抛出的异常。
   - IllegalStateException：对象在不合适的状态下调用方法时抛出的异常。

3. **Error**：
   - OutOfMemoryError：内存耗尽时抛出的错误。
   - StackOverflowError：方法调用栈溢出时抛出的错误。
   - VirtualMachineError：虚拟机发生内部错误时抛出的错误。

对于 Checked Exception，Java 强制要求进行异常处理，要么通过 try-catch 块捕获异常，要么通过 throws 关键字声明方法可能抛出的异常；而对于 Unchecked Exception 和 Error，则可以选择处理或者让程序崩溃。
## 2. Java如何自定义受检异常和不受检异常？ ★
在Java中，可以通过自定义类来创建受检异常（checked exception）和不受检异常（unchecked exception）。受检异常是指在方法中抛出时必须显式处理的异常，而不受检异常是指在方法中抛出时可以选择性地处理的异常。

要自定义受检异常，需要创建一个继承自Exception类或其子类的异常类。例如：

```java
public class CustomCheckedException extends Exception {
    public CustomCheckedException(String message) {
        super(message);
    }
}
```

要自定义不受检异常，需要创建一个继承自RuntimeException类或其子类的异常类。例如：

```java
public class CustomUncheckedException extends RuntimeException {
    public CustomUncheckedException(String message) {
        super(message);
    }
}
```

在使用自定义异常时，可以在方法中使用throw关键字抛出异常，然后在调用该方法的地方使用try-catch块或throws关键字处理异常。

受检异常的处理方式示例：

```java
public void doSomething() throws CustomCheckedException {
    if (someCondition) {
        throw new CustomCheckedException("Custom checked exception occurred");
    }
}
```

不受检异常的处理方式示例：

```java
public void doSomething() {
    if (someCondition) {
        throw new CustomUncheckedException("Custom unchecked exception occurred");
    }
}
```

需要注意的是，自定义异常类的命名应该清晰明了，以便在代码中容易理解异常的含义和用途。
## 3. 触发catch中的return，finally代码还会执行吗?
在Java中，如果在try块中的代码中出现了异常，并且该异常被catch块捕获并处理，那么在catch块中的return语句将会被执行。此时，如果还有finally块存在，finally块中的代码也会被执行，然后整个方法的执行流程将继续执行finally块之后的代码。

如果在catch块中的return语句之前有finally块，那么无论是否发生了异常，finally块中的代码都会被执行，然后catch块中的return语句将覆盖之前的返回值。

下面是一个示例代码，说明了try-catch-finally块中return语句的执行顺序：

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(test()); // 输出 2
    }
    
    public static int test() {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            System.out.println("Finally block executed");
        }
    }
}
```

在上面的代码中，try块中的return语句将会被执行，但是finally块中的代码也会在return语句执行之后被执行。所以最终的输出是2，并且会输出"Finally block executed"。
## 4. finally中的代码一定会执行吗？
[转载csdn链接](https://blog.csdn.net/qq_22136439/article/details/123028976)
1. 如果在 `try` 或 `catch` 块中调用了 `System.exit()`，JVM 将会停止运行，因此 `finally` 块不会执行。
2. 如果在执行 `try` 或 `catch` 块的过程中，JVM 发生了错误（如硬件故障），导致进程终止，`finally` 块也不会执行。
3. 在极少数情况下，如果 `try` 块中发生了一个严重的错误，如 `StackOverflowError` 或 `OutOfMemoryError`，并且没有足够的资源让JVM继续运行，`finally` 块可能也无法执行。
4. 代码流程并未进入try语句块，那指定不会执行
## 5. 如何让对象支持链式调用?
Lombok @Accessors 注解方式
Lombok @Builder 注解方式
在Java中，支持链式调用的对象通常通过返回对象本身（即this）来实现。这种方法称为“Fluent Interface”（流畅接口）模式。要实现链式调用，需要按照以下步骤进行操作：

1. 在方法内部进行所需的操作。
2. 在方法的最后返回this（即当前对象的引用）。

下面是一个简单的示例，演示如何在Java中实现链式调用：

```java
public class MyClass {
    private int value;

    public MyClass setValue(int value) {
        this.value = value;
        return this;
    }

    public MyClass add(int num) {
        this.value += num;
        return this;
    }

    public int getValue() {
        return this.value;
    }

    public static void main(String[] args) {
        MyClass obj = new MyClass();
        int result = obj.setValue(5).add(3).getValue(); // 链式调用
        System.out.println("Result: " + result); // 输出: Result: 8
    }
}
```


在上面的示例中，setValue和add方法返回了当前对象的引用（即this），因此可以使用链式调用的方式依次调用这两个方法，并最终获取结果。
## 6. 为什么类一定要实现Serializable才能被序列化?
1. 性能开销:序列化和反序列化操作可能涉及复杂的数据处理和字节转换。如果所有类默认都是可序列化的，会导致在创建对象时会增加额外的开销，包括生成和处理不必要的序列化字节流。
2. 安全性:不是所有类的实例都应该被序列化和传输。一些类可能包含敏感信息，如果默认是可序列化的，可能会导致数据泄露的风险。需要开发者明确指定哪些类可以被序列化，以确保安全性。
## 7. 什么是SPI？它有哪些使用场景？
SPI(Service Provider Interface)，是 Java 中一种用于实现框架扩展的机制，Java 内置的一种服务提供发现机制。它==允许框架在运行时动态地发现、加载和实例化服务提供者==，以支持模块化和可插拔的架构设计。在 SPI 机制中，有以下 3 个重要的角色:
1. 服务接口(Service Interface):定义一组接口或抽象类，表示一种服务或功能。
2. 服务提供者接口(Service Provider Interface):是服务接口的具体实现，提供了服务的具体功能。
3. 服务加载器(Service Loader):负责加载并实例化服务提供者，并将其注册到系统中，以供服务接口使用。

使用场景：
 1. 数据库驱动:在 Java 中，数据库驱动就是一个典型的 SPI 使用场景。不同的数据库厂商都提供了自己的数据库驱动实现，这些实现都实现了同一个 JDBC 接口。JM 在运行时可以动态加载适合的数据库驱动，使得开发者可以在不修改代码的情况下切换不同的数据库。
2. 日志框架:日志框架(例如 SLF4J)也使用了 SPI 机制。开发者可以选择不同的日志实现(如 Logback、Log4j 等)并将其注入到日志框架中，从而灵活地切换日志实现。
3. SPI 框架:有很多框架中广泛用到了 SPI 技术，例如 Dubbo(高性能 RPC 框架，Remote Procedure Cal，远程过程调用协议)中，它们允许开发者通过 SPI方式定义和管理应用程序的组件和扩展。

## 讲讲java序列化的过程？ ★
Java序列化是将对象转换为字节流的过程，以便在网络上传输或将对象持久化到磁盘上。序列化的过程如下：

1. 实现Serializable接口：要使一个类可以被序列化，需要让该类实现Serializable接口。这是一个标记接口，没有任何方法需要实现。

2. 创建ObjectOutputStream对象：使用ObjectOutputStream类来将对象序列化为字节流。这个类提供了writeObject()方法来将对象写入输出流。

3. 调用writeObject()方法：将要序列化的对象传递给writeObject()方法，该方法将对象转换为字节流并写入输出流中。

4. 关闭ObjectOutputStream：在序列化完成后，需要关闭ObjectOutputStream以释放资源。

示例代码如下：

```java
import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        // 创建一个对象
        Person person = new Person("Alice", 30);

        try {
            // 创建ObjectOutputStream对象
            FileOutputStream fileOut = new FileOutputStream("person.ser");
            ObjectOutputStream out = new ObjectOutputStream(fileOut);

            // 序列化对象
            out.writeObject(person);

            // 关闭ObjectOutputStream
            out.close();
            fileOut.close();

            System.out.println("对象已序列化到文件 person.ser");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

在上面的示例中，我们创建了一个Person类并实现了Serializable接口，然后将一个Person对象序列化到文件中。




## JVM、JRE和JDK的关系
>JVM
>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。
>JRE
>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。
>JDK
>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等

![在这里插入图片描述](C:\application\gitee\learning-notes\学习笔记\面试题\1.基础面试题.assets\35f3afdc1335234c47d05a4958ea5c91.png)



## java中有哪些访问权限控制符？ ★
>所有都可以访问——包外不能访问但子类可以访问——包外也不能访问——包内也不能访问

在Java中，有四种访问权限控制符：public、protected、default（包级别）和private。下面我将为你举例说明每种访问权限控制符的使用范围。

1. public：可以被任何类访问。
```java
public class MyClass {
    public int publicVar;
    public void publicMethod() {
        // 可以被任何类访问
    }
}
```

2. protected：可以被同一包内的类和子类访问。
```java
public class MyClass {
    protected int protectedVar;
    protected void protectedMethod() {
        // 可以被同一包内的类和子类访问
    }
}
```

3. default（包级别）：可以被同一包内的类访问。
```java
class MyClass {
    int defaultVar;
    void defaultMethod() {
        // 可以被同一包内的类访问
    }
}
```

4. private：只能被本类访问。
```java
public class MyClass {
    private int privateVar;
    private void privateMethod() {
        // 只能被本类访问
    }
}
```

这些访问权限控制符可以帮助你控制类的成员变量和方法的访问范围，从而实现封装和安全性。