# 并发编程面试题

## 1. 线程和进程？

> 是什么、有什么、本质、上下文切换、进程共享堆和方法区，线程共享虚拟机栈、本地方法栈、程序计数器。

## 2. 虚拟线程？

> 1. 内存占用：线程占用内存1mb，虚拟线程几百kb
> 2. 调用和执行：线程调用限制于操作系统。虚拟线程限制于jvm
> 3. **并发处理能力：虚拟线程更优**

## 3. 线程的常用方法？

> 启动（run、start）、中断（join，sleep，wait，notify，yield，interrupt）属性（name，priority，daemon，alive）
>
> 就绪状态、运行状态、阻塞状态、等待状态、限时等待状态、终止状态

## 4. star和run，start重复调用？

> ①性质不同 ②调用后，线程的状态改变不同 ③调用后，具体效果不同

## 5. 线程的生命周期?

> ①start之前是new ②调用start-runnable（可运行状态） ③blocked ④waiting ⑤timed waiting ⑥terminated

## 6. wait 和 sleep?

> ①用途：等待、休眠 ②唤醒方式 ③锁的释放 ④所属类 

## 7. 线程通讯？

> ①共享变量 ②wait、condition、lock ③阻塞队列 ④并发类（CountDownLatch、CyclicBarrier、Semaphore、Exchanger）

## 8. 如何停止线程?

> 1. 标记变量 2.中断机制 3.如果使用`ExecutorService`来管理线程，可以通过`Future`对象来取消任务。
>
>    ```java
>    package org.example;
>             
>    import java.util.concurrent.*;
>             
>    public class ExecutorServiceCancellation {
>        public static void main(String[] args) {
>            // 创建一个可缓存的线程池
>            ExecutorService executorService = Executors.newCachedThreadPool();
>             
>            // 提交一个任务并获取 Future 对象
>            Future<String> future = executorService.submit(() -> {
>                // 模拟一个耗时的任务
>                for (int i = 0; i < 10; i++) {
>                    try {
>                        Thread.sleep(1000);
>                        System.out.println("Task is running: " + i);
>                    } catch (InterruptedException e) {
>                        System.out.println("Task was interrupted.");
>                        return "Task was interrupted before completion.";
>                    }
>                }
>                return "Task completed successfully.";
>            });
>             
>            try {
>                // 等待一段时间后尝试取消任务
>                Thread.sleep(3000);
>                // 尝试取消任务，允许中断正在运行的任务
>                boolean cancelled = future.cancel(true);
>                if (cancelled) {
>                    System.out.println("Task was cancelled successfully.");
>                } else {
>                    System.out.println("Task could not be cancelled.");
>                }
>            } catch (InterruptedException e) {
>                e.printStackTrace();
>            }
>             
>            // 关闭线程池
>            executorService.shutdown();
>        }
>    }
>    ```

## 9. 线程池？

> 线程池是一种多线程处理形式，它可以管理和复用线程，避免了频繁创建和销毁线程带来的开销。
>
> 优势：降低资源消耗、提高响应速度、便于线程管理
>
> - **Executor 接口**：
>
>   - 这是 Java 中线程池的核心接口，它定义了一个用于执行任务的方法`execute(Runnable command)`。它提供了一种将任务提交和任务执行解耦的方式。任何实现了`Runnable`接口的类都可以作为任务提交给`Executor`执行。
>
>     ```java
>     Executor executor = anExecutor;
>     Runnable task = new Runnable() {
>         @Override
>         public void run() {
>             System.out.println("Task is running");
>         }
>     };
>     executor.execute(task);
>     ```
>
>     常见的线程池类型（通过 Executors 工厂类创建）
>
>     - newFixedThreadPool：
>       - 创建一个固定大小的线程池，线程数量固定为指定的值。如果提交的任务数量超过线程数量，任务会在队列中等待。例如，`Executors.newFixedThreadPool(4)`会创建一个有 4 个线程的线程池。所有任务会被分配到这 4 个线程中执行，线程数量不会随着任务数量的变化而变化。
>     - newCachedThreadPool：
>       - 创建一个可缓存的线程池。如果线程池中有空闲线程，会复用空闲线程；如果没有空闲线程，会创建新线程。如果线程空闲了一段时间（默认 60 秒），会被回收。例如，在一个有突发任务的场景中，当有大量任务到来时，会快速创建新线程来处理任务，任务完成后，空闲线程会被回收，节省资源。
>     - newSingleThreadExecutor：
>       - 创建一个只有一个线程的线程池。所有任务按照提交的顺序在这个线程中执行，保证了任务执行的顺序性。比如在一些对任务执行顺序有严格要求的场景，如日志记录等，使用这个线程池可以确保日志按照顺序写入。
>     - newScheduledThreadPool：
>       - 用于定时执行任务或周期性执行任务。例如，可以设置一个任务在 10 秒后执行，或者每隔 5 秒执行一次任务。它内部使用`DelayedWorkQueue`来存放任务。比如在一个定时备份数据的系统中，可以使用这个线程池来定期执行备份任务。
>
> - **ExecutorService 接口**：
>
>   - 它是`Executor`接口的扩展，提供了更多的功能，如管理任务的生命周期、关闭线程池等。
>
>     ```java
>     ExecutorService executorService = Executors.newFixedThreadPool(5);
>     Future<?> future = executorService.submit(new Runnable() {
>         @Override
>         public void run() {
>             System.out.println("Task submitted to executor service");
>         }
>     });
>     executorService.shutdown();
>     ```
>
> - **ThreadPoolExecutor 类**
>
>   - 参数：1.核心线程数 2.最大线程数 3.存活时间 4.时间单位 5.任务队列 6.线程工程 7.拒绝策略
>
>     ```java
>     BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
>     ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
>             3, // corePoolSize
>             5, // maximumPoolSize
>             60L, // keepAliveTime
>             TimeUnit.SECONDS, // unit
>             workQueue,
>             Executors.defaultThreadFactory(),
>             new ThreadPoolExecutor.AbortPolicy()
>     );
>     ```

## 10. 线程池选择合适的线程数量和拒绝策略？

> - 线程数量：
>   - CPU密集型任务：线程数量应该等于 CPU 核心数
>   - IO密集型任务：一个常见的经验公式是线程数 = CPU 核心数 ×(1 + 平均等待时间 / 平均计算时间)
> - 拒绝策略
>   - **AbortPolicy**默认：当线程池和任务队列都满了，新任务提交时，会直接抛出`RejectedExecutionException`异常。
>     - **适用场景**：这种策略比较适合对任务提交的可靠性要求较高的场景。例如，在一个订单处理系统中，如果线程池无法处理新的订单任务，抛出异常可以让上层系统及时捕获并采取相应的补救措施，如提示用户稍后再试或者将订单信息存储起来等待后续处理。
>   - **CallerRunsPolicy**:当线程池和任务队列都满了，新任务会在提交任务的线程中直接执行。这样做的好处是可以降低新任务被拒绝的概率，但是会增加提交任务线程的负担。
>     - **适用场景**：适用于不希望任务被直接拒绝，并且提交任务的线程有能力执行任务的情况。比如在一个简单的工具类应用中，任务相对较轻，即使在主线程中执行这些额外的任务也不会对整体性能产生太大影响。
>   - **DiscardPolicy**:当线程池和任务队列都满了，新任务会被直接丢弃，不会抛出异常，也不会执行。
>     - **适用场景**：适用于对任务丢失不太敏感的场景。例如，在一个日志收集系统中，如果日志收集任务过多，丢弃一些不太重要的日志任务不会对系统的核心功能产生太大影响，因为日志主要是用于辅助分析，丢失部分日志可以接受。
>   - **DiscardOldestPolicy**:当线程池和任务队列都满了，会丢弃任务队列中最旧的任务，然后将新任务添加到队列中。
>     - **适用场景**：适用于任务有一定时效性，并且新任务比旧任务更重要的场景。例如，在一个实时数据处理系统中，新的数据可能比旧的数据更有价值，当线程池无法处理所有任务时，丢弃最旧的数据任务来为新任务腾出空间。

## 11. 线程池的创建方式有哪些?

> - **Executor 接口**：
>
>   - 这是 Java 中线程池的核心接口，它定义了一个用于执行任务的方法`execute(Runnable command)`。它提供了一种将任务提交和任务执行解耦的方式。任何实现了`Runnable`接口的类都可以作为任务提交给`Executor`执行。
>
>     ```java
>     Executor executor = anExecutor;
>     Runnable task = new Runnable() {
>         @Override
>         public void run() {
>             System.out.println("Task is running");
>         }
>     };
>     executor.execute(task);
>     ```
>
>     常见的线程池类型（通过 Executors 工厂类创建）
>
>     - newFixedThreadPool：
>       - 创建一个固定大小的线程池，线程数量固定为指定的值。如果提交的任务数量超过线程数量，任务会在队列中等待。例如，`Executors.newFixedThreadPool(4)`会创建一个有 4 个线程的线程池。所有任务会被分配到这 4 个线程中执行，线程数量不会随着任务数量的变化而变化。
>     - newCachedThreadPool：
>       - 创建一个可缓存的线程池。如果线程池中有空闲线程，会复用空闲线程；如果没有空闲线程，会创建新线程。如果线程空闲了一段时间（默认 60 秒），会被回收。例如，在一个有突发任务的场景中，当有大量任务到来时，会快速创建新线程来处理任务，任务完成后，空闲线程会被回收，节省资源。
>     - newSingleThreadExecutor：
>       - 创建一个只有一个线程的线程池。所有任务按照提交的顺序在这个线程中执行，保证了任务执行的顺序性。比如在一些对任务执行顺序有严格要求的场景，如日志记录等，使用这个线程池可以确保日志按照顺序写入。
>     - newScheduledThreadPool：
>       - 用于定时执行任务或周期性执行任务。例如，可以设置一个任务在 10 秒后执行，或者每隔 5 秒执行一次任务。它内部使用`DelayedWorkQueue`来存放任务。比如在一个定时备份数据的系统中，可以使用这个线程池来定期执行备份任务。
>
> - **ExecutorService 接口**：
>
>   - 它是`Executor`接口的扩展，提供了更多的功能，如管理任务的生命周期、关闭线程池等。
>
>     ```java
>     ExecutorService executorService = Executors.newFixedThreadPool(5);
>     Future<?> future = executorService.submit(new Runnable() {
>         @Override
>         public void run() {
>             System.out.println("Task submitted to executor service");
>         }
>     });
>     executorService.shutdown();
>     ```
>
> - **ThreadPoolExecutor 类**
>
>   - 参数：1.核心线程数 2.最大线程数 3.存活时间 4.时间单位 5.任务队列 6.线程工程 7.拒绝策略
>
>     ```java
>     BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
>     ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
>             3, // corePoolSize
>             5, // maximumPoolSize
>             60L, // keepAliveTime
>             TimeUnit.SECONDS, // unit
>             workQueue,
>             Executors.defaultThreadFactory(),
>             new ThreadPoolExecutor.AbortPolicy()
>     );
>     ```
>
> - **ThreadPoolTaskScheduler**
>
>   - `ThreadPoolTaskScheduler`主要用于定时任务的调度和执行，它也是基于线程池的。它允许你设置定时任务的执行时间、周期等参数。

## 12. 说一下线程池的各个参数的含义？

> 1.corePoolsize:（可为0）、2.maximumPoolSize:（最大线程数、必须大于0且大于核心）、3.keepAliveTime、4.unit、5.workQueue、6.threadFactory、7.RejectedExecutionHandler

## 13. 线程工厂有什么用?

> 线程工厂（ThreadFactory）是一个接口，它的主要作用是创建新的线程。
>
> ```java
> import java.util.concurrent.ThreadFactory;
> 
> class MyThreadFactory implements ThreadFactory {
>     private int threadNumber = 1;
>     private String prefix = "MyThread-";
> 
>     @Override
>     public Thread newThread(Runnable r) {
>         // 创建一个新的线程
>         Thread t = new Thread(r);
>         // 设置线程名称
>         t.setName(prefix + threadNumber);
>         // 递增线程编号，以便下一个线程使用
>         threadNumber++;
>         // 设置线程优先级，这里设置为默认优先级
>         t.setPriority(Thread.NORM_PRIORITY);
>         // 设置线程为非守护线程
>         t.setDaemon(false);
>         return t;
>     }
> }
> 
> public class ThreadFactoryExample {
>     public static void main(String[] args) {
>         // 创建自定义的线程工厂
>         MyThreadFactory threadFactory = new MyThreadFactory();
>         // 创建一个 Runnable 对象，包含线程要执行的任务
>         Runnable task = () -> {
>             System.out.println("Thread is running: " + Thread.currentThread().getName());
>         };
>         // 使用线程工厂创建新线程
>         Thread thread1 = threadFactory.newThread(task);
>         Thread thread2 = threadFactory.newThread(task);
>         // 启动线程
>         thread1.start();
>         thread2.start();
>     }
> }
> ```

## 14. 线程池是如何运行的？

> 核心线程-任务队列-最大线程数-拒绝策略

## 15. 线程池的拒绝策略有哪些?

> 拒绝策略
>
> - **AbortPolicy**默认：当线程池和任务队列都满了，新任务提交时，会直接抛出`RejectedExecutionException`异常。
>   - **适用场景**：这种策略比较适合对任务提交的可靠性要求较高的场景。例如，在一个订单处理系统中，如果线程池无法处理新的订单任务，抛出异常可以让上层系统及时捕获并采取相应的补救措施，如提示用户稍后再试或者将订单信息存储起来等待后续处理。
> - **CallerRunsPolicy**:当线程池和任务队列都满了，新任务会在提交任务的线程中直接执行。这样做的好处是可以降低新任务被拒绝的概率，但是会增加提交任务线程的负担。
>   - **适用场景**：适用于不希望任务被直接拒绝，并且提交任务的线程有能力执行任务的情况。比如在一个简单的工具类应用中，任务相对较轻，即使在主线程中执行这些额外的任务也不会对整体性能产生太大影响。
> - **DiscardPolicy**:当线程池和任务队列都满了，新任务会被直接丢弃，不会抛出异常，也不会执行。
>   - **适用场景**：适用于对任务丢失不太敏感的场景。例如，在一个日志收集系统中，如果日志收集任务过多，丢弃一些不太重要的日志任务不会对系统的核心功能产生太大影响，因为日志主要是用于辅助分析，丢失部分日志可以接受。
> - **DiscardOldestPolicy**:当线程池和任务队列都满了，会丢弃任务队列中最旧的任务，然后将新任务添加到队列中。
>   - **适用场景**：适用于任务有一定时效性，并且新任务比旧任务更重要的场景。例如，在一个实时数据处理系统中，新的数据可能比旧的数据更有价值，当线程池无法处理所有任务时，丢弃最旧的数据任务来为新任务腾出空间。

## 16. 如何实现自定义拒绝策略?  

> 实现RejectedExecutionHandler接口的rejectedExecution方法
>
> ```java
> package org.example;
> 
> import java.util.concurrent.*;
> 
> class CustomRejectedExecutionHandler implements RejectedExecutionHandler {
>     @Override
>     public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
>         // 自定义的拒绝处理逻辑
>         System.out.println("Task " + r.toString() + " is rejected.");
>         // 这里可以添加更多的逻辑，例如将任务保存到其他存储位置，或者记录日志
>     }
> }
> 
> public class CustomRejectedStrategyExample {
>     public static void main(String[] args) {
>         // 核心线程数
>         int corePoolSize = 2;
>         // 最大线程数
>         int maximumPoolSize = 4;
>         // 线程存活时间
>         long keepAliveTime = 1;
>         // 存活时间的单位
>         TimeUnit unit = TimeUnit.SECONDS;
>         // 任务队列，使用 LinkedBlockingQueue
>         BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(1);
>         // 自定义线程工厂
>         ThreadFactory threadFactory = Executors.defaultThreadFactory();
>         // 自定义拒绝策略
>         RejectedExecutionHandler handler = new CustomRejectedExecutionHandler();
> 
>         // 创建 ThreadPoolExecutor 线程池
>         ThreadPoolExecutor executor = new ThreadPoolExecutor(
>                 corePoolSize,
>                 maximumPoolSize,
>                 keepAliveTime,
>                 unit,
>                 workQueue,
>                 threadFactory,
>                 handler);
> 
>         // 创建 Runnable 任务
>         Runnable task = () -> {
>             System.out.println("Thread is running: " + Thread.currentThread().getName());
>             try {
>                 // 模拟任务执行时间
>                 Thread.sleep(1000);
>             } catch (InterruptedException e) {
>                 e.printStackTrace();
>             }
>         };
> 
>         // 向线程池提交大量任务，使线程池进入饱和状态，触发拒绝策略
>         for (int i = 0; i < 10; i++) {
>             executor.execute(task);
>         }
> 
>         // 关闭线程池
>         executor.shutdown();
>         try {
>             // 等待一段时间，确保所有任务完成
>             if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
>                 // 如果超时，强制关闭线程池
>                 executor.shutdownNow();
>             }
>         } catch (InterruptedException e) {
>             // 处理中断异常
>             executor.shutdownNow();
>             Thread.currentThread().interrupt();
>         }
>     }
> }
> ```

## 17. 如何判断线程池中的任务是否执行完成?

> - `executorService.awaitTermination(10, TimeUnit.SECONDS)` 会阻塞当前线程，等待线程池中的任务完成。如果在 10 秒内所有任务完成，它将返回 `true`，表示任务完成；否则返回 `false`。
> - `executorService.isTerminated()` 方法用于检查线程池是否已经终止，即所有任务是否都已完成。
> - `CountDownLatch latch = new CountDownLatch(taskCount);` 创建一个 `CountDownLatch`，其初始计数值为任务的数量。在每个任务的 `finally` 块中，使用 `latch.countDown()` 方法，确保无论任务是否正常完成，计数器都会减一。
> - `executorService.invokeAll(tasks)` 方法将提交一个 `Callable` 任务列表，并返回一个 `Future` 列表。`future.isDone()` 可以检查每个 `Future` 是否完成。

## 18. Java中导致线程安全问题的因素有哪些? 

> 1、多个线程同时执行 2、操作共享数据 3、非院子操作 4、指令重排序 5、内存可见效问题

## 19. 如何解决线程安全问题?

> 1、synchronized关键字 2、ReentrantLock 3、Atomic类 4、volaitle 5、线程安全的类 6、Juc包下的类

## 20. synchronized和ReentrantLock?

> - 对于简单的同步需求，使用 `synchronized` 更简洁方便，代码易读性好。
> - 对于需要更高级的同步功能，如公平锁、可中断锁、条件变量等，或者需要使用 `tryLock` 进行尝试获取锁的场景，使用 `ReentrantLock`。

## 21. volatile能保证线程安全吗?

> 能保证：可见性、有序性

## 22. volatile使用场景有哪些? 

> 状态标志、单例模式

## 23. 为什么双重效验锁一定要加volatile?

> 防止重新排序导致返回的实例是null

## 24.什么是JMM？JMM有什么问题？如何解决?

> - JMM定义了主内存和工作内存，为了屏蔽不同硬件和操作系统的内存访问差异，确保 Java 程序在不同平台上的一致性和正确性。
> - 导致的问题：内存可见性、指令重排序
> - 解决办法：volatile

## 25. 说一下volatile的实现原理?

> - 可见性的实现：内存屏障
>   - 当一个 `volatile` 变量被写时，Java 编译器会在生成的字节码中插入一个 `StoreStore` 屏障，该屏障会确保在将 `volatile` 变量的新值刷新到主内存之前，前面的所有普通写操作已经完成。
>   - 同时，会插入一个 `StoreLoad` 屏障，该屏障会确保 `volatile` 变量的新值刷新到主内存之后，才会执行后续的读操作。
>   - 当一个 `volatile` 变量被读时，会插入一个 `LoadLoad` 屏障和一个 `LoadStore` 屏障，确保后续的读操作和写操作不会重排到该 `volatile` 变量的读操作之前。
> - **防止指令重排序的实现**
>   - 同样通过内存屏障实现：
>     - `LoadLoad` 屏障：确保 `volatile` 读操作不会与之前的读操作重排序。
>     - `LoadStore` 屏障：确保 `volatile` 读操作不会与后续的写操作重排序。
>     - `StoreStore` 屏障：确保 `volatile` 写操作不会与之前的写操作重排序。
>     - `StoreLoad` 屏障：确保 `volatile` 写操作不会与后续的读操作重排序。

## 26. 什么是ThreadLocal?它底层是如何实现的?

> - ThreadLocal 是 Java 中的一个类，它提供了线程局部变量。ThreadLocal 为每个使用该变量的线程提供一个独立的副本，各个线程之间互不干扰，这样可以避免多线程环境下的并发问题。
>
> - **内部结构**：`ThreadLocalMap` 来存储线程的局部变量,`ThreadLocalMap` 是一个自定义的哈希表，它类似于 `HashMap`，但专门为 ThreadLocal 设计，使用弱引用（WeakReference）来存储键（ThreadLocal 实例），以避免内存泄漏。
>
>   - key为什么用弱饮用：如果一个线程的生命周期很长，并且使用 `ThreadLocal` 存储了一些数据，即使 `ThreadLocal` 实例在外部已经不再使用，由于 `ThreadLocalMap` 中使用强引用存储 `ThreadLocal` 实例作为键，那么只要该线程不结束，`ThreadLocalMap` 中的 `ThreadLocal` 实例就不会被回收，导致该 `ThreadLocal` 实例和其关联的 `value` 都无法被垃圾回收，从而造成内存泄漏。
>
>   ```java
>   public class ThreadLocalExample {
>       private static ThreadLocal<Integer> threadLocal = new ThreadLocal<>() {
>           protected Integer initialValue() {
>               return 0;
>           }
>       };
>       
>       public static void main(String[] args) {
>           Thread thread1 = new Thread(() -> {
>               threadLocal.set(threadLocal.get() + 1);
>               System.out.println("线程1的threadLocal" + threadLocal.get());
>           });
>           Thread thread2 = new Thread(() -> {
>               threadLocal.set(threadLocal.get() + 1);
>               System.out.println("线程2的threadLocal" + threadLocal.get());
>           });
>           thread1.start();
>           thread2.start();
>       }
>   }
>   ```

## 27. ThreadLocal为什么会导致内存泄漏?

> 使用弱引用（WeakReference）来存储键（ThreadLocal 实例），以避免内存泄漏。
>
> - key为什么用弱饮用：如果一个线程的生命周期很长，并且使用 `ThreadLocal` 存储了一些数据，即使 `ThreadLocal` 实例在外部已经不再使用，由于 `ThreadLocalMap` 中使用强引用存储 `ThreadLocal` 实例作为键，那么只要该线程不结束，`ThreadLocalMap` 中的 `ThreadLocal` 实例就不会被回收，导致该 `ThreadLocal` 实例和其关联的 `value` 都无法被垃圾回收，从而造成内存泄漏。

## 28. synchronized底层是如何实现的?

> - JVM层面的监视器

## 29. 监视器Monitor是如何实现的? 

> - 每个对象头中有：count(当前线程上锁次数)、recursions(线程重入次数)、owner(当前拥有者)、EntryList(阻塞队列)、WaitSet(等待队列)
> - 流程：
>   - 1. CAS对比并替换，上锁。如果失败则自旋获取锁，还是失败则进入阻塞队列（CAS-自旋-阻塞队列）
>   - 2. 如果使用了wait，则线程进入wait等待。owner为null
>     3. notify则唤醒
>     4. 线程执行结束，获取阻塞队列中的锁

## 30. 说一下synchronized锁升级的流程?

> - 无锁：没有线程使用
> - 偏向锁：在对象头中设置线程的ID
> - 轻量级锁：CAS获取不到线程，则设置轻量级锁-自旋锁
> - 重量级锁：进入阻塞状态

## 31. 悲观锁和乐观锁有什么区别?

>- 悲观锁：在事务开始处理数据时，就会对数据进行加锁，以防止其他事务对该数据进行访问和修改，直到当前事务完成并释放锁为止。
>  乐观锁：只有在提交更新数据的时候，才会检查数据在读取之后是否被其他事务修改过。如果没有被修改，就可以正常提交更新；如果发现数据已经被修改，那么就需要根据具体的业务逻辑来决定是重试操作还是抛出异常等。
>
>- 悲观锁：sql+for update
>
>  乐观锁：用时间戳或者版本号实现

## 32. 乐观锁底层是如何实现的? 

> CAS对比并替换

## 33. 什么是ABA问题?如何解决ABA问题? 

> A 被改成了B后 又改成了A
>
> 使用版本号或者时间戳解决ABA

## 34. 说一下CAS在Java中应用? 
> 1. **`java.util.concurrent.atomic`包下的原子类**
> 2. **`ConcurrentHashMap`的部分操作**：`ConcurrentHashMap`是一个高效的并发哈希映射表。它在一些操作（如`putIfAbsent()`等方法）中使用了 CAS 机制来提高并发性能。

## 35. ReentrantLock底层是如何实现的? 

> - 基本构造：**AQS（是用于构造锁和同步器的框架，维护了一个同步队列FIFO队列）+状态变量（用于记录锁被冲入的次数）**
> - 可以实现公平锁和非公平锁。

## 36. 产生死锁的因素有哪些? 

> 1. 互斥条件：资源只能被一个线程占有
> 2. 请求与保持：线程在持有了一个资源后，又请求新资源，并且不会释放原有资源
> 3. 不可剥夺：资源在被一个线程占用后，不能被其他线程强行剥夺。
> 4. 环路等待：两个资源相互等待被释放。

## 37. 如何排查死锁? 

> 1. **jstack**:生成 Java 虚拟机中线程的栈信息。
> 2. **VisualVM**：

## 38. 解决死锁？

> 1. 破坏死锁的条件 2.死锁预防 3.死锁避免 4.死锁检测和恢复 5.锁超时 6.轮询锁 7.顺序锁

# 一般面试题：

## 1. 线程有几种创建方式?
1. 继承 Thread 类，重写 run()方法。
2. 实现 Runnable 接口，实现 run()方法。
3. 实现 Callable 接口，实现 cal()方法。
4. 通过线程池创建。

## 2. 什么是用户线程和守护线程?它们有什么区别?

> 用户线程：执行任务的线程。
>
> 守护线程：辅助用户线程执行的线程。

## 3. 说一下JUC?  ★

>JUC 四个著名的类
>1. ReentrantLock：
>2. Semaphore(基于计数器实现的限流器)：停车场
>3. CountDownLatch：只能用一次
>4. CyclicBarrier：公交车站
>5. ThreadPoolExecutor
>6. Atomic
>7. 阻塞队列

## 4. Semaphore有什么用?它底层是如何实现的?

> 停车场
>
> release-acquire-tryAcquire

## 5. CountDownLatch和CyclicBarrier有什么区别?

> CountDownLatch：latch.countDown();只能一次
>
> CyclicBarrier：barrier.await();可以多次

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        int numThreads = 3;
        CountDownLatch latch = new CountDownLatch(numThreads);

        Runnable task = () -> {
            try {
                // 模拟一些工作
                System.out.println(Thread.currentThread().getName() + " 开始工作");
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + " 完成工作");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                latch.countDown(); // 完成工作后，计数器减 1
            }
        };

        // 启动多个线程
        for (int i = 0; i < numThreads; i++) {
            new Thread(task).start();
        }

        // 等待所有线程完成工作
        latch.await(); 
        System.out.println("所有工作已完成");
    }
}
```

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class ParallelIterativeComputation {
    public static void main(String[] args) {
        int numThreads = 3;
        int numIterations = 5;
        CyclicBarrier barrier = new CyclicBarrier(numThreads, () -> {
            System.out.println("完成一轮迭代，开始下一轮");
        });

        Runnable computationTask = () -> {
            for (int i = 0; i < numIterations; i++) {
                try {
                    System.out.println(Thread.currentThread().getName() + " 开始第 " + i + " 轮计算");
                    Thread.sleep((long) (Math.random() * 1000));
                    System.out.println(Thread.currentThread().getName() + " 完成第 " + i + " 轮计算");
                    barrier.await(); // 等待其他线程完成该轮计算
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }
        };

        for (int i = 0; i < numThreads; i++) {
            new Thread(computationTask).start();
        }
    }
}
```



## 6. 什么是AQS?
> AQS：同步队列+CAS获取锁
>
> AQS 主要提供了以下几个核心方法：1、release 2、acquire 3、tryRelease 4、tryAcquire

## 7. AQS的执行流程



## 8. 核心线程数为0时，线程池如何执行?



## 9. 说说Java中的锁机制?（锁的作用、分类、实现）
Java 中的锁(Locking)机制主要是为了解决多线程环境下，对共享资源并发访问时的同步和互斥控制，以确保共享资源的安全访问。

- **锁的作用主要体现在以下几个方面:**
  1. 互斥访问:确保在任何时刻，只有一个线程能够访问特定的资源或执行特定的代码段。这防止了多个线程同时修改同一资源导致的数据不一致问题。
  2. 内存可见性:通过锁的获取和释放，可以确保在锁保护的代码块中对共享变量的修改对其他线程可见。这是因2 为 Java 内存模型 (JMM)规定，对锁的释放会把修改过的共享变量从线程的工作内存刷新到主内存中，而获取锁时会从主内存中读取最新的共享变量值。
  3. 保证原子性:锁能够保证在其保护的代码块内，一系列操作是不可分割的整体即原子操作。这意味着在多线程环境下，这些操作不会被线程调度机制打断，从而避免了数据的不完整修改。
  4. 同步:协调线程间的执行顺序，使得某些操作在另一些操作完成之后再执行，保证程序的逻辑正确性。例如，一个线程在写入数据之后，另一个线程才能读取该数据，以确保读取到的数据是最新的。

- **在 Java 中有很多锁策略，用于对锁进行分类和指导锁的(具体)实现，这些锁策略包括以下内容**
  1. 乐观锁:它基于一种乐观的思想，即认为数据一般情况下不会造成冲突，所以不会立即加上锁，而是在数据进行更新提交的时候再进行检查。如果发生冲突，则返回错误信息，让用户决定如何去做。
  2. 悲观锁:它总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
  3. 自旋锁:如果持有锁的线程能在很短时间内释放锁，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋就是空循环)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。
  4. 可重入锁(递归锁):指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获得该锁的代码。即，线程可以进入任何一个它已经拥有的锁所同步着的代码块。
  5. 读写锁:在读写场景中，读操作可以并发进行，但写操作需要互斥进行。通过读写锁可以实现读写分离，提高系统的并发性能。
  6. 公平锁/非公平锁:公平锁是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先到先得。非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。
  7. 共享锁/独占锁:共享锁允许多个线程同时读取一个资源，而独占锁则只允许一个线程访问资源。
  8. 轻量级锁/重量级锁:这些是 Java 在 JVM 层面对 synchronized 锁的优化，以减少线程之间的竞争和提高程序的性能。
  9. 分段锁:将一把锁分成多段，允许不同的线程同时访问不同的段，从而提高了并发访问的性能。
  10. 同步锁:Java 内建的一种同步机制，例如 synchronized，它可以修饰方法或代码块，用于保护共享资源的访问。

- **锁实现：**
  在 Java 中也有一些具体的锁实现，用于代码层面的锁操作以此来保证线程安全的，这些常见的锁实现有以下几个:
  1. synchronized:内置锁(Monitor Lock)，可以用于方法或代码块，提供互斥访问。当一个线程进入synchronized 方法或块时，它会自动获取对象的锁，其他线程则需等待锁释放后才能进入。
  2. ReentrantLock:是一个重入锁，是 java,util.concurrent.ocks 包中的接口 Lock 的实现，提供了比synchronized 更灵活的锁操作，如尝试获取锁、可中断的获取锁、超时获取锁等。它也支持公平锁和非公平锁策略。
  3. ReentrantReadWriteLock(读写锁):也是java.util.concurrent,locks 包中的一部分，允许同时有多个读取者，但只允许一个写入者。它分为读锁和写锁，读锁之间不互斥，读锁与写锁互斥，写锁之间也互斥，适用于读多写少的场景。
  4. StampedLock(Java8引入):提供了三种锁模式:读锁、写锁和乐观读锁。相较于4ReentrantReadWriteLock，StampedLock 提供了更细粒度的控制，支持乐观读取操作，可以提高并发性能。

下面我将为你展示如何在Java中使用`synchronized`关键字、`ReentrantLock`、`ReentrantReadWriteLock`和`StampedLock`。每种锁都有其适用场景，了解它们的用法可以帮助你更好地控制多线程程序的并发访问。

1. 使用`synchronized`关键字

`synchronized`可以用来修饰方法或者代码块，保证在同一时刻最多只有一个线程执行该段代码。

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

2. 使用`ReentrantLock`

`ReentrantLock`是一个可重入的互斥锁，与`synchronized`有相似的基本行为和语义，但提供了更高的扩展性。

```java
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

3. 使用`ReentrantReadWriteLock`

`ReentrantReadWriteLock`支持一对相关的锁：一个用于只读操作，另一个用于写操作。读锁可以由多个线程同时持有，只要没有线程持有写锁即可。写锁是独占的。

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class Counter {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private int count = 0;

    public void increment() {
        rwLock.writeLock().lock();
        try {
            count++;
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    public int getCount() {
        rwLock.readLock().lock();
        try {
            return count;
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
```

4. 使用`StampedLock`

`StampedLock`是Java 8引入的一种新的锁机制，它可以看成是读写锁的一个改进版本。它提供了一种乐观读锁的策略，这种策略在很多情况下能够减少读锁的争用。

```java
import java.util.concurrent.locks.StampedLock;

public class Counter {
    private final StampedLock lock = new StampedLock();
    private int count = 0;

    public void increment() {
        long stamp = lock.writeLock();
        try {
            count++;
        } finally {
            lock.unlockWrite(stamp);
        }
    }

    public int getCount() {
        long stamp = lock.tryOptimisticRead();
        int copy = count;
        if (!lock.validate(stamp)) {
            stamp = lock.readLock();
            try {
                copy = count;
            } finally {
                lock.unlockRead(stamp);
            }
        }
        return copy;
    }
}
```

每种锁都有其特定的使用场景和性能特点，选择哪种锁取决于你的具体需求。
## 10. 什么锁比读写锁性能更高?
在并发编程中，读写锁 ReentrantReadWriteLock 的性能已经算是比较高的了，因为它将悲观锁的粒度分的更细在它里面有读锁和写锁，当所有操作为读操作时，并发线程是可以共享读锁同时运行的，这样就无需排队执行了所以执行效率也就更高。
那么问题来了，有没有比读写锁 ReentrantReadWriteLock 性能更高的锁呢?答案是有的，在 Java 中，比 ReentrantReadWriteLock 性能更高的锁有以下两种:

1. 乐观锁:乐观锁是一种非阻塞锁机制，它是通过 Compare-And-Swap(CAS)对比并替换来进行数据的更改的，它假设多个线程(或进程)之间很少会发生冲突，因此不会加锁，只有在需要修改之后，通过对比并替换来修改共享变量的值，因此它在非高并发的环境下的性能是非常高的。
2. StampedLock:它是 JDK8 中新增的锁类型，它提供了三种锁模式:读锁、写锁和乐观读锁。相较于ReentrantReadWriteLock，StampedLock 提供了更细粒度的控制，支持乐观读取操作，可以提高并发性能。

## 11. 如何实现线程任务编排?
线程任务编排指的是对多个线程任务按照一定的逻辑顺序或条件进行组织和安排，以实现协同工作、顺序执行或并行执行的一种机制。

**线程任务编排 VS 线程通讯**

有同学可能会想:那线程的任务编排是不是问的就是线程间通讯啊?线程间通讯我知道了，它的实现方式总共有以下几种方式:

 1. Object 类下的 wait()、notify()和 notifyAll()方法,
2. Condition 类下的 await()、signal()和 signalAll()方法;
3. LockSupport 类下的 park()和 unpark()方法。

但是，线程通讯和线程的任务编排是不同的两个概念，它们的区别如下:
==线程任务编排主要关注的是如何组织和管理线程执行的任务序列，确保任务按照预定的逻辑和顺序执行，包括任务的启动、停止、依赖管理、执行策略(如并行、串行)以及错误处理等。它是关于如何有效地规划线程的工作流程，以达成高效和正确的程序执行目标。==

线程通讯则是指在多线程环境中，线程之间传递信息和协调工作的机制。当多个线程需要共享数据或协同完成某项任务时，它们需要通过某种方式进行沟通，以确保数据的正确性和任务的同步执行。==它的重点在于解决线程间的同步问题和数据一致性问题。==
==简而言之，线程任务编排侧重于高层次的执行计划和流程控制，而线程通讯则专注于底层的数据交互和同步细节== 。在实际应用中，有效的线程任务编排往往离不开合理的线程通讯机制，两者相辅相成，共同支撑起复杂多线程程序的正确执行。

**线程的任务编排的实现方式主要有以下两种:**
1. FutureTask:诞生于 JDK 1.5，它实现了 Future 接口和 Runnable 接口，设计初衷是为了支持可取消的异步计算，它既可以承载 Runnable 任务(通过包装成 RunnableAdapter)，也可以承载 Callable 任务，从而能够返回计算结果，使用它可以实现简单的异步任务执行和结果的等待，
2. CompletableFuture:诞生于 JDK8，它不仅实现了 Future 接口，还实现了 CompletionStage 接口。CompletionStage 是对 Future 的扩展，提供了丰富的链式异步编程模型，支持函数式编程风格，可以更加灵活地处理异步操作的组合和依赖回调等。

在Java中，可以使用`FutureTask`和`CompletableFuture`来实现线程任务编排。下面我将分别用代码举例说明它们的用法。

 使用`FutureTask`实现线程任务编排

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class FutureTaskExample {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        FutureTask<Integer> task1 = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                Thread.sleep(2000);
                return 1;
            }
        });

        FutureTask<Integer> task2 = new FutureTask<>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                Thread.sleep(1000);
                return 2;
            }
        });

        new Thread(task1).start();
        new Thread(task2).start();

        int result1 = task1.get();
        int result2 = task2.get();

        System.out.println("Result 1: " + result1);
        System.out.println("Result 2: " + result2);
    }
}
```

使用`CompletableFuture`实现线程任务编排

```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 1;
        });

        CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return 2;
        });

        CompletableFuture<Integer> combinedFuture = future1.thenCombine(future2, (result1, result2) -> result1 + result2);

        combinedFuture.thenAccept(result -> System.out.println("Combined Result: " + result));
        
        // 等待所有任务完成
        combinedFuture.join();
    }
}
```

以上是使用`FutureTask`和`CompletableFuture`实现线程任务编排的示例代码。在实际开发中，可以根据具体需求选择合适的方式来管理和编排线程任务。
## 12. 如何实现优先级线程池?
在Java中实现优先级线程池可以通过`PriorityBlockingQueue`和`ThreadPoolExecutor`来实现。`PriorityBlockingQueue`是一个支持优先级的无界阻塞队列，可以用来存储具有优先级的任务。`ThreadPoolExecutor`是一个线程池的实现类，可以用来管理线程池中的线程。

下面是一个简单的示例代码，演示如何实现一个优先级线程池：

```java
import java.util.concurrent.*;

public class PriorityThreadPoolExample {
    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                2, // 核心线程数
                5, // 最大线程数
                1, // 空闲线程存活时间
                TimeUnit.SECONDS, // 时间单位
                new PriorityBlockingQueue<>()); // 优先级阻塞队列

        for (int i = 0; i < 10; i++) {
            int priority = i % 3; // 模拟不同优先级的任务
            executor.execute(new PriorityTask(priority, i));
        }

        executor.shutdown();
    }

    static class PriorityTask implements Runnable, Comparable<PriorityTask> {
        private int priority;
        private int id;

        public PriorityTask(int priority, int id) {
            this.priority = priority;
            this.id = id;
        }

        @Override
        public void run() {
            System.out.println("Task " + id + " with priority " + priority + " is running.");
        }

        @Override
        public int compareTo(PriorityTask o) {
            return Integer.compare(this.priority, o.priority);
        }
    }
}
```

在这个示例中，我们创建了一个`ThreadPoolExecutor`，使用`PriorityBlockingQueue`作为任务队列，然后定义了一个`PriorityTask`类来表示具有优先级的任务。在`PriorityTask`类中，我们实现了`Comparable`接口，根据任务的优先级进行比较。

通过这样的方式，我们可以实现一个简单的优先级线程池，根据任务的优先级来执行任务。

## 13. 为什么stampedLock会导致CPU100%?

StampedLock 是 Java8引入的一种高级的锁机制，它位于 java.util.concurrent.locks 包中，与传统的读写锁(ReentrantReadWriteLock)相比，StampedLock 提供了更灵活和更高性能的锁解决方案，尤其适用于读操作远多于写操作的场景。

**1.特点展示**
相比于 Java 中的其他锁，StampedLock 具有以下特点:

1. 读写分离:StampedLock 支持读写分离，读锁和写锁可以同时被不同的线程持有，从而提高了并发性能。而synchronized 和 ReentrantLock 则不支持读写分离，读操作和写操作会相互阻塞
2. 乐观读:StampedLock 支持乐观读，读操作不会阻塞写操作，只有在写操作发生时才会升级为悲观读。这种方式适用于读多写少的场景，可以提高读操作的并发性能。而 ReentrantReadWriteLock 则不支持乐观读。
3. 不可重入:ReentrantLock 和 synchronized 都是可重入锁，而 StampedLock 的写锁是不可重入的。
4. 性能优势:StampedLock 在多线程并发中的读多情况下有更好的性能，因为 StampedLock 获取乐观读锁时不需要通过 CAS 操作来设置锁的状态，只是简单地通过测试状态即可。

**2.基本使用**
StampedLock 有三种读写方法:
1. readLock():读锁，用于多线程并发读取共享资源。
2. writeLock():写锁，用于独占写入共享资源。
3. tryOptimisticRead():读乐观锁，用于在不阻塞其他线程的情况下尝试读取共享资源。

其中 readLock()和 writeLock()方法与 ReentrantReadWriteLock 的用法类似，而 tryOptimisticRead()方法则是StampedLock 引入的新方法，它用于非常短的读作，
因此，我们在加锁时，可以使用性能更高的读乐观锁来替代传统的读锁，如果能加锁成功，则它可以和其他线程(即使是写操作)一起执行，也无需排队运行(传统读锁遇到写锁时需要排队执行)，这样的话StampedLock 的执行效率就会更高，它是使用如下:

```java
import java.util.concurrent.locks.StampedLock;

public class StampedLockExample {
    private double x, y;
    private final StampedLock sl = new StampedLock();

    // Write method
    public void move(double deltaX, double deltaY) {
        long stamp = sl.writeLock();
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            sl.unlockWrite(stamp);
        }
    }

    // Optimistic read method
    public double distanceFromOrigin() {
        long stamp = sl.tryOptimisticRead();
        double currentX = x, currentY = y;
        if (!sl.validate(stamp)) {
            stamp = sl.readLock();
            try {
                currentX = x;
                currentY = y;
            } finally {
                sl.unlockRead(stamp);
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
```




**3.注意事项**
在使用 StampedLock 时，需要注意以下几个问题:
1. 不可重入性:StampedLock 的读锁和写锁都不支持重入，这意味着一个线程在获取了锁之后，不能再次获取同一个锁，所以在使用 StampedLock 时，一定要避免嵌套使用。
2. 死锁问题:使用 StampedLock 时，必须使用与获取锁时相同的 stamp 来释放锁，否则就会导致释放锁失败从而导致死锁问题的发生。
3. CPU 使用率飙升问题:如果 StampedLock 使用不当，具体来说，在 StampedLock 执行 writeLock 或readLock 阳塞时，如果调用了中断操作，如 interrupt()可能会导致 CPU 使用率飙升。这是因为线程接收到了中断请求，但 StampedLock 并没有正确处理中断信号，那么线程可能会陷入无限循环中，试图从中断状态中恢复，这可能会导致 CPU 使用率飙升。


以下代码中线程 2 会导致 CPU 100% 的问题，如下代码所示:

```java
public void runningTask()throws Exception{
	final stampedLock lock =new stampedLock();
	Thread thread = new Thread(()->{
	// 获取写锁
	lock.writeLock();// 永远阻塞在此处，不释放写锁
	Locksupport.park();
	});
	thread.start();
	// 保证 thread 获取写锁
	Thread.sleep(100);
	Thread thread2 = new Thread(()->
		// 阻塞在悲观读锁
		lock.readLock()
	);
	thread2.start();
	// 保证 thread2 阻塞在读锁
	Thread.sleep(100);
	// 中断线程 thread2，导致 thread2 CPu 飙升
	thread2.interrupt();
	thread2.join();
}
```
以上代码中，线程一先获取到锁，之后阻塞，并未释放锁，而线程二阻塞在 readLock()读锁时，收到了中断请求interrupt()，但并未正确处理中断异常，因此线程会陷入无限循环中，试图从中断状态中恢复，这就会导致 CPU 使用率一直飙升。
**5.如何解决 CPU 100%?**
StampedLock 可能会导致 CPU 100% 是因为使用了 interrupt()中止线程导致的，我们只需要将 interrupt() 方法换成 readLockInterruptibly()或 writeLockInterruptibly()方法中止线程即可，这两种方法提供了可中断的悲观读锁和写锁，它们允许线程在等待锁时响应中断。
也就是说 interrupt 只是设置线程的中断状态，在 StampedLock 阻塞状态时，中断状态和阻塞状态同时存在可能会导致 CPU 一直飙升;而 readLockInterruptibly 和 writeLockInterruptibly 提供了在获取锁的过程中能够响应中断的机制，通过抛出异常来通知线程中断的发生。